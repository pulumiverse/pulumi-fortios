# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'Accessproxy6ApiGateway6',
    'Accessproxy6ApiGateway6Application',
    'Accessproxy6ApiGateway6Quic',
    'Accessproxy6ApiGateway6Realserver',
    'Accessproxy6ApiGateway6RealserverSshHostKey',
    'Accessproxy6ApiGateway6SslCipherSuite',
    'Accessproxy6ApiGateway',
    'Accessproxy6ApiGatewayApplication',
    'Accessproxy6ApiGatewayQuic',
    'Accessproxy6ApiGatewayRealserver',
    'Accessproxy6ApiGatewayRealserverSshHostKey',
    'Accessproxy6ApiGatewaySslCipherSuite',
    'AccessproxyApiGateway6',
    'AccessproxyApiGateway6Application',
    'AccessproxyApiGateway6Quic',
    'AccessproxyApiGateway6Realserver',
    'AccessproxyApiGateway6RealserverSshHostKey',
    'AccessproxyApiGateway6SslCipherSuite',
    'AccessproxyApiGateway',
    'AccessproxyApiGatewayApplication',
    'AccessproxyApiGatewayQuic',
    'AccessproxyApiGatewayRealserver',
    'AccessproxyApiGatewayRealserverSshHostKey',
    'AccessproxyApiGatewaySslCipherSuite',
    'AccessproxysshclientcertCertExtension',
    'Address6List',
    'Address6Macaddr',
    'Address6SubnetSegment',
    'Address6Tagging',
    'Address6TaggingTag',
    'Address6templateSubnetSegment',
    'Address6templateSubnetSegmentValue',
    'AddressFssoGroup',
    'AddressList',
    'AddressMacaddr',
    'AddressTagging',
    'AddressTaggingTag',
    'Addrgrp6ExcludeMember',
    'Addrgrp6Member',
    'Addrgrp6Tagging',
    'Addrgrp6TaggingTag',
    'AddrgrpExcludeMember',
    'AddrgrpMember',
    'AddrgrpTagging',
    'AddrgrpTaggingTag',
    'AuthportalGroup',
    'CentralsnatmapDstAddr6',
    'CentralsnatmapDstAddr',
    'CentralsnatmapDstintf',
    'CentralsnatmapNatIppool6',
    'CentralsnatmapNatIppool',
    'CentralsnatmapOrigAddr6',
    'CentralsnatmapOrigAddr',
    'CentralsnatmapSortStatePolicyList',
    'CentralsnatmapSrcintf',
    'CountryRegion',
    'DecryptedtrafficmirrorInterface',
    'DoSpolicy6Anomaly',
    'DoSpolicy6Dstaddr',
    'DoSpolicy6Service',
    'DoSpolicy6Srcaddr',
    'DoSpolicyAnomaly',
    'DoSpolicyDstaddr',
    'DoSpolicyService',
    'DoSpolicySrcaddr',
    'IdentitybasedrouteRule',
    'IdentitybasedrouteRuleGroup',
    'Interfacepolicy6Dstaddr6',
    'Interfacepolicy6Service6',
    'Interfacepolicy6Srcaddr6',
    'InterfacepolicyDstaddr',
    'InterfacepolicyService',
    'InterfacepolicySrcaddr',
    'InternetserviceadditionEntry',
    'InternetserviceadditionEntryPortRange',
    'InternetservicecustomEntry',
    'InternetservicecustomEntryDst6',
    'InternetservicecustomEntryDst',
    'InternetservicecustomEntryPortRange',
    'InternetservicecustomgroupMember',
    'InternetservicedefinitionEntry',
    'InternetservicedefinitionEntryPortRange',
    'InternetserviceextensionDisableEntry',
    'InternetserviceextensionDisableEntryIp6Range',
    'InternetserviceextensionDisableEntryIpRange',
    'InternetserviceextensionDisableEntryPortRange',
    'InternetserviceextensionEntry',
    'InternetserviceextensionEntryDst6',
    'InternetserviceextensionEntryDst',
    'InternetserviceextensionEntryPortRange',
    'InternetservicegroupMember',
    'InternetservicesubappSubApp',
    'Localinpolicy6Dstaddr',
    'Localinpolicy6Service',
    'Localinpolicy6Srcaddr',
    'LocalinpolicyDstaddr',
    'LocalinpolicyService',
    'LocalinpolicySrcaddr',
    'Multicastaddress6Tagging',
    'Multicastaddress6TaggingTag',
    'MulticastaddressTagging',
    'MulticastaddressTaggingTag',
    'Multicastpolicy6Dstaddr',
    'Multicastpolicy6Srcaddr',
    'MulticastpolicyDstaddr',
    'MulticastpolicySrcaddr',
    'Policy46Dstaddr',
    'Policy46Poolname',
    'Policy46Service',
    'Policy46Srcaddr',
    'Policy64Dstaddr',
    'Policy64Poolname',
    'Policy64Service',
    'Policy64Srcaddr',
    'Policy6AppCategory',
    'Policy6AppGroup',
    'Policy6Application',
    'Policy6CustomLogField',
    'Policy6Device',
    'Policy6Dstaddr',
    'Policy6Dstintf',
    'Policy6FssoGroup',
    'Policy6Group',
    'Policy6Poolname',
    'Policy6Service',
    'Policy6Srcaddr',
    'Policy6Srcintf',
    'Policy6SslMirrorIntf',
    'Policy6UrlCategory',
    'Policy6User',
    'PolicyAppCategory',
    'PolicyAppGroup',
    'PolicyApplication',
    'PolicyCustomLogField',
    'PolicyDevice',
    'PolicyDstaddr6',
    'PolicyDstaddr',
    'PolicyDstintf',
    'PolicyFssoGroup',
    'PolicyGroup',
    'PolicyInternetService6Custom',
    'PolicyInternetService6CustomGroup',
    'PolicyInternetService6Group',
    'PolicyInternetService6Name',
    'PolicyInternetService6SrcCustom',
    'PolicyInternetService6SrcCustomGroup',
    'PolicyInternetService6SrcGroup',
    'PolicyInternetService6SrcName',
    'PolicyInternetServiceCustom',
    'PolicyInternetServiceCustomGroup',
    'PolicyInternetServiceGroup',
    'PolicyInternetServiceId',
    'PolicyInternetServiceName',
    'PolicyInternetServiceSrcCustom',
    'PolicyInternetServiceSrcCustomGroup',
    'PolicyInternetServiceSrcGroup',
    'PolicyInternetServiceSrcId',
    'PolicyInternetServiceSrcName',
    'PolicyNetworkServiceDynamic',
    'PolicyNetworkServiceSrcDynamic',
    'PolicyNtlmEnabledBrowser',
    'PolicyPcpPoolname',
    'PolicyPoolname6',
    'PolicyPoolname',
    'PolicyRtpAddr',
    'PolicyService',
    'PolicySgt',
    'PolicySortStatePolicyList',
    'PolicySrcVendorMac',
    'PolicySrcaddr6',
    'PolicySrcaddr',
    'PolicySrcintf',
    'PolicySslMirrorIntf',
    'PolicyUrlCategory',
    'PolicyUser',
    'PolicyZtnaEmsTag',
    'PolicyZtnaEmsTagSecondary',
    'PolicyZtnaGeoTag',
    'ProfileprotocoloptionsCifs',
    'ProfileprotocoloptionsCifsServerKeytab',
    'ProfileprotocoloptionsDns',
    'ProfileprotocoloptionsFtp',
    'ProfileprotocoloptionsHttp',
    'ProfileprotocoloptionsImap',
    'ProfileprotocoloptionsMailSignature',
    'ProfileprotocoloptionsMapi',
    'ProfileprotocoloptionsNntp',
    'ProfileprotocoloptionsPop3',
    'ProfileprotocoloptionsSmtp',
    'ProfileprotocoloptionsSsh',
    'ProxyaddressApplication',
    'ProxyaddressCategory',
    'ProxyaddressHeaderGroup',
    'ProxyaddressTagging',
    'ProxyaddressTaggingTag',
    'ProxyaddrgrpMember',
    'ProxyaddrgrpTagging',
    'ProxyaddrgrpTaggingTag',
    'ProxypolicyAccessProxy6',
    'ProxypolicyAccessProxy',
    'ProxypolicyDstaddr6',
    'ProxypolicyDstaddr',
    'ProxypolicyDstintf',
    'ProxypolicyGroup',
    'ProxypolicyInternetService6Custom',
    'ProxypolicyInternetService6CustomGroup',
    'ProxypolicyInternetService6Group',
    'ProxypolicyInternetService6Name',
    'ProxypolicyInternetServiceCustom',
    'ProxypolicyInternetServiceCustomGroup',
    'ProxypolicyInternetServiceGroup',
    'ProxypolicyInternetServiceId',
    'ProxypolicyInternetServiceName',
    'ProxypolicyPoolname',
    'ProxypolicyService',
    'ProxypolicySortStatePolicyList',
    'ProxypolicySrcaddr6',
    'ProxypolicySrcaddr',
    'ProxypolicySrcintf',
    'ProxypolicyUser',
    'ProxypolicyZtnaEmsTag',
    'RegionCity',
    'SecurityPolicyseqStatePolicyList',
    'SecuritypolicyAppCategory',
    'SecuritypolicyAppGroup',
    'SecuritypolicyApplication',
    'SecuritypolicyDstaddr4',
    'SecuritypolicyDstaddr6',
    'SecuritypolicyDstaddr',
    'SecuritypolicyDstintf',
    'SecuritypolicyFssoGroup',
    'SecuritypolicyGroup',
    'SecuritypolicyInternetService6Custom',
    'SecuritypolicyInternetService6CustomGroup',
    'SecuritypolicyInternetService6Group',
    'SecuritypolicyInternetService6Name',
    'SecuritypolicyInternetService6SrcCustom',
    'SecuritypolicyInternetService6SrcCustomGroup',
    'SecuritypolicyInternetService6SrcGroup',
    'SecuritypolicyInternetService6SrcName',
    'SecuritypolicyInternetServiceCustom',
    'SecuritypolicyInternetServiceCustomGroup',
    'SecuritypolicyInternetServiceGroup',
    'SecuritypolicyInternetServiceId',
    'SecuritypolicyInternetServiceName',
    'SecuritypolicyInternetServiceSrcCustom',
    'SecuritypolicyInternetServiceSrcCustomGroup',
    'SecuritypolicyInternetServiceSrcGroup',
    'SecuritypolicyInternetServiceSrcId',
    'SecuritypolicyInternetServiceSrcName',
    'SecuritypolicyService',
    'SecuritypolicySortStatePolicyList',
    'SecuritypolicySrcaddr4',
    'SecuritypolicySrcaddr6',
    'SecuritypolicySrcaddr',
    'SecuritypolicySrcintf',
    'SecuritypolicyUrlCategory',
    'SecuritypolicyUser',
    'ShapingpolicyAppCategory',
    'ShapingpolicyAppGroup',
    'ShapingpolicyApplication',
    'ShapingpolicyDstaddr6',
    'ShapingpolicyDstaddr',
    'ShapingpolicyDstintf',
    'ShapingpolicyGroup',
    'ShapingpolicyInternetServiceCustom',
    'ShapingpolicyInternetServiceCustomGroup',
    'ShapingpolicyInternetServiceGroup',
    'ShapingpolicyInternetServiceId',
    'ShapingpolicyInternetServiceName',
    'ShapingpolicyInternetServiceSrcCustom',
    'ShapingpolicyInternetServiceSrcCustomGroup',
    'ShapingpolicyInternetServiceSrcGroup',
    'ShapingpolicyInternetServiceSrcId',
    'ShapingpolicyInternetServiceSrcName',
    'ShapingpolicyService',
    'ShapingpolicySrcaddr6',
    'ShapingpolicySrcaddr',
    'ShapingpolicySrcintf',
    'ShapingpolicyUrlCategory',
    'ShapingpolicyUser',
    'ShapingprofileShapingEntry',
    'SnifferAnomaly',
    'SnifferIpThreatfeed',
    'SslsshprofileDot',
    'SslsshprofileFtps',
    'SslsshprofileHttps',
    'SslsshprofileImaps',
    'SslsshprofilePop3s',
    'SslsshprofileSmtps',
    'SslsshprofileSsh',
    'SslsshprofileSsl',
    'SslsshprofileSslExempt',
    'SslsshprofileSslServer',
    'TtlpolicyService',
    'TtlpolicySrcaddr',
    'Vip46Monitor',
    'Vip46Realserver',
    'Vip46SrcFilter',
    'Vip46SrcintfFilter',
    'Vip64Monitor',
    'Vip64Realserver',
    'Vip64SrcFilter',
    'Vip6Monitor',
    'Vip6Quic',
    'Vip6Realserver',
    'Vip6SrcFilter',
    'Vip6SslCipherSuite',
    'Vip6SslServerCipherSuite',
    'VipExtaddr',
    'VipGslbPublicIp',
    'VipMappedip',
    'VipMonitor',
    'VipQuic',
    'VipRealserver',
    'VipService',
    'VipSrcFilter',
    'VipSrcintfFilter',
    'VipSslCipherSuite',
    'VipSslServerCipherSuite',
    'Vipgrp46Member',
    'Vipgrp64Member',
    'Vipgrp6Member',
    'VipgrpMember',
    'GetAddress6ListResult',
    'GetAddress6MacaddrResult',
    'GetAddress6SubnetSegmentResult',
    'GetAddress6TaggingResult',
    'GetAddress6TaggingTagResult',
    'GetAddress6templateSubnetSegmentResult',
    'GetAddress6templateSubnetSegmentValueResult',
    'GetAddressFssoGroupResult',
    'GetAddressListResult',
    'GetAddressMacaddrResult',
    'GetAddressTaggingResult',
    'GetAddressTaggingTagResult',
    'GetAddrgrp6ExcludeMemberResult',
    'GetAddrgrp6MemberResult',
    'GetAddrgrp6TaggingResult',
    'GetAddrgrp6TaggingTagResult',
    'GetAddrgrpExcludeMemberResult',
    'GetAddrgrpMemberResult',
    'GetAddrgrpTaggingResult',
    'GetAddrgrpTaggingTagResult',
    'GetCentralsnatmapDstAddr6Result',
    'GetCentralsnatmapDstAddrResult',
    'GetCentralsnatmapDstintfResult',
    'GetCentralsnatmapNatIppool6Result',
    'GetCentralsnatmapNatIppoolResult',
    'GetCentralsnatmapOrigAddr6Result',
    'GetCentralsnatmapOrigAddrResult',
    'GetCentralsnatmapSrcintfResult',
    'GetDoSpolicy6AnomalyResult',
    'GetDoSpolicy6DstaddrResult',
    'GetDoSpolicy6ServiceResult',
    'GetDoSpolicy6SrcaddrResult',
    'GetDoSpolicyAnomalyResult',
    'GetDoSpolicyDstaddrResult',
    'GetDoSpolicyServiceResult',
    'GetDoSpolicySrcaddrResult',
    'GetInternetservicecustomEntryResult',
    'GetInternetservicecustomEntryDst6Result',
    'GetInternetservicecustomEntryDstResult',
    'GetInternetservicecustomEntryPortRangeResult',
    'GetInternetservicecustomgroupMemberResult',
    'GetInternetservicedefinitionEntryResult',
    'GetInternetservicedefinitionEntryPortRangeResult',
    'GetInternetserviceextensionDisableEntryResult',
    'GetInternetserviceextensionDisableEntryIp6RangeResult',
    'GetInternetserviceextensionDisableEntryIpRangeResult',
    'GetInternetserviceextensionDisableEntryPortRangeResult',
    'GetInternetserviceextensionEntryResult',
    'GetInternetserviceextensionEntryDst6Result',
    'GetInternetserviceextensionEntryDstResult',
    'GetInternetserviceextensionEntryPortRangeResult',
    'GetInternetservicegroupMemberResult',
    'GetMulticastaddress6TaggingResult',
    'GetMulticastaddress6TaggingTagResult',
    'GetMulticastaddressTaggingResult',
    'GetMulticastaddressTaggingTagResult',
    'GetPolicy46DstaddrResult',
    'GetPolicy46PoolnameResult',
    'GetPolicy46ServiceResult',
    'GetPolicy46SrcaddrResult',
    'GetPolicy64DstaddrResult',
    'GetPolicy64PoolnameResult',
    'GetPolicy64ServiceResult',
    'GetPolicy64SrcaddrResult',
    'GetPolicy6AppCategoryResult',
    'GetPolicy6AppGroupResult',
    'GetPolicy6ApplicationResult',
    'GetPolicy6CustomLogFieldResult',
    'GetPolicy6DeviceResult',
    'GetPolicy6DstaddrResult',
    'GetPolicy6DstintfResult',
    'GetPolicy6FssoGroupResult',
    'GetPolicy6GroupResult',
    'GetPolicy6PoolnameResult',
    'GetPolicy6ServiceResult',
    'GetPolicy6SrcaddrResult',
    'GetPolicy6SrcintfResult',
    'GetPolicy6SslMirrorIntfResult',
    'GetPolicy6UrlCategoryResult',
    'GetPolicy6UserResult',
    'GetPolicyAppCategoryResult',
    'GetPolicyAppGroupResult',
    'GetPolicyApplicationResult',
    'GetPolicyCustomLogFieldResult',
    'GetPolicyDeviceResult',
    'GetPolicyDstaddr6Result',
    'GetPolicyDstaddrResult',
    'GetPolicyDstintfResult',
    'GetPolicyFssoGroupResult',
    'GetPolicyGroupResult',
    'GetPolicyInternetService6CustomResult',
    'GetPolicyInternetService6CustomGroupResult',
    'GetPolicyInternetService6GroupResult',
    'GetPolicyInternetService6NameResult',
    'GetPolicyInternetService6SrcCustomResult',
    'GetPolicyInternetService6SrcCustomGroupResult',
    'GetPolicyInternetService6SrcGroupResult',
    'GetPolicyInternetService6SrcNameResult',
    'GetPolicyInternetServiceCustomResult',
    'GetPolicyInternetServiceCustomGroupResult',
    'GetPolicyInternetServiceGroupResult',
    'GetPolicyInternetServiceIdResult',
    'GetPolicyInternetServiceNameResult',
    'GetPolicyInternetServiceSrcCustomResult',
    'GetPolicyInternetServiceSrcCustomGroupResult',
    'GetPolicyInternetServiceSrcGroupResult',
    'GetPolicyInternetServiceSrcIdResult',
    'GetPolicyInternetServiceSrcNameResult',
    'GetPolicyNetworkServiceDynamicResult',
    'GetPolicyNetworkServiceSrcDynamicResult',
    'GetPolicyNtlmEnabledBrowserResult',
    'GetPolicyPcpPoolnameResult',
    'GetPolicyPoolname6Result',
    'GetPolicyPoolnameResult',
    'GetPolicyRtpAddrResult',
    'GetPolicyServiceResult',
    'GetPolicySgtResult',
    'GetPolicySrcVendorMacResult',
    'GetPolicySrcaddr6Result',
    'GetPolicySrcaddrResult',
    'GetPolicySrcintfResult',
    'GetPolicySslMirrorIntfResult',
    'GetPolicyUrlCategoryResult',
    'GetPolicyUserResult',
    'GetPolicyZtnaEmsTagResult',
    'GetPolicyZtnaEmsTagSecondaryResult',
    'GetPolicyZtnaGeoTagResult',
    'GetProfileprotocoloptionsCifResult',
    'GetProfileprotocoloptionsCifServerKeytabResult',
    'GetProfileprotocoloptionsDnResult',
    'GetProfileprotocoloptionsFtpResult',
    'GetProfileprotocoloptionsHttpResult',
    'GetProfileprotocoloptionsImapResult',
    'GetProfileprotocoloptionsMailSignatureResult',
    'GetProfileprotocoloptionsMapiResult',
    'GetProfileprotocoloptionsNntpResult',
    'GetProfileprotocoloptionsPop3Result',
    'GetProfileprotocoloptionsSmtpResult',
    'GetProfileprotocoloptionsSshResult',
    'GetProxyaddressApplicationResult',
    'GetProxyaddressCategoryResult',
    'GetProxyaddressHeaderGroupResult',
    'GetProxyaddressTaggingResult',
    'GetProxyaddressTaggingTagResult',
    'GetProxyaddrgrpMemberResult',
    'GetProxyaddrgrpTaggingResult',
    'GetProxyaddrgrpTaggingTagResult',
    'GetProxypolicyAccessProxy6Result',
    'GetProxypolicyAccessProxyResult',
    'GetProxypolicyDstaddr6Result',
    'GetProxypolicyDstaddrResult',
    'GetProxypolicyDstintfResult',
    'GetProxypolicyGroupResult',
    'GetProxypolicyInternetService6CustomResult',
    'GetProxypolicyInternetService6CustomGroupResult',
    'GetProxypolicyInternetService6GroupResult',
    'GetProxypolicyInternetService6NameResult',
    'GetProxypolicyInternetServiceCustomResult',
    'GetProxypolicyInternetServiceCustomGroupResult',
    'GetProxypolicyInternetServiceGroupResult',
    'GetProxypolicyInternetServiceIdResult',
    'GetProxypolicyInternetServiceNameResult',
    'GetProxypolicyPoolnameResult',
    'GetProxypolicyServiceResult',
    'GetProxypolicySrcaddr6Result',
    'GetProxypolicySrcaddrResult',
    'GetProxypolicySrcintfResult',
    'GetProxypolicyUserResult',
    'GetProxypolicyZtnaEmsTagResult',
]

@pulumi.output_type
class Accessproxy6ApiGateway6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "h2Support":
            suggest = "h2_support"
        elif key == "h3Support":
            suggest = "h3_support"
        elif key == "httpCookieAge":
            suggest = "http_cookie_age"
        elif key == "httpCookieDomain":
            suggest = "http_cookie_domain"
        elif key == "httpCookieDomainFromHost":
            suggest = "http_cookie_domain_from_host"
        elif key == "httpCookieGeneration":
            suggest = "http_cookie_generation"
        elif key == "httpCookiePath":
            suggest = "http_cookie_path"
        elif key == "httpCookieShare":
            suggest = "http_cookie_share"
        elif key == "httpsCookieSecure":
            suggest = "https_cookie_secure"
        elif key == "ldbMethod":
            suggest = "ldb_method"
        elif key == "samlRedirect":
            suggest = "saml_redirect"
        elif key == "samlServer":
            suggest = "saml_server"
        elif key == "sslAlgorithm":
            suggest = "ssl_algorithm"
        elif key == "sslCipherSuites":
            suggest = "ssl_cipher_suites"
        elif key == "sslDhBits":
            suggest = "ssl_dh_bits"
        elif key == "sslMaxVersion":
            suggest = "ssl_max_version"
        elif key == "sslMinVersion":
            suggest = "ssl_min_version"
        elif key == "sslRenegotiation":
            suggest = "ssl_renegotiation"
        elif key == "sslVpnWebPortal":
            suggest = "ssl_vpn_web_portal"
        elif key == "urlMap":
            suggest = "url_map"
        elif key == "urlMapType":
            suggest = "url_map_type"
        elif key == "virtualHost":
            suggest = "virtual_host"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Accessproxy6ApiGateway6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Accessproxy6ApiGateway6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Accessproxy6ApiGateway6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applications: Optional[Sequence['outputs.Accessproxy6ApiGateway6Application']] = None,
                 h2_support: Optional[str] = None,
                 h3_support: Optional[str] = None,
                 http_cookie_age: Optional[int] = None,
                 http_cookie_domain: Optional[str] = None,
                 http_cookie_domain_from_host: Optional[str] = None,
                 http_cookie_generation: Optional[int] = None,
                 http_cookie_path: Optional[str] = None,
                 http_cookie_share: Optional[str] = None,
                 https_cookie_secure: Optional[str] = None,
                 id: Optional[int] = None,
                 ldb_method: Optional[str] = None,
                 persistence: Optional[str] = None,
                 quic: Optional['outputs.Accessproxy6ApiGateway6Quic'] = None,
                 realservers: Optional[Sequence['outputs.Accessproxy6ApiGateway6Realserver']] = None,
                 saml_redirect: Optional[str] = None,
                 saml_server: Optional[str] = None,
                 service: Optional[str] = None,
                 ssl_algorithm: Optional[str] = None,
                 ssl_cipher_suites: Optional[Sequence['outputs.Accessproxy6ApiGateway6SslCipherSuite']] = None,
                 ssl_dh_bits: Optional[str] = None,
                 ssl_max_version: Optional[str] = None,
                 ssl_min_version: Optional[str] = None,
                 ssl_renegotiation: Optional[str] = None,
                 ssl_vpn_web_portal: Optional[str] = None,
                 url_map: Optional[str] = None,
                 url_map_type: Optional[str] = None,
                 virtual_host: Optional[str] = None):
        """
        :param Sequence['Accessproxy6ApiGateway6ApplicationArgs'] applications: SaaS application controlled by this Access Proxy. The structure of `application` block is documented below.
        :param str h2_support: HTTP2 support, default=Enable. Valid values: `enable`, `disable`.
        :param str h3_support: HTTP3/QUIC support, default=Disable. Valid values: `enable`, `disable`.
        :param int http_cookie_age: Time in minutes that client web browsers should keep a cookie. Default is 60 minutes. 0 = no time limit.
        :param str http_cookie_domain: Domain that HTTP cookie persistence should apply to.
        :param str http_cookie_domain_from_host: Enable/disable use of HTTP cookie domain from host field in HTTP. Valid values: `disable`, `enable`.
        :param int http_cookie_generation: Generation of HTTP cookie to be accepted. Changing invalidates all existing cookies.
        :param str http_cookie_path: Limit HTTP cookie persistence to the specified path.
        :param str http_cookie_share: Control sharing of cookies across API Gateway. same-ip means a cookie from one virtual server can be used by another. Disable stops cookie sharing. Valid values: `disable`, `same-ip`.
        :param str https_cookie_secure: Enable/disable verification that inserted HTTPS cookies are secure. Valid values: `disable`, `enable`.
        :param int id: API Gateway ID.
        :param str ldb_method: Method used to distribute sessions to real servers. Valid values: `static`, `round-robin`, `weighted`, `first-alive`, `http-host`.
        :param str persistence: Configure how to make sure that clients connect to the same server every time they make a request that is part of the same session. Valid values: `none`, `http-cookie`.
        :param 'Accessproxy6ApiGateway6QuicArgs' quic: QUIC setting. The structure of `quic` block is documented below.
        :param Sequence['Accessproxy6ApiGateway6RealserverArgs'] realservers: Select the real servers that this Access Proxy will distribute traffic to. The structure of `realservers` block is documented below.
        :param str saml_redirect: Enable/disable SAML redirection after successful authentication. Valid values: `disable`, `enable`.
        :param str saml_server: SAML service provider configuration for VIP authentication.
        :param str service: Service.
        :param str ssl_algorithm: Permitted encryption algorithms for the server side of SSL full mode sessions according to encryption strength. Valid values: `high`, `medium`, `low`.
        :param Sequence['Accessproxy6ApiGateway6SslCipherSuiteArgs'] ssl_cipher_suites: SSL/TLS cipher suites to offer to a server, ordered by priority. The structure of `ssl_cipher_suites` block is documented below.
        :param str ssl_dh_bits: Number of bits to use in the Diffie-Hellman exchange for RSA encryption of SSL sessions. Valid values: `768`, `1024`, `1536`, `2048`, `3072`, `4096`.
        :param str ssl_max_version: Highest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        :param str ssl_min_version: Lowest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        :param str ssl_renegotiation: Enable/disable secure renegotiation to comply with RFC 5746. Valid values: `enable`, `disable`.
        :param str ssl_vpn_web_portal: SSL-VPN web portal.
        :param str url_map: URL pattern to match.
        :param str url_map_type: Type of url-map. Valid values: `sub-string`, `wildcard`, `regex`.
        :param str virtual_host: Virtual host.
        """
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if h2_support is not None:
            pulumi.set(__self__, "h2_support", h2_support)
        if h3_support is not None:
            pulumi.set(__self__, "h3_support", h3_support)
        if http_cookie_age is not None:
            pulumi.set(__self__, "http_cookie_age", http_cookie_age)
        if http_cookie_domain is not None:
            pulumi.set(__self__, "http_cookie_domain", http_cookie_domain)
        if http_cookie_domain_from_host is not None:
            pulumi.set(__self__, "http_cookie_domain_from_host", http_cookie_domain_from_host)
        if http_cookie_generation is not None:
            pulumi.set(__self__, "http_cookie_generation", http_cookie_generation)
        if http_cookie_path is not None:
            pulumi.set(__self__, "http_cookie_path", http_cookie_path)
        if http_cookie_share is not None:
            pulumi.set(__self__, "http_cookie_share", http_cookie_share)
        if https_cookie_secure is not None:
            pulumi.set(__self__, "https_cookie_secure", https_cookie_secure)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ldb_method is not None:
            pulumi.set(__self__, "ldb_method", ldb_method)
        if persistence is not None:
            pulumi.set(__self__, "persistence", persistence)
        if quic is not None:
            pulumi.set(__self__, "quic", quic)
        if realservers is not None:
            pulumi.set(__self__, "realservers", realservers)
        if saml_redirect is not None:
            pulumi.set(__self__, "saml_redirect", saml_redirect)
        if saml_server is not None:
            pulumi.set(__self__, "saml_server", saml_server)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if ssl_algorithm is not None:
            pulumi.set(__self__, "ssl_algorithm", ssl_algorithm)
        if ssl_cipher_suites is not None:
            pulumi.set(__self__, "ssl_cipher_suites", ssl_cipher_suites)
        if ssl_dh_bits is not None:
            pulumi.set(__self__, "ssl_dh_bits", ssl_dh_bits)
        if ssl_max_version is not None:
            pulumi.set(__self__, "ssl_max_version", ssl_max_version)
        if ssl_min_version is not None:
            pulumi.set(__self__, "ssl_min_version", ssl_min_version)
        if ssl_renegotiation is not None:
            pulumi.set(__self__, "ssl_renegotiation", ssl_renegotiation)
        if ssl_vpn_web_portal is not None:
            pulumi.set(__self__, "ssl_vpn_web_portal", ssl_vpn_web_portal)
        if url_map is not None:
            pulumi.set(__self__, "url_map", url_map)
        if url_map_type is not None:
            pulumi.set(__self__, "url_map_type", url_map_type)
        if virtual_host is not None:
            pulumi.set(__self__, "virtual_host", virtual_host)

    @property
    @pulumi.getter
    def applications(self) -> Optional[Sequence['outputs.Accessproxy6ApiGateway6Application']]:
        """
        SaaS application controlled by this Access Proxy. The structure of `application` block is documented below.
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter(name="h2Support")
    def h2_support(self) -> Optional[str]:
        """
        HTTP2 support, default=Enable. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "h2_support")

    @property
    @pulumi.getter(name="h3Support")
    def h3_support(self) -> Optional[str]:
        """
        HTTP3/QUIC support, default=Disable. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "h3_support")

    @property
    @pulumi.getter(name="httpCookieAge")
    def http_cookie_age(self) -> Optional[int]:
        """
        Time in minutes that client web browsers should keep a cookie. Default is 60 minutes. 0 = no time limit.
        """
        return pulumi.get(self, "http_cookie_age")

    @property
    @pulumi.getter(name="httpCookieDomain")
    def http_cookie_domain(self) -> Optional[str]:
        """
        Domain that HTTP cookie persistence should apply to.
        """
        return pulumi.get(self, "http_cookie_domain")

    @property
    @pulumi.getter(name="httpCookieDomainFromHost")
    def http_cookie_domain_from_host(self) -> Optional[str]:
        """
        Enable/disable use of HTTP cookie domain from host field in HTTP. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "http_cookie_domain_from_host")

    @property
    @pulumi.getter(name="httpCookieGeneration")
    def http_cookie_generation(self) -> Optional[int]:
        """
        Generation of HTTP cookie to be accepted. Changing invalidates all existing cookies.
        """
        return pulumi.get(self, "http_cookie_generation")

    @property
    @pulumi.getter(name="httpCookiePath")
    def http_cookie_path(self) -> Optional[str]:
        """
        Limit HTTP cookie persistence to the specified path.
        """
        return pulumi.get(self, "http_cookie_path")

    @property
    @pulumi.getter(name="httpCookieShare")
    def http_cookie_share(self) -> Optional[str]:
        """
        Control sharing of cookies across API Gateway. same-ip means a cookie from one virtual server can be used by another. Disable stops cookie sharing. Valid values: `disable`, `same-ip`.
        """
        return pulumi.get(self, "http_cookie_share")

    @property
    @pulumi.getter(name="httpsCookieSecure")
    def https_cookie_secure(self) -> Optional[str]:
        """
        Enable/disable verification that inserted HTTPS cookies are secure. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "https_cookie_secure")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        API Gateway ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ldbMethod")
    def ldb_method(self) -> Optional[str]:
        """
        Method used to distribute sessions to real servers. Valid values: `static`, `round-robin`, `weighted`, `first-alive`, `http-host`.
        """
        return pulumi.get(self, "ldb_method")

    @property
    @pulumi.getter
    def persistence(self) -> Optional[str]:
        """
        Configure how to make sure that clients connect to the same server every time they make a request that is part of the same session. Valid values: `none`, `http-cookie`.
        """
        return pulumi.get(self, "persistence")

    @property
    @pulumi.getter
    def quic(self) -> Optional['outputs.Accessproxy6ApiGateway6Quic']:
        """
        QUIC setting. The structure of `quic` block is documented below.
        """
        return pulumi.get(self, "quic")

    @property
    @pulumi.getter
    def realservers(self) -> Optional[Sequence['outputs.Accessproxy6ApiGateway6Realserver']]:
        """
        Select the real servers that this Access Proxy will distribute traffic to. The structure of `realservers` block is documented below.
        """
        return pulumi.get(self, "realservers")

    @property
    @pulumi.getter(name="samlRedirect")
    def saml_redirect(self) -> Optional[str]:
        """
        Enable/disable SAML redirection after successful authentication. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "saml_redirect")

    @property
    @pulumi.getter(name="samlServer")
    def saml_server(self) -> Optional[str]:
        """
        SAML service provider configuration for VIP authentication.
        """
        return pulumi.get(self, "saml_server")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="sslAlgorithm")
    def ssl_algorithm(self) -> Optional[str]:
        """
        Permitted encryption algorithms for the server side of SSL full mode sessions according to encryption strength. Valid values: `high`, `medium`, `low`.
        """
        return pulumi.get(self, "ssl_algorithm")

    @property
    @pulumi.getter(name="sslCipherSuites")
    def ssl_cipher_suites(self) -> Optional[Sequence['outputs.Accessproxy6ApiGateway6SslCipherSuite']]:
        """
        SSL/TLS cipher suites to offer to a server, ordered by priority. The structure of `ssl_cipher_suites` block is documented below.
        """
        return pulumi.get(self, "ssl_cipher_suites")

    @property
    @pulumi.getter(name="sslDhBits")
    def ssl_dh_bits(self) -> Optional[str]:
        """
        Number of bits to use in the Diffie-Hellman exchange for RSA encryption of SSL sessions. Valid values: `768`, `1024`, `1536`, `2048`, `3072`, `4096`.
        """
        return pulumi.get(self, "ssl_dh_bits")

    @property
    @pulumi.getter(name="sslMaxVersion")
    def ssl_max_version(self) -> Optional[str]:
        """
        Highest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "ssl_max_version")

    @property
    @pulumi.getter(name="sslMinVersion")
    def ssl_min_version(self) -> Optional[str]:
        """
        Lowest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "ssl_min_version")

    @property
    @pulumi.getter(name="sslRenegotiation")
    def ssl_renegotiation(self) -> Optional[str]:
        """
        Enable/disable secure renegotiation to comply with RFC 5746. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ssl_renegotiation")

    @property
    @pulumi.getter(name="sslVpnWebPortal")
    def ssl_vpn_web_portal(self) -> Optional[str]:
        """
        SSL-VPN web portal.
        """
        return pulumi.get(self, "ssl_vpn_web_portal")

    @property
    @pulumi.getter(name="urlMap")
    def url_map(self) -> Optional[str]:
        """
        URL pattern to match.
        """
        return pulumi.get(self, "url_map")

    @property
    @pulumi.getter(name="urlMapType")
    def url_map_type(self) -> Optional[str]:
        """
        Type of url-map. Valid values: `sub-string`, `wildcard`, `regex`.
        """
        return pulumi.get(self, "url_map_type")

    @property
    @pulumi.getter(name="virtualHost")
    def virtual_host(self) -> Optional[str]:
        """
        Virtual host.
        """
        return pulumi.get(self, "virtual_host")


@pulumi.output_type
class Accessproxy6ApiGateway6Application(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: SaaS application name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        SaaS application name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Accessproxy6ApiGateway6Quic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ackDelayExponent":
            suggest = "ack_delay_exponent"
        elif key == "activeConnectionIdLimit":
            suggest = "active_connection_id_limit"
        elif key == "activeMigration":
            suggest = "active_migration"
        elif key == "greaseQuicBit":
            suggest = "grease_quic_bit"
        elif key == "maxAckDelay":
            suggest = "max_ack_delay"
        elif key == "maxDatagramFrameSize":
            suggest = "max_datagram_frame_size"
        elif key == "maxIdleTimeout":
            suggest = "max_idle_timeout"
        elif key == "maxUdpPayloadSize":
            suggest = "max_udp_payload_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Accessproxy6ApiGateway6Quic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Accessproxy6ApiGateway6Quic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Accessproxy6ApiGateway6Quic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ack_delay_exponent: Optional[int] = None,
                 active_connection_id_limit: Optional[int] = None,
                 active_migration: Optional[str] = None,
                 grease_quic_bit: Optional[str] = None,
                 max_ack_delay: Optional[int] = None,
                 max_datagram_frame_size: Optional[int] = None,
                 max_idle_timeout: Optional[int] = None,
                 max_udp_payload_size: Optional[int] = None):
        """
        :param int ack_delay_exponent: ACK delay exponent (1 - 20, default = 3).
        :param int active_connection_id_limit: Active connection ID limit (1 - 8, default = 2).
        :param str active_migration: Enable/disable active migration (default = disable). Valid values: `enable`, `disable`.
        :param str grease_quic_bit: Enable/disable grease QUIC bit (default = enable). Valid values: `enable`, `disable`.
        :param int max_ack_delay: Maximum ACK delay in milliseconds (1 - 16383, default = 25).
        :param int max_datagram_frame_size: Maximum datagram frame size in bytes (1 - 1500, default = 1500).
        :param int max_idle_timeout: Maximum idle timeout milliseconds (1 - 60000, default = 30000).
        :param int max_udp_payload_size: Maximum UDP payload size in bytes (1200 - 1500, default = 1500).
        """
        if ack_delay_exponent is not None:
            pulumi.set(__self__, "ack_delay_exponent", ack_delay_exponent)
        if active_connection_id_limit is not None:
            pulumi.set(__self__, "active_connection_id_limit", active_connection_id_limit)
        if active_migration is not None:
            pulumi.set(__self__, "active_migration", active_migration)
        if grease_quic_bit is not None:
            pulumi.set(__self__, "grease_quic_bit", grease_quic_bit)
        if max_ack_delay is not None:
            pulumi.set(__self__, "max_ack_delay", max_ack_delay)
        if max_datagram_frame_size is not None:
            pulumi.set(__self__, "max_datagram_frame_size", max_datagram_frame_size)
        if max_idle_timeout is not None:
            pulumi.set(__self__, "max_idle_timeout", max_idle_timeout)
        if max_udp_payload_size is not None:
            pulumi.set(__self__, "max_udp_payload_size", max_udp_payload_size)

    @property
    @pulumi.getter(name="ackDelayExponent")
    def ack_delay_exponent(self) -> Optional[int]:
        """
        ACK delay exponent (1 - 20, default = 3).
        """
        return pulumi.get(self, "ack_delay_exponent")

    @property
    @pulumi.getter(name="activeConnectionIdLimit")
    def active_connection_id_limit(self) -> Optional[int]:
        """
        Active connection ID limit (1 - 8, default = 2).
        """
        return pulumi.get(self, "active_connection_id_limit")

    @property
    @pulumi.getter(name="activeMigration")
    def active_migration(self) -> Optional[str]:
        """
        Enable/disable active migration (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "active_migration")

    @property
    @pulumi.getter(name="greaseQuicBit")
    def grease_quic_bit(self) -> Optional[str]:
        """
        Enable/disable grease QUIC bit (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "grease_quic_bit")

    @property
    @pulumi.getter(name="maxAckDelay")
    def max_ack_delay(self) -> Optional[int]:
        """
        Maximum ACK delay in milliseconds (1 - 16383, default = 25).
        """
        return pulumi.get(self, "max_ack_delay")

    @property
    @pulumi.getter(name="maxDatagramFrameSize")
    def max_datagram_frame_size(self) -> Optional[int]:
        """
        Maximum datagram frame size in bytes (1 - 1500, default = 1500).
        """
        return pulumi.get(self, "max_datagram_frame_size")

    @property
    @pulumi.getter(name="maxIdleTimeout")
    def max_idle_timeout(self) -> Optional[int]:
        """
        Maximum idle timeout milliseconds (1 - 60000, default = 30000).
        """
        return pulumi.get(self, "max_idle_timeout")

    @property
    @pulumi.getter(name="maxUdpPayloadSize")
    def max_udp_payload_size(self) -> Optional[int]:
        """
        Maximum UDP payload size in bytes (1200 - 1500, default = 1500).
        """
        return pulumi.get(self, "max_udp_payload_size")


@pulumi.output_type
class Accessproxy6ApiGateway6Realserver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addrType":
            suggest = "addr_type"
        elif key == "externalAuth":
            suggest = "external_auth"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "healthCheckProto":
            suggest = "health_check_proto"
        elif key == "holddownInterval":
            suggest = "holddown_interval"
        elif key == "httpHost":
            suggest = "http_host"
        elif key == "sshClientCert":
            suggest = "ssh_client_cert"
        elif key == "sshHostKeyValidation":
            suggest = "ssh_host_key_validation"
        elif key == "sshHostKeys":
            suggest = "ssh_host_keys"
        elif key == "translateHost":
            suggest = "translate_host"
        elif key == "tunnelEncryption":
            suggest = "tunnel_encryption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Accessproxy6ApiGateway6Realserver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Accessproxy6ApiGateway6Realserver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Accessproxy6ApiGateway6Realserver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addr_type: Optional[str] = None,
                 address: Optional[str] = None,
                 domain: Optional[str] = None,
                 external_auth: Optional[str] = None,
                 health_check: Optional[str] = None,
                 health_check_proto: Optional[str] = None,
                 holddown_interval: Optional[str] = None,
                 http_host: Optional[str] = None,
                 id: Optional[int] = None,
                 ip: Optional[str] = None,
                 mappedport: Optional[str] = None,
                 port: Optional[int] = None,
                 ssh_client_cert: Optional[str] = None,
                 ssh_host_key_validation: Optional[str] = None,
                 ssh_host_keys: Optional[Sequence['outputs.Accessproxy6ApiGateway6RealserverSshHostKey']] = None,
                 status: Optional[str] = None,
                 translate_host: Optional[str] = None,
                 tunnel_encryption: Optional[str] = None,
                 type: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param str addr_type: Type of address. Valid values: `ip`, `fqdn`.
        :param str address: Address or address group of the real server.
        :param str domain: Wildcard domain name of the real server.
        :param str external_auth: Enable/disable use of external browser as user-agent for SAML user authentication. Valid values: `enable`, `disable`.
        :param str health_check: Enable to check the responsiveness of the real server before forwarding traffic. Valid values: `disable`, `enable`.
        :param str health_check_proto: Protocol of the health check monitor to use when polling to determine server's connectivity status. Valid values: `ping`, `http`, `tcp-connect`.
        :param str holddown_interval: Enable/disable holddown timer. Server will be considered active and reachable once the holddown period has expired (30 seconds). Valid values: `enable`, `disable`.
        :param str http_host: HTTP server domain name in HTTP header.
        :param int id: Real server ID.
        :param str ip: IPv6 address of the real server.
        :param str mappedport: Port for communicating with the real server.
        :param int port: Port for communicating with the real server.
        :param str ssh_client_cert: Set access-proxy SSH client certificate profile.
        :param str ssh_host_key_validation: Enable/disable SSH real server host key validation. Valid values: `disable`, `enable`.
        :param Sequence['Accessproxy6ApiGateway6RealserverSshHostKeyArgs'] ssh_host_keys: One or more server host key. The structure of `ssh_host_key` block is documented below.
        :param str status: Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent. Valid values: `active`, `standby`, `disable`.
        :param str translate_host: Enable/disable translation of hostname/IP from virtual server to real server. Valid values: `enable`, `disable`.
        :param str tunnel_encryption: Tunnel encryption. Valid values: `enable`, `disable`.
        :param str type: TCP forwarding server type. Valid values: `tcp-forwarding`, `ssh`.
        :param int weight: Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
        """
        if addr_type is not None:
            pulumi.set(__self__, "addr_type", addr_type)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if external_auth is not None:
            pulumi.set(__self__, "external_auth", external_auth)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if health_check_proto is not None:
            pulumi.set(__self__, "health_check_proto", health_check_proto)
        if holddown_interval is not None:
            pulumi.set(__self__, "holddown_interval", holddown_interval)
        if http_host is not None:
            pulumi.set(__self__, "http_host", http_host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if mappedport is not None:
            pulumi.set(__self__, "mappedport", mappedport)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_client_cert is not None:
            pulumi.set(__self__, "ssh_client_cert", ssh_client_cert)
        if ssh_host_key_validation is not None:
            pulumi.set(__self__, "ssh_host_key_validation", ssh_host_key_validation)
        if ssh_host_keys is not None:
            pulumi.set(__self__, "ssh_host_keys", ssh_host_keys)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if translate_host is not None:
            pulumi.set(__self__, "translate_host", translate_host)
        if tunnel_encryption is not None:
            pulumi.set(__self__, "tunnel_encryption", tunnel_encryption)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="addrType")
    def addr_type(self) -> Optional[str]:
        """
        Type of address. Valid values: `ip`, `fqdn`.
        """
        return pulumi.get(self, "addr_type")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Address or address group of the real server.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Wildcard domain name of the real server.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="externalAuth")
    def external_auth(self) -> Optional[str]:
        """
        Enable/disable use of external browser as user-agent for SAML user authentication. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "external_auth")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[str]:
        """
        Enable to check the responsiveness of the real server before forwarding traffic. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter(name="healthCheckProto")
    def health_check_proto(self) -> Optional[str]:
        """
        Protocol of the health check monitor to use when polling to determine server's connectivity status. Valid values: `ping`, `http`, `tcp-connect`.
        """
        return pulumi.get(self, "health_check_proto")

    @property
    @pulumi.getter(name="holddownInterval")
    def holddown_interval(self) -> Optional[str]:
        """
        Enable/disable holddown timer. Server will be considered active and reachable once the holddown period has expired (30 seconds). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "holddown_interval")

    @property
    @pulumi.getter(name="httpHost")
    def http_host(self) -> Optional[str]:
        """
        HTTP server domain name in HTTP header.
        """
        return pulumi.get(self, "http_host")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Real server ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv6 address of the real server.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def mappedport(self) -> Optional[str]:
        """
        Port for communicating with the real server.
        """
        return pulumi.get(self, "mappedport")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for communicating with the real server.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sshClientCert")
    def ssh_client_cert(self) -> Optional[str]:
        """
        Set access-proxy SSH client certificate profile.
        """
        return pulumi.get(self, "ssh_client_cert")

    @property
    @pulumi.getter(name="sshHostKeyValidation")
    def ssh_host_key_validation(self) -> Optional[str]:
        """
        Enable/disable SSH real server host key validation. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "ssh_host_key_validation")

    @property
    @pulumi.getter(name="sshHostKeys")
    def ssh_host_keys(self) -> Optional[Sequence['outputs.Accessproxy6ApiGateway6RealserverSshHostKey']]:
        """
        One or more server host key. The structure of `ssh_host_key` block is documented below.
        """
        return pulumi.get(self, "ssh_host_keys")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent. Valid values: `active`, `standby`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="translateHost")
    def translate_host(self) -> Optional[str]:
        """
        Enable/disable translation of hostname/IP from virtual server to real server. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "translate_host")

    @property
    @pulumi.getter(name="tunnelEncryption")
    def tunnel_encryption(self) -> Optional[str]:
        """
        Tunnel encryption. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "tunnel_encryption")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        TCP forwarding server type. Valid values: `tcp-forwarding`, `ssh`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class Accessproxy6ApiGateway6RealserverSshHostKey(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Server host key name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Server host key name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Accessproxy6ApiGateway6SslCipherSuite(dict):
    def __init__(__self__, *,
                 cipher: Optional[str] = None,
                 priority: Optional[int] = None,
                 versions: Optional[str] = None):
        """
        :param str cipher: Cipher suite name. Valid values: `TLS-AES-128-GCM-SHA256`, `TLS-AES-256-GCM-SHA384`, `TLS-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-ECDSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-128-GCM-SHA256`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-AES-128-CBC-SHA`, `TLS-RSA-WITH-AES-256-CBC-SHA`, `TLS-RSA-WITH-AES-128-CBC-SHA256`, `TLS-RSA-WITH-AES-128-GCM-SHA256`, `TLS-RSA-WITH-AES-256-CBC-SHA256`, `TLS-RSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-SEED-CBC-SHA`, `TLS-DHE-DSS-WITH-SEED-CBC-SHA`, `TLS-DHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-DHE-DSS-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-ARIA-256-CBC-SHA384`, `TLS-RSA-WITH-SEED-CBC-SHA`, `TLS-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-RC4-128-SHA`, `TLS-ECDHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-DSS-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-RC4-128-MD5`, `TLS-RSA-WITH-RC4-128-SHA`, `TLS-DHE-RSA-WITH-DES-CBC-SHA`, `TLS-DHE-DSS-WITH-DES-CBC-SHA`, `TLS-RSA-WITH-DES-CBC-SHA`.
        :param int priority: SSL/TLS cipher suites priority.
        :param str versions: SSL/TLS versions that the cipher suite can be used with. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        if cipher is not None:
            pulumi.set(__self__, "cipher", cipher)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def cipher(self) -> Optional[str]:
        """
        Cipher suite name. Valid values: `TLS-AES-128-GCM-SHA256`, `TLS-AES-256-GCM-SHA384`, `TLS-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-ECDSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-128-GCM-SHA256`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-AES-128-CBC-SHA`, `TLS-RSA-WITH-AES-256-CBC-SHA`, `TLS-RSA-WITH-AES-128-CBC-SHA256`, `TLS-RSA-WITH-AES-128-GCM-SHA256`, `TLS-RSA-WITH-AES-256-CBC-SHA256`, `TLS-RSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-SEED-CBC-SHA`, `TLS-DHE-DSS-WITH-SEED-CBC-SHA`, `TLS-DHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-DHE-DSS-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-ARIA-256-CBC-SHA384`, `TLS-RSA-WITH-SEED-CBC-SHA`, `TLS-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-RC4-128-SHA`, `TLS-ECDHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-DSS-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-RC4-128-MD5`, `TLS-RSA-WITH-RC4-128-SHA`, `TLS-DHE-RSA-WITH-DES-CBC-SHA`, `TLS-DHE-DSS-WITH-DES-CBC-SHA`, `TLS-RSA-WITH-DES-CBC-SHA`.
        """
        return pulumi.get(self, "cipher")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        SSL/TLS cipher suites priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def versions(self) -> Optional[str]:
        """
        SSL/TLS versions that the cipher suite can be used with. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class Accessproxy6ApiGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "h2Support":
            suggest = "h2_support"
        elif key == "h3Support":
            suggest = "h3_support"
        elif key == "httpCookieAge":
            suggest = "http_cookie_age"
        elif key == "httpCookieDomain":
            suggest = "http_cookie_domain"
        elif key == "httpCookieDomainFromHost":
            suggest = "http_cookie_domain_from_host"
        elif key == "httpCookieGeneration":
            suggest = "http_cookie_generation"
        elif key == "httpCookiePath":
            suggest = "http_cookie_path"
        elif key == "httpCookieShare":
            suggest = "http_cookie_share"
        elif key == "httpsCookieSecure":
            suggest = "https_cookie_secure"
        elif key == "ldbMethod":
            suggest = "ldb_method"
        elif key == "samlRedirect":
            suggest = "saml_redirect"
        elif key == "samlServer":
            suggest = "saml_server"
        elif key == "sslAlgorithm":
            suggest = "ssl_algorithm"
        elif key == "sslCipherSuites":
            suggest = "ssl_cipher_suites"
        elif key == "sslDhBits":
            suggest = "ssl_dh_bits"
        elif key == "sslMaxVersion":
            suggest = "ssl_max_version"
        elif key == "sslMinVersion":
            suggest = "ssl_min_version"
        elif key == "sslRenegotiation":
            suggest = "ssl_renegotiation"
        elif key == "sslVpnWebPortal":
            suggest = "ssl_vpn_web_portal"
        elif key == "urlMap":
            suggest = "url_map"
        elif key == "urlMapType":
            suggest = "url_map_type"
        elif key == "virtualHost":
            suggest = "virtual_host"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Accessproxy6ApiGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Accessproxy6ApiGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Accessproxy6ApiGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applications: Optional[Sequence['outputs.Accessproxy6ApiGatewayApplication']] = None,
                 h2_support: Optional[str] = None,
                 h3_support: Optional[str] = None,
                 http_cookie_age: Optional[int] = None,
                 http_cookie_domain: Optional[str] = None,
                 http_cookie_domain_from_host: Optional[str] = None,
                 http_cookie_generation: Optional[int] = None,
                 http_cookie_path: Optional[str] = None,
                 http_cookie_share: Optional[str] = None,
                 https_cookie_secure: Optional[str] = None,
                 id: Optional[int] = None,
                 ldb_method: Optional[str] = None,
                 persistence: Optional[str] = None,
                 quic: Optional['outputs.Accessproxy6ApiGatewayQuic'] = None,
                 realservers: Optional[Sequence['outputs.Accessproxy6ApiGatewayRealserver']] = None,
                 saml_redirect: Optional[str] = None,
                 saml_server: Optional[str] = None,
                 service: Optional[str] = None,
                 ssl_algorithm: Optional[str] = None,
                 ssl_cipher_suites: Optional[Sequence['outputs.Accessproxy6ApiGatewaySslCipherSuite']] = None,
                 ssl_dh_bits: Optional[str] = None,
                 ssl_max_version: Optional[str] = None,
                 ssl_min_version: Optional[str] = None,
                 ssl_renegotiation: Optional[str] = None,
                 ssl_vpn_web_portal: Optional[str] = None,
                 url_map: Optional[str] = None,
                 url_map_type: Optional[str] = None,
                 virtual_host: Optional[str] = None):
        """
        :param Sequence['Accessproxy6ApiGatewayApplicationArgs'] applications: SaaS application controlled by this Access Proxy. The structure of `application` block is documented below.
        :param str h2_support: HTTP2 support, default=Enable. Valid values: `enable`, `disable`.
        :param str h3_support: HTTP3/QUIC support, default=Disable. Valid values: `enable`, `disable`.
        :param int http_cookie_age: Time in minutes that client web browsers should keep a cookie. Default is 60 minutes. 0 = no time limit.
        :param str http_cookie_domain: Domain that HTTP cookie persistence should apply to.
        :param str http_cookie_domain_from_host: Enable/disable use of HTTP cookie domain from host field in HTTP. Valid values: `disable`, `enable`.
        :param int http_cookie_generation: Generation of HTTP cookie to be accepted. Changing invalidates all existing cookies.
        :param str http_cookie_path: Limit HTTP cookie persistence to the specified path.
        :param str http_cookie_share: Control sharing of cookies across API Gateway. same-ip means a cookie from one virtual server can be used by another. Disable stops cookie sharing. Valid values: `disable`, `same-ip`.
        :param str https_cookie_secure: Enable/disable verification that inserted HTTPS cookies are secure. Valid values: `disable`, `enable`.
        :param int id: API Gateway ID.
        :param str ldb_method: Method used to distribute sessions to real servers. Valid values: `static`, `round-robin`, `weighted`, `first-alive`, `http-host`.
        :param str persistence: Configure how to make sure that clients connect to the same server every time they make a request that is part of the same session. Valid values: `none`, `http-cookie`.
        :param 'Accessproxy6ApiGatewayQuicArgs' quic: QUIC setting. The structure of `quic` block is documented below.
        :param Sequence['Accessproxy6ApiGatewayRealserverArgs'] realservers: Select the real servers that this Access Proxy will distribute traffic to. The structure of `realservers` block is documented below.
        :param str saml_redirect: Enable/disable SAML redirection after successful authentication. Valid values: `disable`, `enable`.
        :param str saml_server: SAML service provider configuration for VIP authentication.
        :param str service: Service.
        :param str ssl_algorithm: Permitted encryption algorithms for the server side of SSL full mode sessions according to encryption strength. Valid values: `high`, `medium`, `low`.
        :param Sequence['Accessproxy6ApiGatewaySslCipherSuiteArgs'] ssl_cipher_suites: SSL/TLS cipher suites to offer to a server, ordered by priority. The structure of `ssl_cipher_suites` block is documented below.
        :param str ssl_dh_bits: Number of bits to use in the Diffie-Hellman exchange for RSA encryption of SSL sessions. Valid values: `768`, `1024`, `1536`, `2048`, `3072`, `4096`.
        :param str ssl_max_version: Highest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        :param str ssl_min_version: Lowest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        :param str ssl_renegotiation: Enable/disable secure renegotiation to comply with RFC 5746. Valid values: `enable`, `disable`.
        :param str ssl_vpn_web_portal: SSL-VPN web portal.
        :param str url_map: URL pattern to match.
        :param str url_map_type: Type of url-map. Valid values: `sub-string`, `wildcard`, `regex`.
        :param str virtual_host: Virtual host.
        """
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if h2_support is not None:
            pulumi.set(__self__, "h2_support", h2_support)
        if h3_support is not None:
            pulumi.set(__self__, "h3_support", h3_support)
        if http_cookie_age is not None:
            pulumi.set(__self__, "http_cookie_age", http_cookie_age)
        if http_cookie_domain is not None:
            pulumi.set(__self__, "http_cookie_domain", http_cookie_domain)
        if http_cookie_domain_from_host is not None:
            pulumi.set(__self__, "http_cookie_domain_from_host", http_cookie_domain_from_host)
        if http_cookie_generation is not None:
            pulumi.set(__self__, "http_cookie_generation", http_cookie_generation)
        if http_cookie_path is not None:
            pulumi.set(__self__, "http_cookie_path", http_cookie_path)
        if http_cookie_share is not None:
            pulumi.set(__self__, "http_cookie_share", http_cookie_share)
        if https_cookie_secure is not None:
            pulumi.set(__self__, "https_cookie_secure", https_cookie_secure)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ldb_method is not None:
            pulumi.set(__self__, "ldb_method", ldb_method)
        if persistence is not None:
            pulumi.set(__self__, "persistence", persistence)
        if quic is not None:
            pulumi.set(__self__, "quic", quic)
        if realservers is not None:
            pulumi.set(__self__, "realservers", realservers)
        if saml_redirect is not None:
            pulumi.set(__self__, "saml_redirect", saml_redirect)
        if saml_server is not None:
            pulumi.set(__self__, "saml_server", saml_server)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if ssl_algorithm is not None:
            pulumi.set(__self__, "ssl_algorithm", ssl_algorithm)
        if ssl_cipher_suites is not None:
            pulumi.set(__self__, "ssl_cipher_suites", ssl_cipher_suites)
        if ssl_dh_bits is not None:
            pulumi.set(__self__, "ssl_dh_bits", ssl_dh_bits)
        if ssl_max_version is not None:
            pulumi.set(__self__, "ssl_max_version", ssl_max_version)
        if ssl_min_version is not None:
            pulumi.set(__self__, "ssl_min_version", ssl_min_version)
        if ssl_renegotiation is not None:
            pulumi.set(__self__, "ssl_renegotiation", ssl_renegotiation)
        if ssl_vpn_web_portal is not None:
            pulumi.set(__self__, "ssl_vpn_web_portal", ssl_vpn_web_portal)
        if url_map is not None:
            pulumi.set(__self__, "url_map", url_map)
        if url_map_type is not None:
            pulumi.set(__self__, "url_map_type", url_map_type)
        if virtual_host is not None:
            pulumi.set(__self__, "virtual_host", virtual_host)

    @property
    @pulumi.getter
    def applications(self) -> Optional[Sequence['outputs.Accessproxy6ApiGatewayApplication']]:
        """
        SaaS application controlled by this Access Proxy. The structure of `application` block is documented below.
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter(name="h2Support")
    def h2_support(self) -> Optional[str]:
        """
        HTTP2 support, default=Enable. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "h2_support")

    @property
    @pulumi.getter(name="h3Support")
    def h3_support(self) -> Optional[str]:
        """
        HTTP3/QUIC support, default=Disable. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "h3_support")

    @property
    @pulumi.getter(name="httpCookieAge")
    def http_cookie_age(self) -> Optional[int]:
        """
        Time in minutes that client web browsers should keep a cookie. Default is 60 minutes. 0 = no time limit.
        """
        return pulumi.get(self, "http_cookie_age")

    @property
    @pulumi.getter(name="httpCookieDomain")
    def http_cookie_domain(self) -> Optional[str]:
        """
        Domain that HTTP cookie persistence should apply to.
        """
        return pulumi.get(self, "http_cookie_domain")

    @property
    @pulumi.getter(name="httpCookieDomainFromHost")
    def http_cookie_domain_from_host(self) -> Optional[str]:
        """
        Enable/disable use of HTTP cookie domain from host field in HTTP. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "http_cookie_domain_from_host")

    @property
    @pulumi.getter(name="httpCookieGeneration")
    def http_cookie_generation(self) -> Optional[int]:
        """
        Generation of HTTP cookie to be accepted. Changing invalidates all existing cookies.
        """
        return pulumi.get(self, "http_cookie_generation")

    @property
    @pulumi.getter(name="httpCookiePath")
    def http_cookie_path(self) -> Optional[str]:
        """
        Limit HTTP cookie persistence to the specified path.
        """
        return pulumi.get(self, "http_cookie_path")

    @property
    @pulumi.getter(name="httpCookieShare")
    def http_cookie_share(self) -> Optional[str]:
        """
        Control sharing of cookies across API Gateway. same-ip means a cookie from one virtual server can be used by another. Disable stops cookie sharing. Valid values: `disable`, `same-ip`.
        """
        return pulumi.get(self, "http_cookie_share")

    @property
    @pulumi.getter(name="httpsCookieSecure")
    def https_cookie_secure(self) -> Optional[str]:
        """
        Enable/disable verification that inserted HTTPS cookies are secure. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "https_cookie_secure")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        API Gateway ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ldbMethod")
    def ldb_method(self) -> Optional[str]:
        """
        Method used to distribute sessions to real servers. Valid values: `static`, `round-robin`, `weighted`, `first-alive`, `http-host`.
        """
        return pulumi.get(self, "ldb_method")

    @property
    @pulumi.getter
    def persistence(self) -> Optional[str]:
        """
        Configure how to make sure that clients connect to the same server every time they make a request that is part of the same session. Valid values: `none`, `http-cookie`.
        """
        return pulumi.get(self, "persistence")

    @property
    @pulumi.getter
    def quic(self) -> Optional['outputs.Accessproxy6ApiGatewayQuic']:
        """
        QUIC setting. The structure of `quic` block is documented below.
        """
        return pulumi.get(self, "quic")

    @property
    @pulumi.getter
    def realservers(self) -> Optional[Sequence['outputs.Accessproxy6ApiGatewayRealserver']]:
        """
        Select the real servers that this Access Proxy will distribute traffic to. The structure of `realservers` block is documented below.
        """
        return pulumi.get(self, "realservers")

    @property
    @pulumi.getter(name="samlRedirect")
    def saml_redirect(self) -> Optional[str]:
        """
        Enable/disable SAML redirection after successful authentication. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "saml_redirect")

    @property
    @pulumi.getter(name="samlServer")
    def saml_server(self) -> Optional[str]:
        """
        SAML service provider configuration for VIP authentication.
        """
        return pulumi.get(self, "saml_server")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="sslAlgorithm")
    def ssl_algorithm(self) -> Optional[str]:
        """
        Permitted encryption algorithms for the server side of SSL full mode sessions according to encryption strength. Valid values: `high`, `medium`, `low`.
        """
        return pulumi.get(self, "ssl_algorithm")

    @property
    @pulumi.getter(name="sslCipherSuites")
    def ssl_cipher_suites(self) -> Optional[Sequence['outputs.Accessproxy6ApiGatewaySslCipherSuite']]:
        """
        SSL/TLS cipher suites to offer to a server, ordered by priority. The structure of `ssl_cipher_suites` block is documented below.
        """
        return pulumi.get(self, "ssl_cipher_suites")

    @property
    @pulumi.getter(name="sslDhBits")
    def ssl_dh_bits(self) -> Optional[str]:
        """
        Number of bits to use in the Diffie-Hellman exchange for RSA encryption of SSL sessions. Valid values: `768`, `1024`, `1536`, `2048`, `3072`, `4096`.
        """
        return pulumi.get(self, "ssl_dh_bits")

    @property
    @pulumi.getter(name="sslMaxVersion")
    def ssl_max_version(self) -> Optional[str]:
        """
        Highest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "ssl_max_version")

    @property
    @pulumi.getter(name="sslMinVersion")
    def ssl_min_version(self) -> Optional[str]:
        """
        Lowest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "ssl_min_version")

    @property
    @pulumi.getter(name="sslRenegotiation")
    def ssl_renegotiation(self) -> Optional[str]:
        """
        Enable/disable secure renegotiation to comply with RFC 5746. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ssl_renegotiation")

    @property
    @pulumi.getter(name="sslVpnWebPortal")
    def ssl_vpn_web_portal(self) -> Optional[str]:
        """
        SSL-VPN web portal.
        """
        return pulumi.get(self, "ssl_vpn_web_portal")

    @property
    @pulumi.getter(name="urlMap")
    def url_map(self) -> Optional[str]:
        """
        URL pattern to match.
        """
        return pulumi.get(self, "url_map")

    @property
    @pulumi.getter(name="urlMapType")
    def url_map_type(self) -> Optional[str]:
        """
        Type of url-map. Valid values: `sub-string`, `wildcard`, `regex`.
        """
        return pulumi.get(self, "url_map_type")

    @property
    @pulumi.getter(name="virtualHost")
    def virtual_host(self) -> Optional[str]:
        """
        Virtual host.
        """
        return pulumi.get(self, "virtual_host")


@pulumi.output_type
class Accessproxy6ApiGatewayApplication(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: SaaS application name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        SaaS application name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Accessproxy6ApiGatewayQuic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ackDelayExponent":
            suggest = "ack_delay_exponent"
        elif key == "activeConnectionIdLimit":
            suggest = "active_connection_id_limit"
        elif key == "activeMigration":
            suggest = "active_migration"
        elif key == "greaseQuicBit":
            suggest = "grease_quic_bit"
        elif key == "maxAckDelay":
            suggest = "max_ack_delay"
        elif key == "maxDatagramFrameSize":
            suggest = "max_datagram_frame_size"
        elif key == "maxIdleTimeout":
            suggest = "max_idle_timeout"
        elif key == "maxUdpPayloadSize":
            suggest = "max_udp_payload_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Accessproxy6ApiGatewayQuic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Accessproxy6ApiGatewayQuic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Accessproxy6ApiGatewayQuic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ack_delay_exponent: Optional[int] = None,
                 active_connection_id_limit: Optional[int] = None,
                 active_migration: Optional[str] = None,
                 grease_quic_bit: Optional[str] = None,
                 max_ack_delay: Optional[int] = None,
                 max_datagram_frame_size: Optional[int] = None,
                 max_idle_timeout: Optional[int] = None,
                 max_udp_payload_size: Optional[int] = None):
        """
        :param int ack_delay_exponent: ACK delay exponent (1 - 20, default = 3).
        :param int active_connection_id_limit: Active connection ID limit (1 - 8, default = 2).
        :param str active_migration: Enable/disable active migration (default = disable). Valid values: `enable`, `disable`.
        :param str grease_quic_bit: Enable/disable grease QUIC bit (default = enable). Valid values: `enable`, `disable`.
        :param int max_ack_delay: Maximum ACK delay in milliseconds (1 - 16383, default = 25).
        :param int max_datagram_frame_size: Maximum datagram frame size in bytes (1 - 1500, default = 1500).
        :param int max_idle_timeout: Maximum idle timeout milliseconds (1 - 60000, default = 30000).
        :param int max_udp_payload_size: Maximum UDP payload size in bytes (1200 - 1500, default = 1500).
        """
        if ack_delay_exponent is not None:
            pulumi.set(__self__, "ack_delay_exponent", ack_delay_exponent)
        if active_connection_id_limit is not None:
            pulumi.set(__self__, "active_connection_id_limit", active_connection_id_limit)
        if active_migration is not None:
            pulumi.set(__self__, "active_migration", active_migration)
        if grease_quic_bit is not None:
            pulumi.set(__self__, "grease_quic_bit", grease_quic_bit)
        if max_ack_delay is not None:
            pulumi.set(__self__, "max_ack_delay", max_ack_delay)
        if max_datagram_frame_size is not None:
            pulumi.set(__self__, "max_datagram_frame_size", max_datagram_frame_size)
        if max_idle_timeout is not None:
            pulumi.set(__self__, "max_idle_timeout", max_idle_timeout)
        if max_udp_payload_size is not None:
            pulumi.set(__self__, "max_udp_payload_size", max_udp_payload_size)

    @property
    @pulumi.getter(name="ackDelayExponent")
    def ack_delay_exponent(self) -> Optional[int]:
        """
        ACK delay exponent (1 - 20, default = 3).
        """
        return pulumi.get(self, "ack_delay_exponent")

    @property
    @pulumi.getter(name="activeConnectionIdLimit")
    def active_connection_id_limit(self) -> Optional[int]:
        """
        Active connection ID limit (1 - 8, default = 2).
        """
        return pulumi.get(self, "active_connection_id_limit")

    @property
    @pulumi.getter(name="activeMigration")
    def active_migration(self) -> Optional[str]:
        """
        Enable/disable active migration (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "active_migration")

    @property
    @pulumi.getter(name="greaseQuicBit")
    def grease_quic_bit(self) -> Optional[str]:
        """
        Enable/disable grease QUIC bit (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "grease_quic_bit")

    @property
    @pulumi.getter(name="maxAckDelay")
    def max_ack_delay(self) -> Optional[int]:
        """
        Maximum ACK delay in milliseconds (1 - 16383, default = 25).
        """
        return pulumi.get(self, "max_ack_delay")

    @property
    @pulumi.getter(name="maxDatagramFrameSize")
    def max_datagram_frame_size(self) -> Optional[int]:
        """
        Maximum datagram frame size in bytes (1 - 1500, default = 1500).
        """
        return pulumi.get(self, "max_datagram_frame_size")

    @property
    @pulumi.getter(name="maxIdleTimeout")
    def max_idle_timeout(self) -> Optional[int]:
        """
        Maximum idle timeout milliseconds (1 - 60000, default = 30000).
        """
        return pulumi.get(self, "max_idle_timeout")

    @property
    @pulumi.getter(name="maxUdpPayloadSize")
    def max_udp_payload_size(self) -> Optional[int]:
        """
        Maximum UDP payload size in bytes (1200 - 1500, default = 1500).
        """
        return pulumi.get(self, "max_udp_payload_size")


@pulumi.output_type
class Accessproxy6ApiGatewayRealserver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addrType":
            suggest = "addr_type"
        elif key == "externalAuth":
            suggest = "external_auth"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "healthCheckProto":
            suggest = "health_check_proto"
        elif key == "holddownInterval":
            suggest = "holddown_interval"
        elif key == "httpHost":
            suggest = "http_host"
        elif key == "sshClientCert":
            suggest = "ssh_client_cert"
        elif key == "sshHostKeyValidation":
            suggest = "ssh_host_key_validation"
        elif key == "sshHostKeys":
            suggest = "ssh_host_keys"
        elif key == "translateHost":
            suggest = "translate_host"
        elif key == "tunnelEncryption":
            suggest = "tunnel_encryption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Accessproxy6ApiGatewayRealserver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Accessproxy6ApiGatewayRealserver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Accessproxy6ApiGatewayRealserver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addr_type: Optional[str] = None,
                 address: Optional[str] = None,
                 domain: Optional[str] = None,
                 external_auth: Optional[str] = None,
                 health_check: Optional[str] = None,
                 health_check_proto: Optional[str] = None,
                 holddown_interval: Optional[str] = None,
                 http_host: Optional[str] = None,
                 id: Optional[int] = None,
                 ip: Optional[str] = None,
                 mappedport: Optional[str] = None,
                 port: Optional[int] = None,
                 ssh_client_cert: Optional[str] = None,
                 ssh_host_key_validation: Optional[str] = None,
                 ssh_host_keys: Optional[Sequence['outputs.Accessproxy6ApiGatewayRealserverSshHostKey']] = None,
                 status: Optional[str] = None,
                 translate_host: Optional[str] = None,
                 tunnel_encryption: Optional[str] = None,
                 type: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param str addr_type: Type of address. Valid values: `ip`, `fqdn`.
        :param str address: Address or address group of the real server.
        :param str domain: Wildcard domain name of the real server.
        :param str external_auth: Enable/disable use of external browser as user-agent for SAML user authentication. Valid values: `enable`, `disable`.
        :param str health_check: Enable to check the responsiveness of the real server before forwarding traffic. Valid values: `disable`, `enable`.
        :param str health_check_proto: Protocol of the health check monitor to use when polling to determine server's connectivity status. Valid values: `ping`, `http`, `tcp-connect`.
        :param str holddown_interval: Enable/disable holddown timer. Server will be considered active and reachable once the holddown period has expired (30 seconds). Valid values: `enable`, `disable`.
        :param str http_host: HTTP server domain name in HTTP header.
        :param int id: Real server ID.
        :param str ip: IPv6 address of the real server.
        :param str mappedport: Port for communicating with the real server.
        :param int port: Port for communicating with the real server.
        :param str ssh_client_cert: Set access-proxy SSH client certificate profile.
        :param str ssh_host_key_validation: Enable/disable SSH real server host key validation. Valid values: `disable`, `enable`.
        :param Sequence['Accessproxy6ApiGatewayRealserverSshHostKeyArgs'] ssh_host_keys: One or more server host key. The structure of `ssh_host_key` block is documented below.
        :param str status: Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent. Valid values: `active`, `standby`, `disable`.
        :param str translate_host: Enable/disable translation of hostname/IP from virtual server to real server. Valid values: `enable`, `disable`.
        :param str tunnel_encryption: Tunnel encryption. Valid values: `enable`, `disable`.
        :param str type: TCP forwarding server type. Valid values: `tcp-forwarding`, `ssh`.
        :param int weight: Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
        """
        if addr_type is not None:
            pulumi.set(__self__, "addr_type", addr_type)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if external_auth is not None:
            pulumi.set(__self__, "external_auth", external_auth)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if health_check_proto is not None:
            pulumi.set(__self__, "health_check_proto", health_check_proto)
        if holddown_interval is not None:
            pulumi.set(__self__, "holddown_interval", holddown_interval)
        if http_host is not None:
            pulumi.set(__self__, "http_host", http_host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if mappedport is not None:
            pulumi.set(__self__, "mappedport", mappedport)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_client_cert is not None:
            pulumi.set(__self__, "ssh_client_cert", ssh_client_cert)
        if ssh_host_key_validation is not None:
            pulumi.set(__self__, "ssh_host_key_validation", ssh_host_key_validation)
        if ssh_host_keys is not None:
            pulumi.set(__self__, "ssh_host_keys", ssh_host_keys)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if translate_host is not None:
            pulumi.set(__self__, "translate_host", translate_host)
        if tunnel_encryption is not None:
            pulumi.set(__self__, "tunnel_encryption", tunnel_encryption)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="addrType")
    def addr_type(self) -> Optional[str]:
        """
        Type of address. Valid values: `ip`, `fqdn`.
        """
        return pulumi.get(self, "addr_type")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Address or address group of the real server.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Wildcard domain name of the real server.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="externalAuth")
    def external_auth(self) -> Optional[str]:
        """
        Enable/disable use of external browser as user-agent for SAML user authentication. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "external_auth")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[str]:
        """
        Enable to check the responsiveness of the real server before forwarding traffic. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter(name="healthCheckProto")
    def health_check_proto(self) -> Optional[str]:
        """
        Protocol of the health check monitor to use when polling to determine server's connectivity status. Valid values: `ping`, `http`, `tcp-connect`.
        """
        return pulumi.get(self, "health_check_proto")

    @property
    @pulumi.getter(name="holddownInterval")
    def holddown_interval(self) -> Optional[str]:
        """
        Enable/disable holddown timer. Server will be considered active and reachable once the holddown period has expired (30 seconds). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "holddown_interval")

    @property
    @pulumi.getter(name="httpHost")
    def http_host(self) -> Optional[str]:
        """
        HTTP server domain name in HTTP header.
        """
        return pulumi.get(self, "http_host")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Real server ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv6 address of the real server.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def mappedport(self) -> Optional[str]:
        """
        Port for communicating with the real server.
        """
        return pulumi.get(self, "mappedport")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for communicating with the real server.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sshClientCert")
    def ssh_client_cert(self) -> Optional[str]:
        """
        Set access-proxy SSH client certificate profile.
        """
        return pulumi.get(self, "ssh_client_cert")

    @property
    @pulumi.getter(name="sshHostKeyValidation")
    def ssh_host_key_validation(self) -> Optional[str]:
        """
        Enable/disable SSH real server host key validation. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "ssh_host_key_validation")

    @property
    @pulumi.getter(name="sshHostKeys")
    def ssh_host_keys(self) -> Optional[Sequence['outputs.Accessproxy6ApiGatewayRealserverSshHostKey']]:
        """
        One or more server host key. The structure of `ssh_host_key` block is documented below.
        """
        return pulumi.get(self, "ssh_host_keys")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent. Valid values: `active`, `standby`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="translateHost")
    def translate_host(self) -> Optional[str]:
        """
        Enable/disable translation of hostname/IP from virtual server to real server. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "translate_host")

    @property
    @pulumi.getter(name="tunnelEncryption")
    def tunnel_encryption(self) -> Optional[str]:
        """
        Tunnel encryption. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "tunnel_encryption")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        TCP forwarding server type. Valid values: `tcp-forwarding`, `ssh`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class Accessproxy6ApiGatewayRealserverSshHostKey(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Server host key name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Server host key name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Accessproxy6ApiGatewaySslCipherSuite(dict):
    def __init__(__self__, *,
                 cipher: Optional[str] = None,
                 priority: Optional[int] = None,
                 versions: Optional[str] = None):
        """
        :param str cipher: Cipher suite name. Valid values: `TLS-AES-128-GCM-SHA256`, `TLS-AES-256-GCM-SHA384`, `TLS-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-ECDSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-128-GCM-SHA256`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-AES-128-CBC-SHA`, `TLS-RSA-WITH-AES-256-CBC-SHA`, `TLS-RSA-WITH-AES-128-CBC-SHA256`, `TLS-RSA-WITH-AES-128-GCM-SHA256`, `TLS-RSA-WITH-AES-256-CBC-SHA256`, `TLS-RSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-SEED-CBC-SHA`, `TLS-DHE-DSS-WITH-SEED-CBC-SHA`, `TLS-DHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-DHE-DSS-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-ARIA-256-CBC-SHA384`, `TLS-RSA-WITH-SEED-CBC-SHA`, `TLS-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-RC4-128-SHA`, `TLS-ECDHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-DSS-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-RC4-128-MD5`, `TLS-RSA-WITH-RC4-128-SHA`, `TLS-DHE-RSA-WITH-DES-CBC-SHA`, `TLS-DHE-DSS-WITH-DES-CBC-SHA`, `TLS-RSA-WITH-DES-CBC-SHA`.
        :param int priority: SSL/TLS cipher suites priority.
        :param str versions: SSL/TLS versions that the cipher suite can be used with. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        if cipher is not None:
            pulumi.set(__self__, "cipher", cipher)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def cipher(self) -> Optional[str]:
        """
        Cipher suite name. Valid values: `TLS-AES-128-GCM-SHA256`, `TLS-AES-256-GCM-SHA384`, `TLS-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-ECDSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-128-GCM-SHA256`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-AES-128-CBC-SHA`, `TLS-RSA-WITH-AES-256-CBC-SHA`, `TLS-RSA-WITH-AES-128-CBC-SHA256`, `TLS-RSA-WITH-AES-128-GCM-SHA256`, `TLS-RSA-WITH-AES-256-CBC-SHA256`, `TLS-RSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-SEED-CBC-SHA`, `TLS-DHE-DSS-WITH-SEED-CBC-SHA`, `TLS-DHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-DHE-DSS-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-ARIA-256-CBC-SHA384`, `TLS-RSA-WITH-SEED-CBC-SHA`, `TLS-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-RC4-128-SHA`, `TLS-ECDHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-DSS-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-RC4-128-MD5`, `TLS-RSA-WITH-RC4-128-SHA`, `TLS-DHE-RSA-WITH-DES-CBC-SHA`, `TLS-DHE-DSS-WITH-DES-CBC-SHA`, `TLS-RSA-WITH-DES-CBC-SHA`.
        """
        return pulumi.get(self, "cipher")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        SSL/TLS cipher suites priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def versions(self) -> Optional[str]:
        """
        SSL/TLS versions that the cipher suite can be used with. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class AccessproxyApiGateway6(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "h2Support":
            suggest = "h2_support"
        elif key == "h3Support":
            suggest = "h3_support"
        elif key == "httpCookieAge":
            suggest = "http_cookie_age"
        elif key == "httpCookieDomain":
            suggest = "http_cookie_domain"
        elif key == "httpCookieDomainFromHost":
            suggest = "http_cookie_domain_from_host"
        elif key == "httpCookieGeneration":
            suggest = "http_cookie_generation"
        elif key == "httpCookiePath":
            suggest = "http_cookie_path"
        elif key == "httpCookieShare":
            suggest = "http_cookie_share"
        elif key == "httpsCookieSecure":
            suggest = "https_cookie_secure"
        elif key == "ldbMethod":
            suggest = "ldb_method"
        elif key == "samlRedirect":
            suggest = "saml_redirect"
        elif key == "samlServer":
            suggest = "saml_server"
        elif key == "sslAlgorithm":
            suggest = "ssl_algorithm"
        elif key == "sslCipherSuites":
            suggest = "ssl_cipher_suites"
        elif key == "sslDhBits":
            suggest = "ssl_dh_bits"
        elif key == "sslMaxVersion":
            suggest = "ssl_max_version"
        elif key == "sslMinVersion":
            suggest = "ssl_min_version"
        elif key == "sslRenegotiation":
            suggest = "ssl_renegotiation"
        elif key == "sslVpnWebPortal":
            suggest = "ssl_vpn_web_portal"
        elif key == "urlMap":
            suggest = "url_map"
        elif key == "urlMapType":
            suggest = "url_map_type"
        elif key == "virtualHost":
            suggest = "virtual_host"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessproxyApiGateway6. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessproxyApiGateway6.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessproxyApiGateway6.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applications: Optional[Sequence['outputs.AccessproxyApiGateway6Application']] = None,
                 h2_support: Optional[str] = None,
                 h3_support: Optional[str] = None,
                 http_cookie_age: Optional[int] = None,
                 http_cookie_domain: Optional[str] = None,
                 http_cookie_domain_from_host: Optional[str] = None,
                 http_cookie_generation: Optional[int] = None,
                 http_cookie_path: Optional[str] = None,
                 http_cookie_share: Optional[str] = None,
                 https_cookie_secure: Optional[str] = None,
                 id: Optional[int] = None,
                 ldb_method: Optional[str] = None,
                 persistence: Optional[str] = None,
                 quic: Optional['outputs.AccessproxyApiGateway6Quic'] = None,
                 realservers: Optional[Sequence['outputs.AccessproxyApiGateway6Realserver']] = None,
                 saml_redirect: Optional[str] = None,
                 saml_server: Optional[str] = None,
                 service: Optional[str] = None,
                 ssl_algorithm: Optional[str] = None,
                 ssl_cipher_suites: Optional[Sequence['outputs.AccessproxyApiGateway6SslCipherSuite']] = None,
                 ssl_dh_bits: Optional[str] = None,
                 ssl_max_version: Optional[str] = None,
                 ssl_min_version: Optional[str] = None,
                 ssl_renegotiation: Optional[str] = None,
                 ssl_vpn_web_portal: Optional[str] = None,
                 url_map: Optional[str] = None,
                 url_map_type: Optional[str] = None,
                 virtual_host: Optional[str] = None):
        """
        :param Sequence['AccessproxyApiGateway6ApplicationArgs'] applications: SaaS application controlled by this Access Proxy. The structure of `application` block is documented below.
        :param str h2_support: HTTP2 support, default=Enable. Valid values: `enable`, `disable`.
        :param str h3_support: HTTP3/QUIC support, default=Disable. Valid values: `enable`, `disable`.
        :param int http_cookie_age: Time in minutes that client web browsers should keep a cookie. Default is 60 minutes. 0 = no time limit.
        :param str http_cookie_domain: Domain that HTTP cookie persistence should apply to.
        :param str http_cookie_domain_from_host: Enable/disable use of HTTP cookie domain from host field in HTTP. Valid values: `disable`, `enable`.
        :param int http_cookie_generation: Generation of HTTP cookie to be accepted. Changing invalidates all existing cookies.
        :param str http_cookie_path: Limit HTTP cookie persistence to the specified path.
        :param str http_cookie_share: Control sharing of cookies across API Gateway. same-ip means a cookie from one virtual server can be used by another. Disable stops cookie sharing. Valid values: `disable`, `same-ip`.
        :param str https_cookie_secure: Enable/disable verification that inserted HTTPS cookies are secure. Valid values: `disable`, `enable`.
        :param int id: API Gateway ID.
        :param str ldb_method: Method used to distribute sessions to real servers. Valid values: `static`, `round-robin`, `weighted`, `first-alive`, `http-host`.
        :param str persistence: Configure how to make sure that clients connect to the same server every time they make a request that is part of the same session. Valid values: `none`, `http-cookie`.
        :param 'AccessproxyApiGateway6QuicArgs' quic: QUIC setting. The structure of `quic` block is documented below.
        :param Sequence['AccessproxyApiGateway6RealserverArgs'] realservers: Select the real servers that this Access Proxy will distribute traffic to. The structure of `realservers` block is documented below.
        :param str saml_redirect: Enable/disable SAML redirection after successful authentication. Valid values: `disable`, `enable`.
        :param str saml_server: SAML service provider configuration for VIP authentication.
        :param str service: Service.
        :param str ssl_algorithm: Permitted encryption algorithms for the server side of SSL full mode sessions according to encryption strength. Valid values: `high`, `medium`, `low`.
        :param Sequence['AccessproxyApiGateway6SslCipherSuiteArgs'] ssl_cipher_suites: SSL/TLS cipher suites to offer to a server, ordered by priority. The structure of `ssl_cipher_suites` block is documented below.
        :param str ssl_dh_bits: Number of bits to use in the Diffie-Hellman exchange for RSA encryption of SSL sessions. Valid values: `768`, `1024`, `1536`, `2048`, `3072`, `4096`.
        :param str ssl_max_version: Highest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        :param str ssl_min_version: Lowest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        :param str ssl_renegotiation: Enable/disable secure renegotiation to comply with RFC 5746. Valid values: `enable`, `disable`.
        :param str ssl_vpn_web_portal: SSL-VPN web portal.
        :param str url_map: URL pattern to match.
        :param str url_map_type: Type of url-map. Valid values: `sub-string`, `wildcard`, `regex`.
        :param str virtual_host: Virtual host.
        """
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if h2_support is not None:
            pulumi.set(__self__, "h2_support", h2_support)
        if h3_support is not None:
            pulumi.set(__self__, "h3_support", h3_support)
        if http_cookie_age is not None:
            pulumi.set(__self__, "http_cookie_age", http_cookie_age)
        if http_cookie_domain is not None:
            pulumi.set(__self__, "http_cookie_domain", http_cookie_domain)
        if http_cookie_domain_from_host is not None:
            pulumi.set(__self__, "http_cookie_domain_from_host", http_cookie_domain_from_host)
        if http_cookie_generation is not None:
            pulumi.set(__self__, "http_cookie_generation", http_cookie_generation)
        if http_cookie_path is not None:
            pulumi.set(__self__, "http_cookie_path", http_cookie_path)
        if http_cookie_share is not None:
            pulumi.set(__self__, "http_cookie_share", http_cookie_share)
        if https_cookie_secure is not None:
            pulumi.set(__self__, "https_cookie_secure", https_cookie_secure)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ldb_method is not None:
            pulumi.set(__self__, "ldb_method", ldb_method)
        if persistence is not None:
            pulumi.set(__self__, "persistence", persistence)
        if quic is not None:
            pulumi.set(__self__, "quic", quic)
        if realservers is not None:
            pulumi.set(__self__, "realservers", realservers)
        if saml_redirect is not None:
            pulumi.set(__self__, "saml_redirect", saml_redirect)
        if saml_server is not None:
            pulumi.set(__self__, "saml_server", saml_server)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if ssl_algorithm is not None:
            pulumi.set(__self__, "ssl_algorithm", ssl_algorithm)
        if ssl_cipher_suites is not None:
            pulumi.set(__self__, "ssl_cipher_suites", ssl_cipher_suites)
        if ssl_dh_bits is not None:
            pulumi.set(__self__, "ssl_dh_bits", ssl_dh_bits)
        if ssl_max_version is not None:
            pulumi.set(__self__, "ssl_max_version", ssl_max_version)
        if ssl_min_version is not None:
            pulumi.set(__self__, "ssl_min_version", ssl_min_version)
        if ssl_renegotiation is not None:
            pulumi.set(__self__, "ssl_renegotiation", ssl_renegotiation)
        if ssl_vpn_web_portal is not None:
            pulumi.set(__self__, "ssl_vpn_web_portal", ssl_vpn_web_portal)
        if url_map is not None:
            pulumi.set(__self__, "url_map", url_map)
        if url_map_type is not None:
            pulumi.set(__self__, "url_map_type", url_map_type)
        if virtual_host is not None:
            pulumi.set(__self__, "virtual_host", virtual_host)

    @property
    @pulumi.getter
    def applications(self) -> Optional[Sequence['outputs.AccessproxyApiGateway6Application']]:
        """
        SaaS application controlled by this Access Proxy. The structure of `application` block is documented below.
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter(name="h2Support")
    def h2_support(self) -> Optional[str]:
        """
        HTTP2 support, default=Enable. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "h2_support")

    @property
    @pulumi.getter(name="h3Support")
    def h3_support(self) -> Optional[str]:
        """
        HTTP3/QUIC support, default=Disable. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "h3_support")

    @property
    @pulumi.getter(name="httpCookieAge")
    def http_cookie_age(self) -> Optional[int]:
        """
        Time in minutes that client web browsers should keep a cookie. Default is 60 minutes. 0 = no time limit.
        """
        return pulumi.get(self, "http_cookie_age")

    @property
    @pulumi.getter(name="httpCookieDomain")
    def http_cookie_domain(self) -> Optional[str]:
        """
        Domain that HTTP cookie persistence should apply to.
        """
        return pulumi.get(self, "http_cookie_domain")

    @property
    @pulumi.getter(name="httpCookieDomainFromHost")
    def http_cookie_domain_from_host(self) -> Optional[str]:
        """
        Enable/disable use of HTTP cookie domain from host field in HTTP. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "http_cookie_domain_from_host")

    @property
    @pulumi.getter(name="httpCookieGeneration")
    def http_cookie_generation(self) -> Optional[int]:
        """
        Generation of HTTP cookie to be accepted. Changing invalidates all existing cookies.
        """
        return pulumi.get(self, "http_cookie_generation")

    @property
    @pulumi.getter(name="httpCookiePath")
    def http_cookie_path(self) -> Optional[str]:
        """
        Limit HTTP cookie persistence to the specified path.
        """
        return pulumi.get(self, "http_cookie_path")

    @property
    @pulumi.getter(name="httpCookieShare")
    def http_cookie_share(self) -> Optional[str]:
        """
        Control sharing of cookies across API Gateway. same-ip means a cookie from one virtual server can be used by another. Disable stops cookie sharing. Valid values: `disable`, `same-ip`.
        """
        return pulumi.get(self, "http_cookie_share")

    @property
    @pulumi.getter(name="httpsCookieSecure")
    def https_cookie_secure(self) -> Optional[str]:
        """
        Enable/disable verification that inserted HTTPS cookies are secure. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "https_cookie_secure")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        API Gateway ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ldbMethod")
    def ldb_method(self) -> Optional[str]:
        """
        Method used to distribute sessions to real servers. Valid values: `static`, `round-robin`, `weighted`, `first-alive`, `http-host`.
        """
        return pulumi.get(self, "ldb_method")

    @property
    @pulumi.getter
    def persistence(self) -> Optional[str]:
        """
        Configure how to make sure that clients connect to the same server every time they make a request that is part of the same session. Valid values: `none`, `http-cookie`.
        """
        return pulumi.get(self, "persistence")

    @property
    @pulumi.getter
    def quic(self) -> Optional['outputs.AccessproxyApiGateway6Quic']:
        """
        QUIC setting. The structure of `quic` block is documented below.
        """
        return pulumi.get(self, "quic")

    @property
    @pulumi.getter
    def realservers(self) -> Optional[Sequence['outputs.AccessproxyApiGateway6Realserver']]:
        """
        Select the real servers that this Access Proxy will distribute traffic to. The structure of `realservers` block is documented below.
        """
        return pulumi.get(self, "realservers")

    @property
    @pulumi.getter(name="samlRedirect")
    def saml_redirect(self) -> Optional[str]:
        """
        Enable/disable SAML redirection after successful authentication. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "saml_redirect")

    @property
    @pulumi.getter(name="samlServer")
    def saml_server(self) -> Optional[str]:
        """
        SAML service provider configuration for VIP authentication.
        """
        return pulumi.get(self, "saml_server")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="sslAlgorithm")
    def ssl_algorithm(self) -> Optional[str]:
        """
        Permitted encryption algorithms for the server side of SSL full mode sessions according to encryption strength. Valid values: `high`, `medium`, `low`.
        """
        return pulumi.get(self, "ssl_algorithm")

    @property
    @pulumi.getter(name="sslCipherSuites")
    def ssl_cipher_suites(self) -> Optional[Sequence['outputs.AccessproxyApiGateway6SslCipherSuite']]:
        """
        SSL/TLS cipher suites to offer to a server, ordered by priority. The structure of `ssl_cipher_suites` block is documented below.
        """
        return pulumi.get(self, "ssl_cipher_suites")

    @property
    @pulumi.getter(name="sslDhBits")
    def ssl_dh_bits(self) -> Optional[str]:
        """
        Number of bits to use in the Diffie-Hellman exchange for RSA encryption of SSL sessions. Valid values: `768`, `1024`, `1536`, `2048`, `3072`, `4096`.
        """
        return pulumi.get(self, "ssl_dh_bits")

    @property
    @pulumi.getter(name="sslMaxVersion")
    def ssl_max_version(self) -> Optional[str]:
        """
        Highest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "ssl_max_version")

    @property
    @pulumi.getter(name="sslMinVersion")
    def ssl_min_version(self) -> Optional[str]:
        """
        Lowest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "ssl_min_version")

    @property
    @pulumi.getter(name="sslRenegotiation")
    def ssl_renegotiation(self) -> Optional[str]:
        """
        Enable/disable secure renegotiation to comply with RFC 5746. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ssl_renegotiation")

    @property
    @pulumi.getter(name="sslVpnWebPortal")
    def ssl_vpn_web_portal(self) -> Optional[str]:
        """
        SSL-VPN web portal.
        """
        return pulumi.get(self, "ssl_vpn_web_portal")

    @property
    @pulumi.getter(name="urlMap")
    def url_map(self) -> Optional[str]:
        """
        URL pattern to match.
        """
        return pulumi.get(self, "url_map")

    @property
    @pulumi.getter(name="urlMapType")
    def url_map_type(self) -> Optional[str]:
        """
        Type of url-map. Valid values: `sub-string`, `wildcard`, `regex`.
        """
        return pulumi.get(self, "url_map_type")

    @property
    @pulumi.getter(name="virtualHost")
    def virtual_host(self) -> Optional[str]:
        """
        Virtual host.
        """
        return pulumi.get(self, "virtual_host")


@pulumi.output_type
class AccessproxyApiGateway6Application(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: SaaS application name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        SaaS application name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AccessproxyApiGateway6Quic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ackDelayExponent":
            suggest = "ack_delay_exponent"
        elif key == "activeConnectionIdLimit":
            suggest = "active_connection_id_limit"
        elif key == "activeMigration":
            suggest = "active_migration"
        elif key == "greaseQuicBit":
            suggest = "grease_quic_bit"
        elif key == "maxAckDelay":
            suggest = "max_ack_delay"
        elif key == "maxDatagramFrameSize":
            suggest = "max_datagram_frame_size"
        elif key == "maxIdleTimeout":
            suggest = "max_idle_timeout"
        elif key == "maxUdpPayloadSize":
            suggest = "max_udp_payload_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessproxyApiGateway6Quic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessproxyApiGateway6Quic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessproxyApiGateway6Quic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ack_delay_exponent: Optional[int] = None,
                 active_connection_id_limit: Optional[int] = None,
                 active_migration: Optional[str] = None,
                 grease_quic_bit: Optional[str] = None,
                 max_ack_delay: Optional[int] = None,
                 max_datagram_frame_size: Optional[int] = None,
                 max_idle_timeout: Optional[int] = None,
                 max_udp_payload_size: Optional[int] = None):
        """
        :param int ack_delay_exponent: ACK delay exponent (1 - 20, default = 3).
        :param int active_connection_id_limit: Active connection ID limit (1 - 8, default = 2).
        :param str active_migration: Enable/disable active migration (default = disable). Valid values: `enable`, `disable`.
        :param str grease_quic_bit: Enable/disable grease QUIC bit (default = enable). Valid values: `enable`, `disable`.
        :param int max_ack_delay: Maximum ACK delay in milliseconds (1 - 16383, default = 25).
        :param int max_datagram_frame_size: Maximum datagram frame size in bytes (1 - 1500, default = 1500).
        :param int max_idle_timeout: Maximum idle timeout milliseconds (1 - 60000, default = 30000).
        :param int max_udp_payload_size: Maximum UDP payload size in bytes (1200 - 1500, default = 1500).
        """
        if ack_delay_exponent is not None:
            pulumi.set(__self__, "ack_delay_exponent", ack_delay_exponent)
        if active_connection_id_limit is not None:
            pulumi.set(__self__, "active_connection_id_limit", active_connection_id_limit)
        if active_migration is not None:
            pulumi.set(__self__, "active_migration", active_migration)
        if grease_quic_bit is not None:
            pulumi.set(__self__, "grease_quic_bit", grease_quic_bit)
        if max_ack_delay is not None:
            pulumi.set(__self__, "max_ack_delay", max_ack_delay)
        if max_datagram_frame_size is not None:
            pulumi.set(__self__, "max_datagram_frame_size", max_datagram_frame_size)
        if max_idle_timeout is not None:
            pulumi.set(__self__, "max_idle_timeout", max_idle_timeout)
        if max_udp_payload_size is not None:
            pulumi.set(__self__, "max_udp_payload_size", max_udp_payload_size)

    @property
    @pulumi.getter(name="ackDelayExponent")
    def ack_delay_exponent(self) -> Optional[int]:
        """
        ACK delay exponent (1 - 20, default = 3).
        """
        return pulumi.get(self, "ack_delay_exponent")

    @property
    @pulumi.getter(name="activeConnectionIdLimit")
    def active_connection_id_limit(self) -> Optional[int]:
        """
        Active connection ID limit (1 - 8, default = 2).
        """
        return pulumi.get(self, "active_connection_id_limit")

    @property
    @pulumi.getter(name="activeMigration")
    def active_migration(self) -> Optional[str]:
        """
        Enable/disable active migration (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "active_migration")

    @property
    @pulumi.getter(name="greaseQuicBit")
    def grease_quic_bit(self) -> Optional[str]:
        """
        Enable/disable grease QUIC bit (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "grease_quic_bit")

    @property
    @pulumi.getter(name="maxAckDelay")
    def max_ack_delay(self) -> Optional[int]:
        """
        Maximum ACK delay in milliseconds (1 - 16383, default = 25).
        """
        return pulumi.get(self, "max_ack_delay")

    @property
    @pulumi.getter(name="maxDatagramFrameSize")
    def max_datagram_frame_size(self) -> Optional[int]:
        """
        Maximum datagram frame size in bytes (1 - 1500, default = 1500).
        """
        return pulumi.get(self, "max_datagram_frame_size")

    @property
    @pulumi.getter(name="maxIdleTimeout")
    def max_idle_timeout(self) -> Optional[int]:
        """
        Maximum idle timeout milliseconds (1 - 60000, default = 30000).
        """
        return pulumi.get(self, "max_idle_timeout")

    @property
    @pulumi.getter(name="maxUdpPayloadSize")
    def max_udp_payload_size(self) -> Optional[int]:
        """
        Maximum UDP payload size in bytes (1200 - 1500, default = 1500).
        """
        return pulumi.get(self, "max_udp_payload_size")


@pulumi.output_type
class AccessproxyApiGateway6Realserver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addrType":
            suggest = "addr_type"
        elif key == "externalAuth":
            suggest = "external_auth"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "healthCheckProto":
            suggest = "health_check_proto"
        elif key == "holddownInterval":
            suggest = "holddown_interval"
        elif key == "httpHost":
            suggest = "http_host"
        elif key == "sshClientCert":
            suggest = "ssh_client_cert"
        elif key == "sshHostKeyValidation":
            suggest = "ssh_host_key_validation"
        elif key == "sshHostKeys":
            suggest = "ssh_host_keys"
        elif key == "translateHost":
            suggest = "translate_host"
        elif key == "tunnelEncryption":
            suggest = "tunnel_encryption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessproxyApiGateway6Realserver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessproxyApiGateway6Realserver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessproxyApiGateway6Realserver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addr_type: Optional[str] = None,
                 address: Optional[str] = None,
                 domain: Optional[str] = None,
                 external_auth: Optional[str] = None,
                 health_check: Optional[str] = None,
                 health_check_proto: Optional[str] = None,
                 holddown_interval: Optional[str] = None,
                 http_host: Optional[str] = None,
                 id: Optional[int] = None,
                 ip: Optional[str] = None,
                 mappedport: Optional[str] = None,
                 port: Optional[int] = None,
                 ssh_client_cert: Optional[str] = None,
                 ssh_host_key_validation: Optional[str] = None,
                 ssh_host_keys: Optional[Sequence['outputs.AccessproxyApiGateway6RealserverSshHostKey']] = None,
                 status: Optional[str] = None,
                 translate_host: Optional[str] = None,
                 tunnel_encryption: Optional[str] = None,
                 type: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param str addr_type: Type of address. Valid values: `ip`, `fqdn`.
        :param str address: Address or address group of the real server.
        :param str domain: Wildcard domain name of the real server.
        :param str external_auth: Enable/disable use of external browser as user-agent for SAML user authentication. Valid values: `enable`, `disable`.
        :param str health_check: Enable to check the responsiveness of the real server before forwarding traffic. Valid values: `disable`, `enable`.
        :param str health_check_proto: Protocol of the health check monitor to use when polling to determine server's connectivity status. Valid values: `ping`, `http`, `tcp-connect`.
        :param str holddown_interval: Enable/disable holddown timer. Server will be considered active and reachable once the holddown period has expired (30 seconds). Valid values: `enable`, `disable`.
        :param str http_host: HTTP server domain name in HTTP header.
        :param int id: Real server ID.
        :param str ip: IPv6 address of the real server.
        :param str mappedport: Port for communicating with the real server.
        :param int port: Port for communicating with the real server.
        :param str ssh_client_cert: Set access-proxy SSH client certificate profile.
        :param str ssh_host_key_validation: Enable/disable SSH real server host key validation. Valid values: `disable`, `enable`.
        :param Sequence['AccessproxyApiGateway6RealserverSshHostKeyArgs'] ssh_host_keys: One or more server host key. The structure of `ssh_host_key` block is documented below.
        :param str status: Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent. Valid values: `active`, `standby`, `disable`.
        :param str translate_host: Enable/disable translation of hostname/IP from virtual server to real server. Valid values: `enable`, `disable`.
        :param str tunnel_encryption: Tunnel encryption. Valid values: `enable`, `disable`.
        :param str type: TCP forwarding server type. Valid values: `tcp-forwarding`, `ssh`.
        :param int weight: Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
        """
        if addr_type is not None:
            pulumi.set(__self__, "addr_type", addr_type)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if external_auth is not None:
            pulumi.set(__self__, "external_auth", external_auth)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if health_check_proto is not None:
            pulumi.set(__self__, "health_check_proto", health_check_proto)
        if holddown_interval is not None:
            pulumi.set(__self__, "holddown_interval", holddown_interval)
        if http_host is not None:
            pulumi.set(__self__, "http_host", http_host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if mappedport is not None:
            pulumi.set(__self__, "mappedport", mappedport)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_client_cert is not None:
            pulumi.set(__self__, "ssh_client_cert", ssh_client_cert)
        if ssh_host_key_validation is not None:
            pulumi.set(__self__, "ssh_host_key_validation", ssh_host_key_validation)
        if ssh_host_keys is not None:
            pulumi.set(__self__, "ssh_host_keys", ssh_host_keys)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if translate_host is not None:
            pulumi.set(__self__, "translate_host", translate_host)
        if tunnel_encryption is not None:
            pulumi.set(__self__, "tunnel_encryption", tunnel_encryption)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="addrType")
    def addr_type(self) -> Optional[str]:
        """
        Type of address. Valid values: `ip`, `fqdn`.
        """
        return pulumi.get(self, "addr_type")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Address or address group of the real server.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Wildcard domain name of the real server.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="externalAuth")
    def external_auth(self) -> Optional[str]:
        """
        Enable/disable use of external browser as user-agent for SAML user authentication. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "external_auth")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[str]:
        """
        Enable to check the responsiveness of the real server before forwarding traffic. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter(name="healthCheckProto")
    def health_check_proto(self) -> Optional[str]:
        """
        Protocol of the health check monitor to use when polling to determine server's connectivity status. Valid values: `ping`, `http`, `tcp-connect`.
        """
        return pulumi.get(self, "health_check_proto")

    @property
    @pulumi.getter(name="holddownInterval")
    def holddown_interval(self) -> Optional[str]:
        """
        Enable/disable holddown timer. Server will be considered active and reachable once the holddown period has expired (30 seconds). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "holddown_interval")

    @property
    @pulumi.getter(name="httpHost")
    def http_host(self) -> Optional[str]:
        """
        HTTP server domain name in HTTP header.
        """
        return pulumi.get(self, "http_host")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Real server ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv6 address of the real server.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def mappedport(self) -> Optional[str]:
        """
        Port for communicating with the real server.
        """
        return pulumi.get(self, "mappedport")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for communicating with the real server.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sshClientCert")
    def ssh_client_cert(self) -> Optional[str]:
        """
        Set access-proxy SSH client certificate profile.
        """
        return pulumi.get(self, "ssh_client_cert")

    @property
    @pulumi.getter(name="sshHostKeyValidation")
    def ssh_host_key_validation(self) -> Optional[str]:
        """
        Enable/disable SSH real server host key validation. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "ssh_host_key_validation")

    @property
    @pulumi.getter(name="sshHostKeys")
    def ssh_host_keys(self) -> Optional[Sequence['outputs.AccessproxyApiGateway6RealserverSshHostKey']]:
        """
        One or more server host key. The structure of `ssh_host_key` block is documented below.
        """
        return pulumi.get(self, "ssh_host_keys")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent. Valid values: `active`, `standby`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="translateHost")
    def translate_host(self) -> Optional[str]:
        """
        Enable/disable translation of hostname/IP from virtual server to real server. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "translate_host")

    @property
    @pulumi.getter(name="tunnelEncryption")
    def tunnel_encryption(self) -> Optional[str]:
        """
        Tunnel encryption. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "tunnel_encryption")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        TCP forwarding server type. Valid values: `tcp-forwarding`, `ssh`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class AccessproxyApiGateway6RealserverSshHostKey(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Server host key name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Server host key name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AccessproxyApiGateway6SslCipherSuite(dict):
    def __init__(__self__, *,
                 cipher: Optional[str] = None,
                 priority: Optional[int] = None,
                 versions: Optional[str] = None):
        """
        :param str cipher: Cipher suite name. Valid values: `TLS-AES-128-GCM-SHA256`, `TLS-AES-256-GCM-SHA384`, `TLS-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-ECDSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-128-GCM-SHA256`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-AES-128-CBC-SHA`, `TLS-RSA-WITH-AES-256-CBC-SHA`, `TLS-RSA-WITH-AES-128-CBC-SHA256`, `TLS-RSA-WITH-AES-128-GCM-SHA256`, `TLS-RSA-WITH-AES-256-CBC-SHA256`, `TLS-RSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-SEED-CBC-SHA`, `TLS-DHE-DSS-WITH-SEED-CBC-SHA`, `TLS-DHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-DHE-DSS-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-ARIA-256-CBC-SHA384`, `TLS-RSA-WITH-SEED-CBC-SHA`, `TLS-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-RC4-128-SHA`, `TLS-ECDHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-DSS-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-RC4-128-MD5`, `TLS-RSA-WITH-RC4-128-SHA`, `TLS-DHE-RSA-WITH-DES-CBC-SHA`, `TLS-DHE-DSS-WITH-DES-CBC-SHA`, `TLS-RSA-WITH-DES-CBC-SHA`.
        :param int priority: SSL/TLS cipher suites priority.
        :param str versions: SSL/TLS versions that the cipher suite can be used with. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        if cipher is not None:
            pulumi.set(__self__, "cipher", cipher)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def cipher(self) -> Optional[str]:
        """
        Cipher suite name. Valid values: `TLS-AES-128-GCM-SHA256`, `TLS-AES-256-GCM-SHA384`, `TLS-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-ECDSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-128-GCM-SHA256`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-AES-128-CBC-SHA`, `TLS-RSA-WITH-AES-256-CBC-SHA`, `TLS-RSA-WITH-AES-128-CBC-SHA256`, `TLS-RSA-WITH-AES-128-GCM-SHA256`, `TLS-RSA-WITH-AES-256-CBC-SHA256`, `TLS-RSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-SEED-CBC-SHA`, `TLS-DHE-DSS-WITH-SEED-CBC-SHA`, `TLS-DHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-DHE-DSS-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-ARIA-256-CBC-SHA384`, `TLS-RSA-WITH-SEED-CBC-SHA`, `TLS-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-RC4-128-SHA`, `TLS-ECDHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-DSS-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-RC4-128-MD5`, `TLS-RSA-WITH-RC4-128-SHA`, `TLS-DHE-RSA-WITH-DES-CBC-SHA`, `TLS-DHE-DSS-WITH-DES-CBC-SHA`, `TLS-RSA-WITH-DES-CBC-SHA`.
        """
        return pulumi.get(self, "cipher")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        SSL/TLS cipher suites priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def versions(self) -> Optional[str]:
        """
        SSL/TLS versions that the cipher suite can be used with. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class AccessproxyApiGateway(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "h2Support":
            suggest = "h2_support"
        elif key == "h3Support":
            suggest = "h3_support"
        elif key == "httpCookieAge":
            suggest = "http_cookie_age"
        elif key == "httpCookieDomain":
            suggest = "http_cookie_domain"
        elif key == "httpCookieDomainFromHost":
            suggest = "http_cookie_domain_from_host"
        elif key == "httpCookieGeneration":
            suggest = "http_cookie_generation"
        elif key == "httpCookiePath":
            suggest = "http_cookie_path"
        elif key == "httpCookieShare":
            suggest = "http_cookie_share"
        elif key == "httpsCookieSecure":
            suggest = "https_cookie_secure"
        elif key == "ldbMethod":
            suggest = "ldb_method"
        elif key == "samlRedirect":
            suggest = "saml_redirect"
        elif key == "samlServer":
            suggest = "saml_server"
        elif key == "sslAlgorithm":
            suggest = "ssl_algorithm"
        elif key == "sslCipherSuites":
            suggest = "ssl_cipher_suites"
        elif key == "sslDhBits":
            suggest = "ssl_dh_bits"
        elif key == "sslMaxVersion":
            suggest = "ssl_max_version"
        elif key == "sslMinVersion":
            suggest = "ssl_min_version"
        elif key == "sslRenegotiation":
            suggest = "ssl_renegotiation"
        elif key == "sslVpnWebPortal":
            suggest = "ssl_vpn_web_portal"
        elif key == "urlMap":
            suggest = "url_map"
        elif key == "urlMapType":
            suggest = "url_map_type"
        elif key == "virtualHost":
            suggest = "virtual_host"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessproxyApiGateway. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessproxyApiGateway.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessproxyApiGateway.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 applications: Optional[Sequence['outputs.AccessproxyApiGatewayApplication']] = None,
                 h2_support: Optional[str] = None,
                 h3_support: Optional[str] = None,
                 http_cookie_age: Optional[int] = None,
                 http_cookie_domain: Optional[str] = None,
                 http_cookie_domain_from_host: Optional[str] = None,
                 http_cookie_generation: Optional[int] = None,
                 http_cookie_path: Optional[str] = None,
                 http_cookie_share: Optional[str] = None,
                 https_cookie_secure: Optional[str] = None,
                 id: Optional[int] = None,
                 ldb_method: Optional[str] = None,
                 persistence: Optional[str] = None,
                 quic: Optional['outputs.AccessproxyApiGatewayQuic'] = None,
                 realservers: Optional[Sequence['outputs.AccessproxyApiGatewayRealserver']] = None,
                 saml_redirect: Optional[str] = None,
                 saml_server: Optional[str] = None,
                 service: Optional[str] = None,
                 ssl_algorithm: Optional[str] = None,
                 ssl_cipher_suites: Optional[Sequence['outputs.AccessproxyApiGatewaySslCipherSuite']] = None,
                 ssl_dh_bits: Optional[str] = None,
                 ssl_max_version: Optional[str] = None,
                 ssl_min_version: Optional[str] = None,
                 ssl_renegotiation: Optional[str] = None,
                 ssl_vpn_web_portal: Optional[str] = None,
                 url_map: Optional[str] = None,
                 url_map_type: Optional[str] = None,
                 virtual_host: Optional[str] = None):
        """
        :param Sequence['AccessproxyApiGatewayApplicationArgs'] applications: SaaS application controlled by this Access Proxy. The structure of `application` block is documented below.
        :param str h2_support: HTTP2 support, default=Enable. Valid values: `enable`, `disable`.
        :param str h3_support: HTTP3/QUIC support, default=Disable. Valid values: `enable`, `disable`.
        :param int http_cookie_age: Time in minutes that client web browsers should keep a cookie. Default is 60 minutes. 0 = no time limit.
        :param str http_cookie_domain: Domain that HTTP cookie persistence should apply to.
        :param str http_cookie_domain_from_host: Enable/disable use of HTTP cookie domain from host field in HTTP. Valid values: `disable`, `enable`.
        :param int http_cookie_generation: Generation of HTTP cookie to be accepted. Changing invalidates all existing cookies.
        :param str http_cookie_path: Limit HTTP cookie persistence to the specified path.
        :param str http_cookie_share: Control sharing of cookies across API Gateway. same-ip means a cookie from one virtual server can be used by another. Disable stops cookie sharing. Valid values: `disable`, `same-ip`.
        :param str https_cookie_secure: Enable/disable verification that inserted HTTPS cookies are secure. Valid values: `disable`, `enable`.
        :param int id: API Gateway ID.
        :param str ldb_method: Method used to distribute sessions to real servers. Valid values: `static`, `round-robin`, `weighted`, `first-alive`, `http-host`.
        :param str persistence: Configure how to make sure that clients connect to the same server every time they make a request that is part of the same session. Valid values: `none`, `http-cookie`.
        :param 'AccessproxyApiGatewayQuicArgs' quic: QUIC setting. The structure of `quic` block is documented below.
        :param Sequence['AccessproxyApiGatewayRealserverArgs'] realservers: Select the real servers that this Access Proxy will distribute traffic to. The structure of `realservers` block is documented below.
        :param str saml_redirect: Enable/disable SAML redirection after successful authentication. Valid values: `disable`, `enable`.
        :param str saml_server: SAML service provider configuration for VIP authentication.
        :param str service: Service.
        :param str ssl_algorithm: Permitted encryption algorithms for the server side of SSL full mode sessions according to encryption strength. Valid values: `high`, `medium`, `low`.
        :param Sequence['AccessproxyApiGatewaySslCipherSuiteArgs'] ssl_cipher_suites: SSL/TLS cipher suites to offer to a server, ordered by priority. The structure of `ssl_cipher_suites` block is documented below.
        :param str ssl_dh_bits: Number of bits to use in the Diffie-Hellman exchange for RSA encryption of SSL sessions. Valid values: `768`, `1024`, `1536`, `2048`, `3072`, `4096`.
        :param str ssl_max_version: Highest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        :param str ssl_min_version: Lowest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        :param str ssl_renegotiation: Enable/disable secure renegotiation to comply with RFC 5746. Valid values: `enable`, `disable`.
        :param str ssl_vpn_web_portal: SSL-VPN web portal.
        :param str url_map: URL pattern to match.
        :param str url_map_type: Type of url-map. Valid values: `sub-string`, `wildcard`, `regex`.
        :param str virtual_host: Virtual host.
        """
        if applications is not None:
            pulumi.set(__self__, "applications", applications)
        if h2_support is not None:
            pulumi.set(__self__, "h2_support", h2_support)
        if h3_support is not None:
            pulumi.set(__self__, "h3_support", h3_support)
        if http_cookie_age is not None:
            pulumi.set(__self__, "http_cookie_age", http_cookie_age)
        if http_cookie_domain is not None:
            pulumi.set(__self__, "http_cookie_domain", http_cookie_domain)
        if http_cookie_domain_from_host is not None:
            pulumi.set(__self__, "http_cookie_domain_from_host", http_cookie_domain_from_host)
        if http_cookie_generation is not None:
            pulumi.set(__self__, "http_cookie_generation", http_cookie_generation)
        if http_cookie_path is not None:
            pulumi.set(__self__, "http_cookie_path", http_cookie_path)
        if http_cookie_share is not None:
            pulumi.set(__self__, "http_cookie_share", http_cookie_share)
        if https_cookie_secure is not None:
            pulumi.set(__self__, "https_cookie_secure", https_cookie_secure)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ldb_method is not None:
            pulumi.set(__self__, "ldb_method", ldb_method)
        if persistence is not None:
            pulumi.set(__self__, "persistence", persistence)
        if quic is not None:
            pulumi.set(__self__, "quic", quic)
        if realservers is not None:
            pulumi.set(__self__, "realservers", realservers)
        if saml_redirect is not None:
            pulumi.set(__self__, "saml_redirect", saml_redirect)
        if saml_server is not None:
            pulumi.set(__self__, "saml_server", saml_server)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if ssl_algorithm is not None:
            pulumi.set(__self__, "ssl_algorithm", ssl_algorithm)
        if ssl_cipher_suites is not None:
            pulumi.set(__self__, "ssl_cipher_suites", ssl_cipher_suites)
        if ssl_dh_bits is not None:
            pulumi.set(__self__, "ssl_dh_bits", ssl_dh_bits)
        if ssl_max_version is not None:
            pulumi.set(__self__, "ssl_max_version", ssl_max_version)
        if ssl_min_version is not None:
            pulumi.set(__self__, "ssl_min_version", ssl_min_version)
        if ssl_renegotiation is not None:
            pulumi.set(__self__, "ssl_renegotiation", ssl_renegotiation)
        if ssl_vpn_web_portal is not None:
            pulumi.set(__self__, "ssl_vpn_web_portal", ssl_vpn_web_portal)
        if url_map is not None:
            pulumi.set(__self__, "url_map", url_map)
        if url_map_type is not None:
            pulumi.set(__self__, "url_map_type", url_map_type)
        if virtual_host is not None:
            pulumi.set(__self__, "virtual_host", virtual_host)

    @property
    @pulumi.getter
    def applications(self) -> Optional[Sequence['outputs.AccessproxyApiGatewayApplication']]:
        """
        SaaS application controlled by this Access Proxy. The structure of `application` block is documented below.
        """
        return pulumi.get(self, "applications")

    @property
    @pulumi.getter(name="h2Support")
    def h2_support(self) -> Optional[str]:
        """
        HTTP2 support, default=Enable. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "h2_support")

    @property
    @pulumi.getter(name="h3Support")
    def h3_support(self) -> Optional[str]:
        """
        HTTP3/QUIC support, default=Disable. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "h3_support")

    @property
    @pulumi.getter(name="httpCookieAge")
    def http_cookie_age(self) -> Optional[int]:
        """
        Time in minutes that client web browsers should keep a cookie. Default is 60 minutes. 0 = no time limit.
        """
        return pulumi.get(self, "http_cookie_age")

    @property
    @pulumi.getter(name="httpCookieDomain")
    def http_cookie_domain(self) -> Optional[str]:
        """
        Domain that HTTP cookie persistence should apply to.
        """
        return pulumi.get(self, "http_cookie_domain")

    @property
    @pulumi.getter(name="httpCookieDomainFromHost")
    def http_cookie_domain_from_host(self) -> Optional[str]:
        """
        Enable/disable use of HTTP cookie domain from host field in HTTP. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "http_cookie_domain_from_host")

    @property
    @pulumi.getter(name="httpCookieGeneration")
    def http_cookie_generation(self) -> Optional[int]:
        """
        Generation of HTTP cookie to be accepted. Changing invalidates all existing cookies.
        """
        return pulumi.get(self, "http_cookie_generation")

    @property
    @pulumi.getter(name="httpCookiePath")
    def http_cookie_path(self) -> Optional[str]:
        """
        Limit HTTP cookie persistence to the specified path.
        """
        return pulumi.get(self, "http_cookie_path")

    @property
    @pulumi.getter(name="httpCookieShare")
    def http_cookie_share(self) -> Optional[str]:
        """
        Control sharing of cookies across API Gateway. same-ip means a cookie from one virtual server can be used by another. Disable stops cookie sharing. Valid values: `disable`, `same-ip`.
        """
        return pulumi.get(self, "http_cookie_share")

    @property
    @pulumi.getter(name="httpsCookieSecure")
    def https_cookie_secure(self) -> Optional[str]:
        """
        Enable/disable verification that inserted HTTPS cookies are secure. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "https_cookie_secure")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        API Gateway ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ldbMethod")
    def ldb_method(self) -> Optional[str]:
        """
        Method used to distribute sessions to real servers. Valid values: `static`, `round-robin`, `weighted`, `first-alive`, `http-host`.
        """
        return pulumi.get(self, "ldb_method")

    @property
    @pulumi.getter
    def persistence(self) -> Optional[str]:
        """
        Configure how to make sure that clients connect to the same server every time they make a request that is part of the same session. Valid values: `none`, `http-cookie`.
        """
        return pulumi.get(self, "persistence")

    @property
    @pulumi.getter
    def quic(self) -> Optional['outputs.AccessproxyApiGatewayQuic']:
        """
        QUIC setting. The structure of `quic` block is documented below.
        """
        return pulumi.get(self, "quic")

    @property
    @pulumi.getter
    def realservers(self) -> Optional[Sequence['outputs.AccessproxyApiGatewayRealserver']]:
        """
        Select the real servers that this Access Proxy will distribute traffic to. The structure of `realservers` block is documented below.
        """
        return pulumi.get(self, "realservers")

    @property
    @pulumi.getter(name="samlRedirect")
    def saml_redirect(self) -> Optional[str]:
        """
        Enable/disable SAML redirection after successful authentication. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "saml_redirect")

    @property
    @pulumi.getter(name="samlServer")
    def saml_server(self) -> Optional[str]:
        """
        SAML service provider configuration for VIP authentication.
        """
        return pulumi.get(self, "saml_server")

    @property
    @pulumi.getter
    def service(self) -> Optional[str]:
        """
        Service.
        """
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="sslAlgorithm")
    def ssl_algorithm(self) -> Optional[str]:
        """
        Permitted encryption algorithms for the server side of SSL full mode sessions according to encryption strength. Valid values: `high`, `medium`, `low`.
        """
        return pulumi.get(self, "ssl_algorithm")

    @property
    @pulumi.getter(name="sslCipherSuites")
    def ssl_cipher_suites(self) -> Optional[Sequence['outputs.AccessproxyApiGatewaySslCipherSuite']]:
        """
        SSL/TLS cipher suites to offer to a server, ordered by priority. The structure of `ssl_cipher_suites` block is documented below.
        """
        return pulumi.get(self, "ssl_cipher_suites")

    @property
    @pulumi.getter(name="sslDhBits")
    def ssl_dh_bits(self) -> Optional[str]:
        """
        Number of bits to use in the Diffie-Hellman exchange for RSA encryption of SSL sessions. Valid values: `768`, `1024`, `1536`, `2048`, `3072`, `4096`.
        """
        return pulumi.get(self, "ssl_dh_bits")

    @property
    @pulumi.getter(name="sslMaxVersion")
    def ssl_max_version(self) -> Optional[str]:
        """
        Highest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "ssl_max_version")

    @property
    @pulumi.getter(name="sslMinVersion")
    def ssl_min_version(self) -> Optional[str]:
        """
        Lowest SSL/TLS version acceptable from a server. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "ssl_min_version")

    @property
    @pulumi.getter(name="sslRenegotiation")
    def ssl_renegotiation(self) -> Optional[str]:
        """
        Enable/disable secure renegotiation to comply with RFC 5746. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ssl_renegotiation")

    @property
    @pulumi.getter(name="sslVpnWebPortal")
    def ssl_vpn_web_portal(self) -> Optional[str]:
        """
        SSL-VPN web portal.
        """
        return pulumi.get(self, "ssl_vpn_web_portal")

    @property
    @pulumi.getter(name="urlMap")
    def url_map(self) -> Optional[str]:
        """
        URL pattern to match.
        """
        return pulumi.get(self, "url_map")

    @property
    @pulumi.getter(name="urlMapType")
    def url_map_type(self) -> Optional[str]:
        """
        Type of url-map. Valid values: `sub-string`, `wildcard`, `regex`.
        """
        return pulumi.get(self, "url_map_type")

    @property
    @pulumi.getter(name="virtualHost")
    def virtual_host(self) -> Optional[str]:
        """
        Virtual host.
        """
        return pulumi.get(self, "virtual_host")


@pulumi.output_type
class AccessproxyApiGatewayApplication(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: SaaS application name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        SaaS application name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AccessproxyApiGatewayQuic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ackDelayExponent":
            suggest = "ack_delay_exponent"
        elif key == "activeConnectionIdLimit":
            suggest = "active_connection_id_limit"
        elif key == "activeMigration":
            suggest = "active_migration"
        elif key == "greaseQuicBit":
            suggest = "grease_quic_bit"
        elif key == "maxAckDelay":
            suggest = "max_ack_delay"
        elif key == "maxDatagramFrameSize":
            suggest = "max_datagram_frame_size"
        elif key == "maxIdleTimeout":
            suggest = "max_idle_timeout"
        elif key == "maxUdpPayloadSize":
            suggest = "max_udp_payload_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessproxyApiGatewayQuic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessproxyApiGatewayQuic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessproxyApiGatewayQuic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ack_delay_exponent: Optional[int] = None,
                 active_connection_id_limit: Optional[int] = None,
                 active_migration: Optional[str] = None,
                 grease_quic_bit: Optional[str] = None,
                 max_ack_delay: Optional[int] = None,
                 max_datagram_frame_size: Optional[int] = None,
                 max_idle_timeout: Optional[int] = None,
                 max_udp_payload_size: Optional[int] = None):
        """
        :param int ack_delay_exponent: ACK delay exponent (1 - 20, default = 3).
        :param int active_connection_id_limit: Active connection ID limit (1 - 8, default = 2).
        :param str active_migration: Enable/disable active migration (default = disable). Valid values: `enable`, `disable`.
        :param str grease_quic_bit: Enable/disable grease QUIC bit (default = enable). Valid values: `enable`, `disable`.
        :param int max_ack_delay: Maximum ACK delay in milliseconds (1 - 16383, default = 25).
        :param int max_datagram_frame_size: Maximum datagram frame size in bytes (1 - 1500, default = 1500).
        :param int max_idle_timeout: Maximum idle timeout milliseconds (1 - 60000, default = 30000).
        :param int max_udp_payload_size: Maximum UDP payload size in bytes (1200 - 1500, default = 1500).
        """
        if ack_delay_exponent is not None:
            pulumi.set(__self__, "ack_delay_exponent", ack_delay_exponent)
        if active_connection_id_limit is not None:
            pulumi.set(__self__, "active_connection_id_limit", active_connection_id_limit)
        if active_migration is not None:
            pulumi.set(__self__, "active_migration", active_migration)
        if grease_quic_bit is not None:
            pulumi.set(__self__, "grease_quic_bit", grease_quic_bit)
        if max_ack_delay is not None:
            pulumi.set(__self__, "max_ack_delay", max_ack_delay)
        if max_datagram_frame_size is not None:
            pulumi.set(__self__, "max_datagram_frame_size", max_datagram_frame_size)
        if max_idle_timeout is not None:
            pulumi.set(__self__, "max_idle_timeout", max_idle_timeout)
        if max_udp_payload_size is not None:
            pulumi.set(__self__, "max_udp_payload_size", max_udp_payload_size)

    @property
    @pulumi.getter(name="ackDelayExponent")
    def ack_delay_exponent(self) -> Optional[int]:
        """
        ACK delay exponent (1 - 20, default = 3).
        """
        return pulumi.get(self, "ack_delay_exponent")

    @property
    @pulumi.getter(name="activeConnectionIdLimit")
    def active_connection_id_limit(self) -> Optional[int]:
        """
        Active connection ID limit (1 - 8, default = 2).
        """
        return pulumi.get(self, "active_connection_id_limit")

    @property
    @pulumi.getter(name="activeMigration")
    def active_migration(self) -> Optional[str]:
        """
        Enable/disable active migration (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "active_migration")

    @property
    @pulumi.getter(name="greaseQuicBit")
    def grease_quic_bit(self) -> Optional[str]:
        """
        Enable/disable grease QUIC bit (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "grease_quic_bit")

    @property
    @pulumi.getter(name="maxAckDelay")
    def max_ack_delay(self) -> Optional[int]:
        """
        Maximum ACK delay in milliseconds (1 - 16383, default = 25).
        """
        return pulumi.get(self, "max_ack_delay")

    @property
    @pulumi.getter(name="maxDatagramFrameSize")
    def max_datagram_frame_size(self) -> Optional[int]:
        """
        Maximum datagram frame size in bytes (1 - 1500, default = 1500).
        """
        return pulumi.get(self, "max_datagram_frame_size")

    @property
    @pulumi.getter(name="maxIdleTimeout")
    def max_idle_timeout(self) -> Optional[int]:
        """
        Maximum idle timeout milliseconds (1 - 60000, default = 30000).
        """
        return pulumi.get(self, "max_idle_timeout")

    @property
    @pulumi.getter(name="maxUdpPayloadSize")
    def max_udp_payload_size(self) -> Optional[int]:
        """
        Maximum UDP payload size in bytes (1200 - 1500, default = 1500).
        """
        return pulumi.get(self, "max_udp_payload_size")


@pulumi.output_type
class AccessproxyApiGatewayRealserver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addrType":
            suggest = "addr_type"
        elif key == "externalAuth":
            suggest = "external_auth"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "healthCheckProto":
            suggest = "health_check_proto"
        elif key == "holddownInterval":
            suggest = "holddown_interval"
        elif key == "httpHost":
            suggest = "http_host"
        elif key == "sshClientCert":
            suggest = "ssh_client_cert"
        elif key == "sshHostKeyValidation":
            suggest = "ssh_host_key_validation"
        elif key == "sshHostKeys":
            suggest = "ssh_host_keys"
        elif key == "translateHost":
            suggest = "translate_host"
        elif key == "tunnelEncryption":
            suggest = "tunnel_encryption"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccessproxyApiGatewayRealserver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccessproxyApiGatewayRealserver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccessproxyApiGatewayRealserver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addr_type: Optional[str] = None,
                 address: Optional[str] = None,
                 domain: Optional[str] = None,
                 external_auth: Optional[str] = None,
                 health_check: Optional[str] = None,
                 health_check_proto: Optional[str] = None,
                 holddown_interval: Optional[str] = None,
                 http_host: Optional[str] = None,
                 id: Optional[int] = None,
                 ip: Optional[str] = None,
                 mappedport: Optional[str] = None,
                 port: Optional[int] = None,
                 ssh_client_cert: Optional[str] = None,
                 ssh_host_key_validation: Optional[str] = None,
                 ssh_host_keys: Optional[Sequence['outputs.AccessproxyApiGatewayRealserverSshHostKey']] = None,
                 status: Optional[str] = None,
                 translate_host: Optional[str] = None,
                 tunnel_encryption: Optional[str] = None,
                 type: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param str addr_type: Type of address. Valid values: `ip`, `fqdn`.
        :param str address: Address or address group of the real server.
        :param str domain: Wildcard domain name of the real server.
        :param str external_auth: Enable/disable use of external browser as user-agent for SAML user authentication. Valid values: `enable`, `disable`.
        :param str health_check: Enable to check the responsiveness of the real server before forwarding traffic. Valid values: `disable`, `enable`.
        :param str health_check_proto: Protocol of the health check monitor to use when polling to determine server's connectivity status. Valid values: `ping`, `http`, `tcp-connect`.
        :param str holddown_interval: Enable/disable holddown timer. Server will be considered active and reachable once the holddown period has expired (30 seconds). Valid values: `enable`, `disable`.
        :param str http_host: HTTP server domain name in HTTP header.
        :param int id: Real server ID.
        :param str ip: IPv6 address of the real server.
        :param str mappedport: Port for communicating with the real server.
        :param int port: Port for communicating with the real server.
        :param str ssh_client_cert: Set access-proxy SSH client certificate profile.
        :param str ssh_host_key_validation: Enable/disable SSH real server host key validation. Valid values: `disable`, `enable`.
        :param Sequence['AccessproxyApiGatewayRealserverSshHostKeyArgs'] ssh_host_keys: One or more server host key. The structure of `ssh_host_key` block is documented below.
        :param str status: Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent. Valid values: `active`, `standby`, `disable`.
        :param str translate_host: Enable/disable translation of hostname/IP from virtual server to real server. Valid values: `enable`, `disable`.
        :param str tunnel_encryption: Tunnel encryption. Valid values: `enable`, `disable`.
        :param str type: TCP forwarding server type. Valid values: `tcp-forwarding`, `ssh`.
        :param int weight: Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
        """
        if addr_type is not None:
            pulumi.set(__self__, "addr_type", addr_type)
        if address is not None:
            pulumi.set(__self__, "address", address)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if external_auth is not None:
            pulumi.set(__self__, "external_auth", external_auth)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if health_check_proto is not None:
            pulumi.set(__self__, "health_check_proto", health_check_proto)
        if holddown_interval is not None:
            pulumi.set(__self__, "holddown_interval", holddown_interval)
        if http_host is not None:
            pulumi.set(__self__, "http_host", http_host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if mappedport is not None:
            pulumi.set(__self__, "mappedport", mappedport)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssh_client_cert is not None:
            pulumi.set(__self__, "ssh_client_cert", ssh_client_cert)
        if ssh_host_key_validation is not None:
            pulumi.set(__self__, "ssh_host_key_validation", ssh_host_key_validation)
        if ssh_host_keys is not None:
            pulumi.set(__self__, "ssh_host_keys", ssh_host_keys)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if translate_host is not None:
            pulumi.set(__self__, "translate_host", translate_host)
        if tunnel_encryption is not None:
            pulumi.set(__self__, "tunnel_encryption", tunnel_encryption)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="addrType")
    def addr_type(self) -> Optional[str]:
        """
        Type of address. Valid values: `ip`, `fqdn`.
        """
        return pulumi.get(self, "addr_type")

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Address or address group of the real server.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        Wildcard domain name of the real server.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter(name="externalAuth")
    def external_auth(self) -> Optional[str]:
        """
        Enable/disable use of external browser as user-agent for SAML user authentication. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "external_auth")

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[str]:
        """
        Enable to check the responsiveness of the real server before forwarding traffic. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "health_check")

    @property
    @pulumi.getter(name="healthCheckProto")
    def health_check_proto(self) -> Optional[str]:
        """
        Protocol of the health check monitor to use when polling to determine server's connectivity status. Valid values: `ping`, `http`, `tcp-connect`.
        """
        return pulumi.get(self, "health_check_proto")

    @property
    @pulumi.getter(name="holddownInterval")
    def holddown_interval(self) -> Optional[str]:
        """
        Enable/disable holddown timer. Server will be considered active and reachable once the holddown period has expired (30 seconds). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "holddown_interval")

    @property
    @pulumi.getter(name="httpHost")
    def http_host(self) -> Optional[str]:
        """
        HTTP server domain name in HTTP header.
        """
        return pulumi.get(self, "http_host")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Real server ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv6 address of the real server.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def mappedport(self) -> Optional[str]:
        """
        Port for communicating with the real server.
        """
        return pulumi.get(self, "mappedport")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for communicating with the real server.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="sshClientCert")
    def ssh_client_cert(self) -> Optional[str]:
        """
        Set access-proxy SSH client certificate profile.
        """
        return pulumi.get(self, "ssh_client_cert")

    @property
    @pulumi.getter(name="sshHostKeyValidation")
    def ssh_host_key_validation(self) -> Optional[str]:
        """
        Enable/disable SSH real server host key validation. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "ssh_host_key_validation")

    @property
    @pulumi.getter(name="sshHostKeys")
    def ssh_host_keys(self) -> Optional[Sequence['outputs.AccessproxyApiGatewayRealserverSshHostKey']]:
        """
        One or more server host key. The structure of `ssh_host_key` block is documented below.
        """
        return pulumi.get(self, "ssh_host_keys")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent. Valid values: `active`, `standby`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="translateHost")
    def translate_host(self) -> Optional[str]:
        """
        Enable/disable translation of hostname/IP from virtual server to real server. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "translate_host")

    @property
    @pulumi.getter(name="tunnelEncryption")
    def tunnel_encryption(self) -> Optional[str]:
        """
        Tunnel encryption. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "tunnel_encryption")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        TCP forwarding server type. Valid values: `tcp-forwarding`, `ssh`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class AccessproxyApiGatewayRealserverSshHostKey(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Server host key name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Server host key name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AccessproxyApiGatewaySslCipherSuite(dict):
    def __init__(__self__, *,
                 cipher: Optional[str] = None,
                 priority: Optional[int] = None,
                 versions: Optional[str] = None):
        """
        :param str cipher: Cipher suite name. Valid values: `TLS-AES-128-GCM-SHA256`, `TLS-AES-256-GCM-SHA384`, `TLS-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-ECDSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-128-GCM-SHA256`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-AES-128-CBC-SHA`, `TLS-RSA-WITH-AES-256-CBC-SHA`, `TLS-RSA-WITH-AES-128-CBC-SHA256`, `TLS-RSA-WITH-AES-128-GCM-SHA256`, `TLS-RSA-WITH-AES-256-CBC-SHA256`, `TLS-RSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-SEED-CBC-SHA`, `TLS-DHE-DSS-WITH-SEED-CBC-SHA`, `TLS-DHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-DHE-DSS-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-ARIA-256-CBC-SHA384`, `TLS-RSA-WITH-SEED-CBC-SHA`, `TLS-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-RC4-128-SHA`, `TLS-ECDHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-DSS-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-RC4-128-MD5`, `TLS-RSA-WITH-RC4-128-SHA`, `TLS-DHE-RSA-WITH-DES-CBC-SHA`, `TLS-DHE-DSS-WITH-DES-CBC-SHA`, `TLS-RSA-WITH-DES-CBC-SHA`.
        :param int priority: SSL/TLS cipher suites priority.
        :param str versions: SSL/TLS versions that the cipher suite can be used with. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        if cipher is not None:
            pulumi.set(__self__, "cipher", cipher)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def cipher(self) -> Optional[str]:
        """
        Cipher suite name. Valid values: `TLS-AES-128-GCM-SHA256`, `TLS-AES-256-GCM-SHA384`, `TLS-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-ECDHE-ECDSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-CHACHA20-POLY1305-SHA256`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-DHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-DHE-RSA-WITH-AES-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA`, `TLS-DHE-DSS-WITH-AES-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-128-GCM-SHA256`, `TLS-DHE-DSS-WITH-AES-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-RSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-AES-256-GCM-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-128-GCM-SHA256`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA`, `TLS-ECDHE-ECDSA-WITH-AES-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-AES-128-CBC-SHA`, `TLS-RSA-WITH-AES-256-CBC-SHA`, `TLS-RSA-WITH-AES-128-CBC-SHA256`, `TLS-RSA-WITH-AES-128-GCM-SHA256`, `TLS-RSA-WITH-AES-256-CBC-SHA256`, `TLS-RSA-WITH-AES-256-GCM-SHA384`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA`, `TLS-DHE-RSA-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-DSS-WITH-CAMELLIA-256-CBC-SHA256`, `TLS-DHE-RSA-WITH-SEED-CBC-SHA`, `TLS-DHE-DSS-WITH-SEED-CBC-SHA`, `TLS-DHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-DHE-DSS-WITH-ARIA-128-CBC-SHA256`, `TLS-DHE-DSS-WITH-ARIA-256-CBC-SHA384`, `TLS-RSA-WITH-SEED-CBC-SHA`, `TLS-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-RSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-ECDSA-WITH-ARIA-128-CBC-SHA256`, `TLS-ECDHE-ECDSA-WITH-ARIA-256-CBC-SHA384`, `TLS-ECDHE-RSA-WITH-RC4-128-SHA`, `TLS-ECDHE-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-DHE-DSS-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-3DES-EDE-CBC-SHA`, `TLS-RSA-WITH-RC4-128-MD5`, `TLS-RSA-WITH-RC4-128-SHA`, `TLS-DHE-RSA-WITH-DES-CBC-SHA`, `TLS-DHE-DSS-WITH-DES-CBC-SHA`, `TLS-RSA-WITH-DES-CBC-SHA`.
        """
        return pulumi.get(self, "cipher")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        SSL/TLS cipher suites priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def versions(self) -> Optional[str]:
        """
        SSL/TLS versions that the cipher suite can be used with. Valid values: `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class AccessproxysshclientcertCertExtension(dict):
    def __init__(__self__, *,
                 critical: Optional[str] = None,
                 data: Optional[str] = None,
                 name: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str critical: Critical option. Valid values: `no`, `yes`.
        :param str data: Data of certificate extension.
        :param str name: Name of certificate extension.
        :param str type: Type of certificate extension. Valid values: `fixed`, `user`.
        """
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def critical(self) -> Optional[str]:
        """
        Critical option. Valid values: `no`, `yes`.
        """
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def data(self) -> Optional[str]:
        """
        Data of certificate extension.
        """
        return pulumi.get(self, "data")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of certificate extension.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of certificate extension. Valid values: `fixed`, `user`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class Address6List(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None):
        """
        :param str ip: IP.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IP.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class Address6Macaddr(dict):
    def __init__(__self__, *,
                 macaddr: Optional[str] = None):
        """
        :param str macaddr: MAC address ranges <start>[-<end>] separated by space.
        """
        if macaddr is not None:
            pulumi.set(__self__, "macaddr", macaddr)

    @property
    @pulumi.getter
    def macaddr(self) -> Optional[str]:
        """
        MAC address ranges <start>[-<end>] separated by space.
        """
        return pulumi.get(self, "macaddr")


@pulumi.output_type
class Address6SubnetSegment(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: Name.
        :param str type: Subnet segment type. Valid values: `any`, `specific`.
        :param str value: Subnet segment value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Subnet segment type. Valid values: `any`, `specific`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Subnet segment value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class Address6Tagging(dict):
    def __init__(__self__, *,
                 category: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.Address6TaggingTag']] = None):
        """
        :param str category: Tag category.
        :param str name: Tagging entry name.
        :param Sequence['Address6TaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tagging entry name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.Address6TaggingTag']]:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class Address6TaggingTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Tag name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tag name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Address6templateSubnetSegment(dict):
    def __init__(__self__, *,
                 bits: Optional[int] = None,
                 exclusive: Optional[str] = None,
                 id: Optional[int] = None,
                 name: Optional[str] = None,
                 values: Optional[Sequence['outputs.Address6templateSubnetSegmentValue']] = None):
        """
        :param int bits: Number of bits.
        :param str exclusive: Enable/disable exclusive value. Valid values: `enable`, `disable`.
        :param int id: Subnet segment ID.
        :param str name: Subnet segment name.
        :param Sequence['Address6templateSubnetSegmentValueArgs'] values: Subnet segment values. The structure of `values` block is documented below.
        """
        if bits is not None:
            pulumi.set(__self__, "bits", bits)
        if exclusive is not None:
            pulumi.set(__self__, "exclusive", exclusive)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def bits(self) -> Optional[int]:
        """
        Number of bits.
        """
        return pulumi.get(self, "bits")

    @property
    @pulumi.getter
    def exclusive(self) -> Optional[str]:
        """
        Enable/disable exclusive value. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "exclusive")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Subnet segment ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Subnet segment name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence['outputs.Address6templateSubnetSegmentValue']]:
        """
        Subnet segment values. The structure of `values` block is documented below.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class Address6templateSubnetSegmentValue(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str name: Subnet segment value name.
        :param str value: Subnet segment value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Subnet segment value name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Subnet segment value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AddressFssoGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: FSSO group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        FSSO group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AddressList(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None):
        """
        :param str ip: IP.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IP.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class AddressMacaddr(dict):
    def __init__(__self__, *,
                 macaddr: Optional[str] = None):
        """
        :param str macaddr: MAC address ranges <start>[-<end>] separated by space.
        """
        if macaddr is not None:
            pulumi.set(__self__, "macaddr", macaddr)

    @property
    @pulumi.getter
    def macaddr(self) -> Optional[str]:
        """
        MAC address ranges <start>[-<end>] separated by space.
        """
        return pulumi.get(self, "macaddr")


@pulumi.output_type
class AddressTagging(dict):
    def __init__(__self__, *,
                 category: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.AddressTaggingTag']] = None):
        """
        :param str category: Tag category.
        :param str name: Tagging entry name.
        :param Sequence['AddressTaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tagging entry name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.AddressTaggingTag']]:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AddressTaggingTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Tag name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tag name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Addrgrp6ExcludeMember(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address6 name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address6 name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Addrgrp6Member(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address6/addrgrp6 name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address6/addrgrp6 name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Addrgrp6Tagging(dict):
    def __init__(__self__, *,
                 category: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.Addrgrp6TaggingTag']] = None):
        """
        :param str category: Tag category.
        :param str name: Tagging entry name.
        :param Sequence['Addrgrp6TaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tagging entry name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.Addrgrp6TaggingTag']]:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class Addrgrp6TaggingTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Tag name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tag name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AddrgrpExcludeMember(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AddrgrpMember(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AddrgrpTagging(dict):
    def __init__(__self__, *,
                 category: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.AddrgrpTaggingTag']] = None):
        """
        :param str category: Tag category.
        :param str name: Tagging entry name.
        :param Sequence['AddrgrpTaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tagging entry name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.AddrgrpTaggingTag']]:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class AddrgrpTaggingTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Tag name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tag name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AuthportalGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CentralsnatmapDstAddr6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CentralsnatmapDstAddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CentralsnatmapDstintf(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CentralsnatmapNatIppool6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CentralsnatmapNatIppool(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: IPv6 pool name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        IPv6 pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CentralsnatmapOrigAddr6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CentralsnatmapOrigAddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CentralsnatmapSortStatePolicyList(dict):
    def __init__(__self__, *,
                 policyid: Optional[str] = None):
        if policyid is not None:
            pulumi.set(__self__, "policyid", policyid)

    @property
    @pulumi.getter
    def policyid(self) -> Optional[str]:
        return pulumi.get(self, "policyid")


@pulumi.output_type
class CentralsnatmapSrcintf(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CountryRegion(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Region ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Region ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DecryptedtrafficmirrorInterface(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Decrypted traffic mirror interface.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Decrypted traffic mirror interface.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DoSpolicy6Anomaly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "quarantineExpiry":
            suggest = "quarantine_expiry"
        elif key == "quarantineLog":
            suggest = "quarantine_log"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DoSpolicy6Anomaly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DoSpolicy6Anomaly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DoSpolicy6Anomaly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 log: Optional[str] = None,
                 name: Optional[str] = None,
                 quarantine: Optional[str] = None,
                 quarantine_expiry: Optional[str] = None,
                 quarantine_log: Optional[str] = None,
                 status: Optional[str] = None,
                 threshold: Optional[int] = None,
                 thresholddefault: Optional[int] = None):
        """
        :param str action: Action taken when the threshold is reached.
        :param str log: Enable/disable anomaly logging. Valid values: `enable`, `disable`.
        :param str name: Anomaly name.
        :param str quarantine: Quarantine method. Valid values: `none`, `attacker`.
        :param str quarantine_expiry: Duration of quarantine. (Format ###d##h##m, minimum 1m, maximum 364d23h59m, default = 5m). Requires quarantine set to attacker.
        :param str quarantine_log: Enable/disable quarantine logging. Valid values: `disable`, `enable`.
        :param str status: Enable/disable this anomaly. Valid values: `disable`, `enable`.
        :param int threshold: Anomaly threshold. Number of detected instances that triggers the anomaly action. On FortiOS versions 6.2.0-6.4.2, 7.0.0-7.0.5, 7.2.0: packets per minute. On FortiOS versions 6.4.10-6.4.14, 7.0.6-7.0.13, >= 7.2.1: packets per second or concurrent session number.
        :param int thresholddefault: Number of detected instances which triggers action (1 - 2147483647, default = 1000). Note that each anomaly has a different threshold value assigned to it. On FortiOS versions 6.2.0-6.4.2, 7.0.0-7.0.5, 7.2.0: packets per minute. On FortiOS versions 6.4.10-6.4.14, 7.0.6-7.0.13, >= 7.2.1: packets per second or concurrent session number.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if quarantine is not None:
            pulumi.set(__self__, "quarantine", quarantine)
        if quarantine_expiry is not None:
            pulumi.set(__self__, "quarantine_expiry", quarantine_expiry)
        if quarantine_log is not None:
            pulumi.set(__self__, "quarantine_log", quarantine_log)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if thresholddefault is not None:
            pulumi.set(__self__, "thresholddefault", thresholddefault)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action taken when the threshold is reached.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def log(self) -> Optional[str]:
        """
        Enable/disable anomaly logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Anomaly name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def quarantine(self) -> Optional[str]:
        """
        Quarantine method. Valid values: `none`, `attacker`.
        """
        return pulumi.get(self, "quarantine")

    @property
    @pulumi.getter(name="quarantineExpiry")
    def quarantine_expiry(self) -> Optional[str]:
        """
        Duration of quarantine. (Format ###d##h##m, minimum 1m, maximum 364d23h59m, default = 5m). Requires quarantine set to attacker.
        """
        return pulumi.get(self, "quarantine_expiry")

    @property
    @pulumi.getter(name="quarantineLog")
    def quarantine_log(self) -> Optional[str]:
        """
        Enable/disable quarantine logging. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "quarantine_log")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable this anomaly. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        Anomaly threshold. Number of detected instances that triggers the anomaly action. On FortiOS versions 6.2.0-6.4.2, 7.0.0-7.0.5, 7.2.0: packets per minute. On FortiOS versions 6.4.10-6.4.14, 7.0.6-7.0.13, >= 7.2.1: packets per second or concurrent session number.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def thresholddefault(self) -> Optional[int]:
        """
        Number of detected instances which triggers action (1 - 2147483647, default = 1000). Note that each anomaly has a different threshold value assigned to it. On FortiOS versions 6.2.0-6.4.2, 7.0.0-7.0.5, 7.2.0: packets per minute. On FortiOS versions 6.4.10-6.4.14, 7.0.6-7.0.13, >= 7.2.1: packets per second or concurrent session number.
        """
        return pulumi.get(self, "thresholddefault")


@pulumi.output_type
class DoSpolicy6Dstaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DoSpolicy6Service(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DoSpolicy6Srcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DoSpolicyAnomaly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "quarantineExpiry":
            suggest = "quarantine_expiry"
        elif key == "quarantineLog":
            suggest = "quarantine_log"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DoSpolicyAnomaly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DoSpolicyAnomaly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DoSpolicyAnomaly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 log: Optional[str] = None,
                 name: Optional[str] = None,
                 quarantine: Optional[str] = None,
                 quarantine_expiry: Optional[str] = None,
                 quarantine_log: Optional[str] = None,
                 status: Optional[str] = None,
                 threshold: Optional[int] = None,
                 thresholddefault: Optional[int] = None):
        """
        :param str action: Action taken when the threshold is reached.
        :param str log: Enable/disable anomaly logging. Valid values: `enable`, `disable`.
        :param str name: Anomaly name.
        :param str quarantine: Quarantine method. Valid values: `none`, `attacker`.
        :param str quarantine_expiry: Duration of quarantine. (Format ###d##h##m, minimum 1m, maximum 364d23h59m, default = 5m). Requires quarantine set to attacker.
        :param str quarantine_log: Enable/disable quarantine logging. Valid values: `disable`, `enable`.
        :param str status: Enable/disable this anomaly. Valid values: `disable`, `enable`.
        :param int threshold: Anomaly threshold. Number of detected instances that triggers the anomaly action. On FortiOS versions 6.2.0-6.4.2, 7.0.0-7.0.5, 7.2.0: packets per minute. On FortiOS versions 6.4.10-6.4.14, 7.0.6-7.0.13, >= 7.2.1: packets per second or concurrent session number.
        :param int thresholddefault: Number of detected instances which triggers action (1 - 2147483647, default = 1000). Note that each anomaly has a different threshold value assigned to it. On FortiOS versions 6.2.0-6.4.2, 7.0.0-7.0.5, 7.2.0: packets per minute. On FortiOS versions 6.4.10-6.4.14, 7.0.6-7.0.13, >= 7.2.1: packets per second or concurrent session number.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if quarantine is not None:
            pulumi.set(__self__, "quarantine", quarantine)
        if quarantine_expiry is not None:
            pulumi.set(__self__, "quarantine_expiry", quarantine_expiry)
        if quarantine_log is not None:
            pulumi.set(__self__, "quarantine_log", quarantine_log)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if thresholddefault is not None:
            pulumi.set(__self__, "thresholddefault", thresholddefault)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action taken when the threshold is reached.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def log(self) -> Optional[str]:
        """
        Enable/disable anomaly logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Anomaly name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def quarantine(self) -> Optional[str]:
        """
        Quarantine method. Valid values: `none`, `attacker`.
        """
        return pulumi.get(self, "quarantine")

    @property
    @pulumi.getter(name="quarantineExpiry")
    def quarantine_expiry(self) -> Optional[str]:
        """
        Duration of quarantine. (Format ###d##h##m, minimum 1m, maximum 364d23h59m, default = 5m). Requires quarantine set to attacker.
        """
        return pulumi.get(self, "quarantine_expiry")

    @property
    @pulumi.getter(name="quarantineLog")
    def quarantine_log(self) -> Optional[str]:
        """
        Enable/disable quarantine logging. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "quarantine_log")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable this anomaly. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        Anomaly threshold. Number of detected instances that triggers the anomaly action. On FortiOS versions 6.2.0-6.4.2, 7.0.0-7.0.5, 7.2.0: packets per minute. On FortiOS versions 6.4.10-6.4.14, 7.0.6-7.0.13, >= 7.2.1: packets per second or concurrent session number.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def thresholddefault(self) -> Optional[int]:
        """
        Number of detected instances which triggers action (1 - 2147483647, default = 1000). Note that each anomaly has a different threshold value assigned to it. On FortiOS versions 6.2.0-6.4.2, 7.0.0-7.0.5, 7.2.0: packets per minute. On FortiOS versions 6.4.10-6.4.14, 7.0.6-7.0.13, >= 7.2.1: packets per second or concurrent session number.
        """
        return pulumi.get(self, "thresholddefault")


@pulumi.output_type
class DoSpolicyDstaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DoSpolicyService(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class DoSpolicySrcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class IdentitybasedrouteRule(dict):
    def __init__(__self__, *,
                 device: Optional[str] = None,
                 gateway: Optional[str] = None,
                 groups: Optional[Sequence['outputs.IdentitybasedrouteRuleGroup']] = None,
                 id: Optional[int] = None):
        """
        :param str device: Outgoing interface for the rule.
        :param str gateway: IPv4 address of the gateway (Format: xxx.xxx.xxx.xxx , Default: 0.0.0.0).
        :param Sequence['IdentitybasedrouteRuleGroupArgs'] groups: Select one or more group(s) from available groups that are allowed to use this route. Separate group names with a space. The structure of `groups` block is documented below.
        :param int id: Rule ID.
        """
        if device is not None:
            pulumi.set(__self__, "device", device)
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if groups is not None:
            pulumi.set(__self__, "groups", groups)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def device(self) -> Optional[str]:
        """
        Outgoing interface for the rule.
        """
        return pulumi.get(self, "device")

    @property
    @pulumi.getter
    def gateway(self) -> Optional[str]:
        """
        IPv4 address of the gateway (Format: xxx.xxx.xxx.xxx , Default: 0.0.0.0).
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def groups(self) -> Optional[Sequence['outputs.IdentitybasedrouteRuleGroup']]:
        """
        Select one or more group(s) from available groups that are allowed to use this route. Separate group names with a space. The structure of `groups` block is documented below.
        """
        return pulumi.get(self, "groups")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Rule ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class IdentitybasedrouteRuleGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Interfacepolicy6Dstaddr6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Interfacepolicy6Service6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Interfacepolicy6Srcaddr6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class InterfacepolicyDstaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class InterfacepolicyService(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class InterfacepolicySrcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class InternetserviceadditionEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addrMode":
            suggest = "addr_mode"
        elif key == "portRanges":
            suggest = "port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetserviceadditionEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetserviceadditionEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetserviceadditionEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addr_mode: Optional[str] = None,
                 id: Optional[int] = None,
                 port_ranges: Optional[Sequence['outputs.InternetserviceadditionEntryPortRange']] = None,
                 protocol: Optional[int] = None):
        """
        :param str addr_mode: Address mode (IPv4 or IPv6) Valid values: `ipv4`, `ipv6`.
        :param int id: Entry ID(1-255).
        :param Sequence['InternetserviceadditionEntryPortRangeArgs'] port_ranges: Port ranges in the custom entry. The structure of `port_range` block is documented below.
        :param int protocol: Integer value for the protocol type as defined by IANA (0 - 255).
        """
        if addr_mode is not None:
            pulumi.set(__self__, "addr_mode", addr_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="addrMode")
    def addr_mode(self) -> Optional[str]:
        """
        Address mode (IPv4 or IPv6) Valid values: `ipv4`, `ipv6`.
        """
        return pulumi.get(self, "addr_mode")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Entry ID(1-255).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.InternetserviceadditionEntryPortRange']]:
        """
        Port ranges in the custom entry. The structure of `port_range` block is documented below.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[int]:
        """
        Integer value for the protocol type as defined by IANA (0 - 255).
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class InternetserviceadditionEntryPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endPort":
            suggest = "end_port"
        elif key == "startPort":
            suggest = "start_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetserviceadditionEntryPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetserviceadditionEntryPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetserviceadditionEntryPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_port: Optional[int] = None,
                 id: Optional[int] = None,
                 start_port: Optional[int] = None):
        """
        :param int end_port: Integer value for ending TCP/UDP/SCTP destination port in range (1 to 65535).
        :param int id: Custom entry port range ID.
        :param int start_port: Integer value for starting TCP/UDP/SCTP destination port in range (1 to 65535).
        """
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[int]:
        """
        Integer value for ending TCP/UDP/SCTP destination port in range (1 to 65535).
        """
        return pulumi.get(self, "end_port")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Custom entry port range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[int]:
        """
        Integer value for starting TCP/UDP/SCTP destination port in range (1 to 65535).
        """
        return pulumi.get(self, "start_port")


@pulumi.output_type
class InternetservicecustomEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addrMode":
            suggest = "addr_mode"
        elif key == "portRanges":
            suggest = "port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetservicecustomEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetservicecustomEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetservicecustomEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addr_mode: Optional[str] = None,
                 dst6s: Optional[Sequence['outputs.InternetservicecustomEntryDst6']] = None,
                 dsts: Optional[Sequence['outputs.InternetservicecustomEntryDst']] = None,
                 id: Optional[int] = None,
                 port_ranges: Optional[Sequence['outputs.InternetservicecustomEntryPortRange']] = None,
                 protocol: Optional[int] = None):
        """
        :param str addr_mode: Address mode (IPv4 or IPv6) Valid values: `ipv4`, `ipv6`.
        :param Sequence['InternetservicecustomEntryDst6Args'] dst6s: Destination address6 or address6 group name. The structure of `dst6` block is documented below.
        :param Sequence['InternetservicecustomEntryDstArgs'] dsts: Destination address or address group name. The structure of `dst` block is documented below.
        :param int id: Entry ID(1-255).
        :param Sequence['InternetservicecustomEntryPortRangeArgs'] port_ranges: Port ranges in the custom entry. The structure of `port_range` block is documented below.
        :param int protocol: Integer value for the protocol type as defined by IANA (0 - 255).
        """
        if addr_mode is not None:
            pulumi.set(__self__, "addr_mode", addr_mode)
        if dst6s is not None:
            pulumi.set(__self__, "dst6s", dst6s)
        if dsts is not None:
            pulumi.set(__self__, "dsts", dsts)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="addrMode")
    def addr_mode(self) -> Optional[str]:
        """
        Address mode (IPv4 or IPv6) Valid values: `ipv4`, `ipv6`.
        """
        return pulumi.get(self, "addr_mode")

    @property
    @pulumi.getter
    def dst6s(self) -> Optional[Sequence['outputs.InternetservicecustomEntryDst6']]:
        """
        Destination address6 or address6 group name. The structure of `dst6` block is documented below.
        """
        return pulumi.get(self, "dst6s")

    @property
    @pulumi.getter
    def dsts(self) -> Optional[Sequence['outputs.InternetservicecustomEntryDst']]:
        """
        Destination address or address group name. The structure of `dst` block is documented below.
        """
        return pulumi.get(self, "dsts")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Entry ID(1-255).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.InternetservicecustomEntryPortRange']]:
        """
        Port ranges in the custom entry. The structure of `port_range` block is documented below.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[int]:
        """
        Integer value for the protocol type as defined by IANA (0 - 255).
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class InternetservicecustomEntryDst6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class InternetservicecustomEntryDst(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Select the destination address6 or address group object from available options.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Select the destination address6 or address group object from available options.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class InternetservicecustomEntryPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endPort":
            suggest = "end_port"
        elif key == "startPort":
            suggest = "start_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetservicecustomEntryPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetservicecustomEntryPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetservicecustomEntryPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_port: Optional[int] = None,
                 id: Optional[int] = None,
                 start_port: Optional[int] = None):
        """
        :param int end_port: Integer value for ending TCP/UDP/SCTP destination port in range (1 to 65535).
        :param int id: Custom entry port range ID.
        :param int start_port: Integer value for starting TCP/UDP/SCTP destination port in range (1 to 65535).
        """
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[int]:
        """
        Integer value for ending TCP/UDP/SCTP destination port in range (1 to 65535).
        """
        return pulumi.get(self, "end_port")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Custom entry port range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[int]:
        """
        Integer value for starting TCP/UDP/SCTP destination port in range (1 to 65535).
        """
        return pulumi.get(self, "start_port")


@pulumi.output_type
class InternetservicecustomgroupMember(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Group member name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Group member name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class InternetservicedefinitionEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "categoryId":
            suggest = "category_id"
        elif key == "portRanges":
            suggest = "port_ranges"
        elif key == "seqNum":
            suggest = "seq_num"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetservicedefinitionEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetservicedefinitionEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetservicedefinitionEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category_id: Optional[int] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 port_ranges: Optional[Sequence['outputs.InternetservicedefinitionEntryPortRange']] = None,
                 protocol: Optional[int] = None,
                 seq_num: Optional[int] = None):
        """
        :param int category_id: Internet Service category ID.
        :param str name: Internet Service name.
        :param int port: Integer value for ending TCP/UDP/SCTP destination port in range (0 to 65535). 0 means undefined.
        :param Sequence['InternetservicedefinitionEntryPortRangeArgs'] port_ranges: Port ranges in the definition entry. The structure of `port_range` block is documented below.
        :param int protocol: Integer value for the protocol type as defined by IANA (0 - 255).
        :param int seq_num: Entry sequence number.
        """
        if category_id is not None:
            pulumi.set(__self__, "category_id", category_id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if seq_num is not None:
            pulumi.set(__self__, "seq_num", seq_num)

    @property
    @pulumi.getter(name="categoryId")
    def category_id(self) -> Optional[int]:
        """
        Internet Service category ID.
        """
        return pulumi.get(self, "category_id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Integer value for ending TCP/UDP/SCTP destination port in range (0 to 65535). 0 means undefined.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.InternetservicedefinitionEntryPortRange']]:
        """
        Port ranges in the definition entry. The structure of `port_range` block is documented below.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[int]:
        """
        Integer value for the protocol type as defined by IANA (0 - 255).
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="seqNum")
    def seq_num(self) -> Optional[int]:
        """
        Entry sequence number.
        """
        return pulumi.get(self, "seq_num")


@pulumi.output_type
class InternetservicedefinitionEntryPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endPort":
            suggest = "end_port"
        elif key == "startPort":
            suggest = "start_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetservicedefinitionEntryPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetservicedefinitionEntryPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetservicedefinitionEntryPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_port: Optional[int] = None,
                 id: Optional[int] = None,
                 start_port: Optional[int] = None):
        """
        :param int end_port: Ending TCP/UDP/SCTP destination port (1 to 65535).
        :param int id: Custom entry port range ID.
        :param int start_port: Starting TCP/UDP/SCTP destination port (1 to 65535).
        """
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[int]:
        """
        Ending TCP/UDP/SCTP destination port (1 to 65535).
        """
        return pulumi.get(self, "end_port")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Custom entry port range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[int]:
        """
        Starting TCP/UDP/SCTP destination port (1 to 65535).
        """
        return pulumi.get(self, "start_port")


@pulumi.output_type
class InternetserviceextensionDisableEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addrMode":
            suggest = "addr_mode"
        elif key == "ip6Ranges":
            suggest = "ip6_ranges"
        elif key == "ipRanges":
            suggest = "ip_ranges"
        elif key == "portRanges":
            suggest = "port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetserviceextensionDisableEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetserviceextensionDisableEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetserviceextensionDisableEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addr_mode: Optional[str] = None,
                 id: Optional[int] = None,
                 ip6_ranges: Optional[Sequence['outputs.InternetserviceextensionDisableEntryIp6Range']] = None,
                 ip_ranges: Optional[Sequence['outputs.InternetserviceextensionDisableEntryIpRange']] = None,
                 port: Optional[int] = None,
                 port_ranges: Optional[Sequence['outputs.InternetserviceextensionDisableEntryPortRange']] = None,
                 protocol: Optional[int] = None):
        """
        :param str addr_mode: Address mode (IPv4 or IPv6) Valid values: `ipv4`, `ipv6`.
        :param int id: Disable entry ID.
        :param Sequence['InternetserviceextensionDisableEntryIp6RangeArgs'] ip6_ranges: IPv6 ranges in the disable entry. The structure of `ip6_range` block is documented below.
        :param Sequence['InternetserviceextensionDisableEntryIpRangeArgs'] ip_ranges: IP ranges in the disable entry. The structure of `ip_range` block is documented below.
        :param int port: Integer value for the TCP/IP port (0 - 65535).
        :param Sequence['InternetserviceextensionDisableEntryPortRangeArgs'] port_ranges: Port ranges in the disable entry. The structure of `port_range` block is documented below.
        :param int protocol: Integer value for the protocol type as defined by IANA (0 - 255).
        """
        if addr_mode is not None:
            pulumi.set(__self__, "addr_mode", addr_mode)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip6_ranges is not None:
            pulumi.set(__self__, "ip6_ranges", ip6_ranges)
        if ip_ranges is not None:
            pulumi.set(__self__, "ip_ranges", ip_ranges)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="addrMode")
    def addr_mode(self) -> Optional[str]:
        """
        Address mode (IPv4 or IPv6) Valid values: `ipv4`, `ipv6`.
        """
        return pulumi.get(self, "addr_mode")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Disable entry ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ip6Ranges")
    def ip6_ranges(self) -> Optional[Sequence['outputs.InternetserviceextensionDisableEntryIp6Range']]:
        """
        IPv6 ranges in the disable entry. The structure of `ip6_range` block is documented below.
        """
        return pulumi.get(self, "ip6_ranges")

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Optional[Sequence['outputs.InternetserviceextensionDisableEntryIpRange']]:
        """
        IP ranges in the disable entry. The structure of `ip_range` block is documented below.
        """
        return pulumi.get(self, "ip_ranges")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Integer value for the TCP/IP port (0 - 65535).
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.InternetserviceextensionDisableEntryPortRange']]:
        """
        Port ranges in the disable entry. The structure of `port_range` block is documented below.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[int]:
        """
        Integer value for the protocol type as defined by IANA (0 - 255).
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class InternetserviceextensionDisableEntryIp6Range(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endIp6":
            suggest = "end_ip6"
        elif key == "startIp6":
            suggest = "start_ip6"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetserviceextensionDisableEntryIp6Range. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetserviceextensionDisableEntryIp6Range.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetserviceextensionDisableEntryIp6Range.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_ip6: Optional[str] = None,
                 id: Optional[int] = None,
                 start_ip6: Optional[str] = None):
        """
        :param str end_ip6: End IPv6 address.
        :param int id: Disable entry ID.
        :param str start_ip6: Start IPv6 address.
        """
        if end_ip6 is not None:
            pulumi.set(__self__, "end_ip6", end_ip6)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if start_ip6 is not None:
            pulumi.set(__self__, "start_ip6", start_ip6)

    @property
    @pulumi.getter(name="endIp6")
    def end_ip6(self) -> Optional[str]:
        """
        End IPv6 address.
        """
        return pulumi.get(self, "end_ip6")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Disable entry ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startIp6")
    def start_ip6(self) -> Optional[str]:
        """
        Start IPv6 address.
        """
        return pulumi.get(self, "start_ip6")


@pulumi.output_type
class InternetserviceextensionDisableEntryIpRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endIp":
            suggest = "end_ip"
        elif key == "startIp":
            suggest = "start_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetserviceextensionDisableEntryIpRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetserviceextensionDisableEntryIpRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetserviceextensionDisableEntryIpRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_ip: Optional[str] = None,
                 id: Optional[int] = None,
                 start_ip: Optional[str] = None):
        """
        :param str end_ip: End IP address.
               
               The `ip6_range` block supports:
        :param int id: Disable entry range ID.
        :param str start_ip: Start IP address.
        """
        if end_ip is not None:
            pulumi.set(__self__, "end_ip", end_ip)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if start_ip is not None:
            pulumi.set(__self__, "start_ip", start_ip)

    @property
    @pulumi.getter(name="endIp")
    def end_ip(self) -> Optional[str]:
        """
        End IP address.

        The `ip6_range` block supports:
        """
        return pulumi.get(self, "end_ip")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Disable entry range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startIp")
    def start_ip(self) -> Optional[str]:
        """
        Start IP address.
        """
        return pulumi.get(self, "start_ip")


@pulumi.output_type
class InternetserviceextensionDisableEntryPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endPort":
            suggest = "end_port"
        elif key == "startPort":
            suggest = "start_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetserviceextensionDisableEntryPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetserviceextensionDisableEntryPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetserviceextensionDisableEntryPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_port: Optional[int] = None,
                 id: Optional[int] = None,
                 start_port: Optional[int] = None):
        """
        :param int end_port: Ending TCP/UDP/SCTP destination port (1 to 65535).
        :param int id: Custom entry port range ID.
        :param int start_port: Starting TCP/UDP/SCTP destination port (1 to 65535).
        """
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[int]:
        """
        Ending TCP/UDP/SCTP destination port (1 to 65535).
        """
        return pulumi.get(self, "end_port")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Custom entry port range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[int]:
        """
        Starting TCP/UDP/SCTP destination port (1 to 65535).
        """
        return pulumi.get(self, "start_port")


@pulumi.output_type
class InternetserviceextensionEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addrMode":
            suggest = "addr_mode"
        elif key == "portRanges":
            suggest = "port_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetserviceextensionEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetserviceextensionEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetserviceextensionEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addr_mode: Optional[str] = None,
                 dst6s: Optional[Sequence['outputs.InternetserviceextensionEntryDst6']] = None,
                 dsts: Optional[Sequence['outputs.InternetserviceextensionEntryDst']] = None,
                 id: Optional[int] = None,
                 port_ranges: Optional[Sequence['outputs.InternetserviceextensionEntryPortRange']] = None,
                 protocol: Optional[int] = None):
        """
        :param str addr_mode: Address mode (IPv4 or IPv6) Valid values: `ipv4`, `ipv6`.
        :param Sequence['InternetserviceextensionEntryDst6Args'] dst6s: Destination address6 or address6 group name. The structure of `dst6` block is documented below.
        :param Sequence['InternetserviceextensionEntryDstArgs'] dsts: Destination address or address group name. The structure of `dst` block is documented below.
        :param int id: Entry ID(1-255).
        :param Sequence['InternetserviceextensionEntryPortRangeArgs'] port_ranges: Port ranges in the custom entry. The structure of `port_range` block is documented below.
        :param int protocol: Integer value for the protocol type as defined by IANA (0 - 255).
        """
        if addr_mode is not None:
            pulumi.set(__self__, "addr_mode", addr_mode)
        if dst6s is not None:
            pulumi.set(__self__, "dst6s", dst6s)
        if dsts is not None:
            pulumi.set(__self__, "dsts", dsts)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if port_ranges is not None:
            pulumi.set(__self__, "port_ranges", port_ranges)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="addrMode")
    def addr_mode(self) -> Optional[str]:
        """
        Address mode (IPv4 or IPv6) Valid values: `ipv4`, `ipv6`.
        """
        return pulumi.get(self, "addr_mode")

    @property
    @pulumi.getter
    def dst6s(self) -> Optional[Sequence['outputs.InternetserviceextensionEntryDst6']]:
        """
        Destination address6 or address6 group name. The structure of `dst6` block is documented below.
        """
        return pulumi.get(self, "dst6s")

    @property
    @pulumi.getter
    def dsts(self) -> Optional[Sequence['outputs.InternetserviceextensionEntryDst']]:
        """
        Destination address or address group name. The structure of `dst` block is documented below.
        """
        return pulumi.get(self, "dsts")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Entry ID(1-255).
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Optional[Sequence['outputs.InternetserviceextensionEntryPortRange']]:
        """
        Port ranges in the custom entry. The structure of `port_range` block is documented below.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[int]:
        """
        Integer value for the protocol type as defined by IANA (0 - 255).
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class InternetserviceextensionEntryDst6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Select the destination address6 or address group object from available options.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Select the destination address6 or address group object from available options.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class InternetserviceextensionEntryDst(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Select the destination address6 or address group object from available options.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Select the destination address6 or address group object from available options.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class InternetserviceextensionEntryPortRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endPort":
            suggest = "end_port"
        elif key == "startPort":
            suggest = "start_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in InternetserviceextensionEntryPortRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        InternetserviceextensionEntryPortRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        InternetserviceextensionEntryPortRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_port: Optional[int] = None,
                 id: Optional[int] = None,
                 start_port: Optional[int] = None):
        """
        :param int end_port: Ending TCP/UDP/SCTP destination port (1 to 65535).
        :param int id: Custom entry port range ID.
        :param int start_port: Starting TCP/UDP/SCTP destination port (1 to 65535).
        """
        if end_port is not None:
            pulumi.set(__self__, "end_port", end_port)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if start_port is not None:
            pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> Optional[int]:
        """
        Ending TCP/UDP/SCTP destination port (1 to 65535).
        """
        return pulumi.get(self, "end_port")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Custom entry port range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> Optional[int]:
        """
        Starting TCP/UDP/SCTP destination port (1 to 65535).
        """
        return pulumi.get(self, "start_port")


@pulumi.output_type
class InternetservicegroupMember(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None,
                 name: Optional[str] = None):
        """
        :param int id: Internet Service ID.
        :param str name: Internet Service name.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Internet Service ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class InternetservicesubappSubApp(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Subapp ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Subapp ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class Localinpolicy6Dstaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Localinpolicy6Service(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Localinpolicy6Srcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LocalinpolicyDstaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LocalinpolicyService(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LocalinpolicySrcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Multicastaddress6Tagging(dict):
    def __init__(__self__, *,
                 category: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.Multicastaddress6TaggingTag']] = None):
        """
        :param str category: Tag category.
        :param str name: Tagging entry name.
        :param Sequence['Multicastaddress6TaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tagging entry name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.Multicastaddress6TaggingTag']]:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class Multicastaddress6TaggingTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Tag name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tag name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MulticastaddressTagging(dict):
    def __init__(__self__, *,
                 category: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.MulticastaddressTaggingTag']] = None):
        """
        :param str category: Tag category.
        :param str name: Tagging entry name.
        :param Sequence['MulticastaddressTaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tagging entry name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.MulticastaddressTaggingTag']]:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class MulticastaddressTaggingTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Tag name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tag name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Multicastpolicy6Dstaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Multicastpolicy6Srcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MulticastpolicyDstaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Destination address objects.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Destination address objects.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class MulticastpolicySrcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Source address objects.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Source address objects.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy46Dstaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy46Poolname(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: IP pool name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        IP pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy46Service(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy46Srcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy64Dstaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy64Poolname(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: IP pool name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        IP pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy64Service(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy64Srcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy6AppCategory(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Category IDs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Category IDs.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class Policy6AppGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Application group names.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Application group names.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy6Application(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Application IDs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Application IDs.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class Policy6CustomLogField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Policy6CustomLogField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Policy6CustomLogField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Policy6CustomLogField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: Optional[str] = None):
        """
        :param str field_id: Custom log field.
        """
        if field_id is not None:
            pulumi.set(__self__, "field_id", field_id)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> Optional[str]:
        """
        Custom log field.
        """
        return pulumi.get(self, "field_id")


@pulumi.output_type
class Policy6Device(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Device or group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Device or group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy6Dstaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy6Dstintf(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy6FssoGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Names of FSSO groups.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy6Group(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy6Poolname(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: IP pool name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        IP pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy6Service(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy6Srcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy6Srcintf(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy6SslMirrorIntf(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Policy6UrlCategory(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: URL category ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        URL category ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class Policy6User(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Names of individual users that can authenticate with this policy.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Names of individual users that can authenticate with this policy.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyAppCategory(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Category IDs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Category IDs.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PolicyAppGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Application group names.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Application group names.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyApplication(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Application IDs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Application IDs.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PolicyCustomLogField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldId":
            suggest = "field_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyCustomLogField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyCustomLogField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyCustomLogField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_id: Optional[str] = None):
        """
        :param str field_id: Custom log field.
        """
        if field_id is not None:
            pulumi.set(__self__, "field_id", field_id)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> Optional[str]:
        """
        Custom log field.
        """
        return pulumi.get(self, "field_id")


@pulumi.output_type
class PolicyDevice(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Device or group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Device or group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyDstaddr6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyDstaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyDstintf(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyFssoGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Names of FSSO groups.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetService6Custom(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetService6CustomGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetService6Group(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetService6Name(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetService6SrcCustom(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetService6SrcCustomGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetService6SrcGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetService6SrcName(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetServiceCustom(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Custom Internet Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetServiceCustomGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Custom Internet Service group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom Internet Service group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetServiceGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetServiceId(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Internet Service ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Internet Service ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PolicyInternetServiceName(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetServiceSrcCustom(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Custom Internet Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetServiceSrcCustomGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Custom Internet Service group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom Internet Service group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetServiceSrcGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyInternetServiceSrcId(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Internet Service ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Internet Service ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PolicyInternetServiceSrcName(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyNetworkServiceDynamic(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Dynamic Network Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Dynamic Network Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyNetworkServiceSrcDynamic(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Dynamic Network Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Dynamic Network Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyNtlmEnabledBrowser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "userAgentString":
            suggest = "user_agent_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PolicyNtlmEnabledBrowser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PolicyNtlmEnabledBrowser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PolicyNtlmEnabledBrowser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 user_agent_string: Optional[str] = None):
        """
        :param str user_agent_string: User agent string.
        """
        if user_agent_string is not None:
            pulumi.set(__self__, "user_agent_string", user_agent_string)

    @property
    @pulumi.getter(name="userAgentString")
    def user_agent_string(self) -> Optional[str]:
        """
        User agent string.
        """
        return pulumi.get(self, "user_agent_string")


@pulumi.output_type
class PolicyPcpPoolname(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: PCP pool name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        PCP pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyPoolname6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyPoolname(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: IPv6 pool name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        IPv6 pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyRtpAddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyService(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Service and service group names.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Service and service group names.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicySgt(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Security group tag.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Security group tag.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PolicySortStatePolicyList(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 name: Optional[str] = None,
                 policyid: Optional[str] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if policyid is not None:
            pulumi.set(__self__, "policyid", policyid)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def policyid(self) -> Optional[str]:
        return pulumi.get(self, "policyid")


@pulumi.output_type
class PolicySrcVendorMac(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Vendor MAC ID.
               
               The `internet_service6_name` block supports:
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Vendor MAC ID.

        The `internet_service6_name` block supports:
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PolicySrcaddr6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicySrcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicySrcintf(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicySslMirrorIntf(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Mirror Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyUrlCategory(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: URL category ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        URL category ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class PolicyUser(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Names of individual users that can authenticate with this policy.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Names of individual users that can authenticate with this policy.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyZtnaEmsTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyZtnaEmsTagSecondary(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class PolicyZtnaGeoTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProfileprotocoloptionsCifs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "domainController":
            suggest = "domain_controller"
        elif key == "oversizeLimit":
            suggest = "oversize_limit"
        elif key == "scanBzip2":
            suggest = "scan_bzip2"
        elif key == "serverCredentialType":
            suggest = "server_credential_type"
        elif key == "serverKeytabs":
            suggest = "server_keytabs"
        elif key == "tcpWindowMaximum":
            suggest = "tcp_window_maximum"
        elif key == "tcpWindowMinimum":
            suggest = "tcp_window_minimum"
        elif key == "tcpWindowSize":
            suggest = "tcp_window_size"
        elif key == "tcpWindowType":
            suggest = "tcp_window_type"
        elif key == "uncompressedNestLimit":
            suggest = "uncompressed_nest_limit"
        elif key == "uncompressedOversizeLimit":
            suggest = "uncompressed_oversize_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileprotocoloptionsCifs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileprotocoloptionsCifs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileprotocoloptionsCifs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain_controller: Optional[str] = None,
                 options: Optional[str] = None,
                 oversize_limit: Optional[int] = None,
                 ports: Optional[int] = None,
                 scan_bzip2: Optional[str] = None,
                 server_credential_type: Optional[str] = None,
                 server_keytabs: Optional[Sequence['outputs.ProfileprotocoloptionsCifsServerKeytab']] = None,
                 status: Optional[str] = None,
                 tcp_window_maximum: Optional[int] = None,
                 tcp_window_minimum: Optional[int] = None,
                 tcp_window_size: Optional[int] = None,
                 tcp_window_type: Optional[str] = None,
                 uncompressed_nest_limit: Optional[int] = None,
                 uncompressed_oversize_limit: Optional[int] = None):
        """
        :param str domain_controller: Domain for which to decrypt CIFS traffic.
        :param str options: One or more options that can be applied to the session. Valid values: `oversize`.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (MB).
        :param int ports: Ports to scan for content (1 - 65535, default = 445).
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        :param str server_credential_type: CIFS server credential type. Valid values: `none`, `credential-replication`, `credential-keytab`.
        :param Sequence['ProfileprotocoloptionsCifsServerKeytabArgs'] server_keytabs: Server keytab. The structure of `server_keytab` block is documented below.
        :param str status: Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        :param int tcp_window_maximum: Maximum dynamic TCP window size.
        :param int tcp_window_minimum: Minimum dynamic TCP window size.
        :param int tcp_window_size: Set TCP static window size.
        :param str tcp_window_type: Specify type of TCP window to use for this protocol.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        if domain_controller is not None:
            pulumi.set(__self__, "domain_controller", domain_controller)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if oversize_limit is not None:
            pulumi.set(__self__, "oversize_limit", oversize_limit)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if scan_bzip2 is not None:
            pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        if server_credential_type is not None:
            pulumi.set(__self__, "server_credential_type", server_credential_type)
        if server_keytabs is not None:
            pulumi.set(__self__, "server_keytabs", server_keytabs)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tcp_window_maximum is not None:
            pulumi.set(__self__, "tcp_window_maximum", tcp_window_maximum)
        if tcp_window_minimum is not None:
            pulumi.set(__self__, "tcp_window_minimum", tcp_window_minimum)
        if tcp_window_size is not None:
            pulumi.set(__self__, "tcp_window_size", tcp_window_size)
        if tcp_window_type is not None:
            pulumi.set(__self__, "tcp_window_type", tcp_window_type)
        if uncompressed_nest_limit is not None:
            pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        if uncompressed_oversize_limit is not None:
            pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter(name="domainController")
    def domain_controller(self) -> Optional[str]:
        """
        Domain for which to decrypt CIFS traffic.
        """
        return pulumi.get(self, "domain_controller")

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        One or more options that can be applied to the session. Valid values: `oversize`.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory file size that can be scanned (MB).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> Optional[int]:
        """
        Ports to scan for content (1 - 65535, default = 445).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> Optional[str]:
        """
        Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter(name="serverCredentialType")
    def server_credential_type(self) -> Optional[str]:
        """
        CIFS server credential type. Valid values: `none`, `credential-replication`, `credential-keytab`.
        """
        return pulumi.get(self, "server_credential_type")

    @property
    @pulumi.getter(name="serverKeytabs")
    def server_keytabs(self) -> Optional[Sequence['outputs.ProfileprotocoloptionsCifsServerKeytab']]:
        """
        Server keytab. The structure of `server_keytab` block is documented below.
        """
        return pulumi.get(self, "server_keytabs")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tcpWindowMaximum")
    def tcp_window_maximum(self) -> Optional[int]:
        """
        Maximum dynamic TCP window size.
        """
        return pulumi.get(self, "tcp_window_maximum")

    @property
    @pulumi.getter(name="tcpWindowMinimum")
    def tcp_window_minimum(self) -> Optional[int]:
        """
        Minimum dynamic TCP window size.
        """
        return pulumi.get(self, "tcp_window_minimum")

    @property
    @pulumi.getter(name="tcpWindowSize")
    def tcp_window_size(self) -> Optional[int]:
        """
        Set TCP static window size.
        """
        return pulumi.get(self, "tcp_window_size")

    @property
    @pulumi.getter(name="tcpWindowType")
    def tcp_window_type(self) -> Optional[str]:
        """
        Specify type of TCP window to use for this protocol.
        """
        return pulumi.get(self, "tcp_window_type")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> Optional[int]:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class ProfileprotocoloptionsCifsServerKeytab(dict):
    def __init__(__self__, *,
                 keytab: Optional[str] = None,
                 principal: Optional[str] = None):
        """
        :param str keytab: Base64 encoded keytab file containing credential of the server.
        :param str principal: Service principal.  For example, "host/cifsserver.example.com@example.com".
        """
        if keytab is not None:
            pulumi.set(__self__, "keytab", keytab)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter
    def keytab(self) -> Optional[str]:
        """
        Base64 encoded keytab file containing credential of the server.
        """
        return pulumi.get(self, "keytab")

    @property
    @pulumi.getter
    def principal(self) -> Optional[str]:
        """
        Service principal.  For example, "host/cifsserver.example.com@example.com".
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class ProfileprotocoloptionsDns(dict):
    def __init__(__self__, *,
                 ports: Optional[int] = None,
                 status: Optional[str] = None):
        """
        :param int ports: Ports to scan for content (1 - 65535, default = 53).
        :param str status: Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        """
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def ports(self) -> Optional[int]:
        """
        Ports to scan for content (1 - 65535, default = 53).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ProfileprotocoloptionsFtp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comfortAmount":
            suggest = "comfort_amount"
        elif key == "comfortInterval":
            suggest = "comfort_interval"
        elif key == "explicitFtpTls":
            suggest = "explicit_ftp_tls"
        elif key == "inspectAll":
            suggest = "inspect_all"
        elif key == "oversizeLimit":
            suggest = "oversize_limit"
        elif key == "scanBzip2":
            suggest = "scan_bzip2"
        elif key == "sslOffloaded":
            suggest = "ssl_offloaded"
        elif key == "streamBasedUncompressedLimit":
            suggest = "stream_based_uncompressed_limit"
        elif key == "tcpWindowMaximum":
            suggest = "tcp_window_maximum"
        elif key == "tcpWindowMinimum":
            suggest = "tcp_window_minimum"
        elif key == "tcpWindowSize":
            suggest = "tcp_window_size"
        elif key == "tcpWindowType":
            suggest = "tcp_window_type"
        elif key == "uncompressedNestLimit":
            suggest = "uncompressed_nest_limit"
        elif key == "uncompressedOversizeLimit":
            suggest = "uncompressed_oversize_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileprotocoloptionsFtp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileprotocoloptionsFtp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileprotocoloptionsFtp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comfort_amount: Optional[int] = None,
                 comfort_interval: Optional[int] = None,
                 explicit_ftp_tls: Optional[str] = None,
                 inspect_all: Optional[str] = None,
                 options: Optional[str] = None,
                 oversize_limit: Optional[int] = None,
                 ports: Optional[int] = None,
                 scan_bzip2: Optional[str] = None,
                 ssl_offloaded: Optional[str] = None,
                 status: Optional[str] = None,
                 stream_based_uncompressed_limit: Optional[int] = None,
                 tcp_window_maximum: Optional[int] = None,
                 tcp_window_minimum: Optional[int] = None,
                 tcp_window_size: Optional[int] = None,
                 tcp_window_type: Optional[str] = None,
                 uncompressed_nest_limit: Optional[int] = None,
                 uncompressed_oversize_limit: Optional[int] = None):
        """
        :param int comfort_amount: Number of bytes to send in each transmission for client comforting (bytes). On FortiOS versions 6.2.0: 1 - 10240 bytes, default = 1. On FortiOS versions 6.2.4-7.2.3: 1 - 65535 bytes, default = 1.
        :param int comfort_interval: Interval between successive transmissions of data for client comforting (seconds).
        :param str explicit_ftp_tls: Enable/disable FTP redirection for explicit FTPS. Valid values: `enable`, `disable`.
        :param str inspect_all: Enable/disable the inspection of all ports for the protocol. Valid values: `enable`, `disable`.
        :param str options: One or more options that can be applied to the session. Valid values: `clientcomfort`, `oversize`, `splice`, `bypass-rest-command`, `bypass-mode-command`.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (MB).
        :param int ports: Ports to scan for content (1 - 65535, default = 21).
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        :param str ssl_offloaded: SSL decryption and encryption performed by an external device. Valid values: `no`, `yes`.
        :param str status: Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        :param int stream_based_uncompressed_limit: Maximum stream-based uncompressed data size that will be scanned in megabytes. Stream-based uncompression used only under certain conditions (unlimited = 0, default = 0).
        :param int tcp_window_maximum: Maximum dynamic TCP window size.
        :param int tcp_window_minimum: Minimum dynamic TCP window size.
        :param int tcp_window_size: Set TCP static window size.
        :param str tcp_window_type: TCP window type to use for this protocol.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        if comfort_amount is not None:
            pulumi.set(__self__, "comfort_amount", comfort_amount)
        if comfort_interval is not None:
            pulumi.set(__self__, "comfort_interval", comfort_interval)
        if explicit_ftp_tls is not None:
            pulumi.set(__self__, "explicit_ftp_tls", explicit_ftp_tls)
        if inspect_all is not None:
            pulumi.set(__self__, "inspect_all", inspect_all)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if oversize_limit is not None:
            pulumi.set(__self__, "oversize_limit", oversize_limit)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if scan_bzip2 is not None:
            pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        if ssl_offloaded is not None:
            pulumi.set(__self__, "ssl_offloaded", ssl_offloaded)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if stream_based_uncompressed_limit is not None:
            pulumi.set(__self__, "stream_based_uncompressed_limit", stream_based_uncompressed_limit)
        if tcp_window_maximum is not None:
            pulumi.set(__self__, "tcp_window_maximum", tcp_window_maximum)
        if tcp_window_minimum is not None:
            pulumi.set(__self__, "tcp_window_minimum", tcp_window_minimum)
        if tcp_window_size is not None:
            pulumi.set(__self__, "tcp_window_size", tcp_window_size)
        if tcp_window_type is not None:
            pulumi.set(__self__, "tcp_window_type", tcp_window_type)
        if uncompressed_nest_limit is not None:
            pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        if uncompressed_oversize_limit is not None:
            pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter(name="comfortAmount")
    def comfort_amount(self) -> Optional[int]:
        """
        Number of bytes to send in each transmission for client comforting (bytes). On FortiOS versions 6.2.0: 1 - 10240 bytes, default = 1. On FortiOS versions 6.2.4-7.2.3: 1 - 65535 bytes, default = 1.
        """
        return pulumi.get(self, "comfort_amount")

    @property
    @pulumi.getter(name="comfortInterval")
    def comfort_interval(self) -> Optional[int]:
        """
        Interval between successive transmissions of data for client comforting (seconds).
        """
        return pulumi.get(self, "comfort_interval")

    @property
    @pulumi.getter(name="explicitFtpTls")
    def explicit_ftp_tls(self) -> Optional[str]:
        """
        Enable/disable FTP redirection for explicit FTPS. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "explicit_ftp_tls")

    @property
    @pulumi.getter(name="inspectAll")
    def inspect_all(self) -> Optional[str]:
        """
        Enable/disable the inspection of all ports for the protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "inspect_all")

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        One or more options that can be applied to the session. Valid values: `clientcomfort`, `oversize`, `splice`, `bypass-rest-command`, `bypass-mode-command`.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory file size that can be scanned (MB).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> Optional[int]:
        """
        Ports to scan for content (1 - 65535, default = 21).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> Optional[str]:
        """
        Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter(name="sslOffloaded")
    def ssl_offloaded(self) -> Optional[str]:
        """
        SSL decryption and encryption performed by an external device. Valid values: `no`, `yes`.
        """
        return pulumi.get(self, "ssl_offloaded")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="streamBasedUncompressedLimit")
    def stream_based_uncompressed_limit(self) -> Optional[int]:
        """
        Maximum stream-based uncompressed data size that will be scanned in megabytes. Stream-based uncompression used only under certain conditions (unlimited = 0, default = 0).
        """
        return pulumi.get(self, "stream_based_uncompressed_limit")

    @property
    @pulumi.getter(name="tcpWindowMaximum")
    def tcp_window_maximum(self) -> Optional[int]:
        """
        Maximum dynamic TCP window size.
        """
        return pulumi.get(self, "tcp_window_maximum")

    @property
    @pulumi.getter(name="tcpWindowMinimum")
    def tcp_window_minimum(self) -> Optional[int]:
        """
        Minimum dynamic TCP window size.
        """
        return pulumi.get(self, "tcp_window_minimum")

    @property
    @pulumi.getter(name="tcpWindowSize")
    def tcp_window_size(self) -> Optional[int]:
        """
        Set TCP static window size.
        """
        return pulumi.get(self, "tcp_window_size")

    @property
    @pulumi.getter(name="tcpWindowType")
    def tcp_window_type(self) -> Optional[str]:
        """
        TCP window type to use for this protocol.
        """
        return pulumi.get(self, "tcp_window_type")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> Optional[int]:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class ProfileprotocoloptionsHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressIpRating":
            suggest = "address_ip_rating"
        elif key == "blockPageStatusCode":
            suggest = "block_page_status_code"
        elif key == "comfortAmount":
            suggest = "comfort_amount"
        elif key == "comfortInterval":
            suggest = "comfort_interval"
        elif key == "fortinetBar":
            suggest = "fortinet_bar"
        elif key == "fortinetBarPort":
            suggest = "fortinet_bar_port"
        elif key == "httpPolicy":
            suggest = "http_policy"
        elif key == "inspectAll":
            suggest = "inspect_all"
        elif key == "oversizeLimit":
            suggest = "oversize_limit"
        elif key == "postLang":
            suggest = "post_lang"
        elif key == "proxyAfterTcpHandshake":
            suggest = "proxy_after_tcp_handshake"
        elif key == "rangeBlock":
            suggest = "range_block"
        elif key == "retryCount":
            suggest = "retry_count"
        elif key == "scanBzip2":
            suggest = "scan_bzip2"
        elif key == "sslOffloaded":
            suggest = "ssl_offloaded"
        elif key == "streamBasedUncompressedLimit":
            suggest = "stream_based_uncompressed_limit"
        elif key == "streamingContentBypass":
            suggest = "streaming_content_bypass"
        elif key == "stripXForwardedFor":
            suggest = "strip_x_forwarded_for"
        elif key == "switchingProtocols":
            suggest = "switching_protocols"
        elif key == "tcpWindowMaximum":
            suggest = "tcp_window_maximum"
        elif key == "tcpWindowMinimum":
            suggest = "tcp_window_minimum"
        elif key == "tcpWindowSize":
            suggest = "tcp_window_size"
        elif key == "tcpWindowType":
            suggest = "tcp_window_type"
        elif key == "tunnelNonHttp":
            suggest = "tunnel_non_http"
        elif key == "uncompressedNestLimit":
            suggest = "uncompressed_nest_limit"
        elif key == "uncompressedOversizeLimit":
            suggest = "uncompressed_oversize_limit"
        elif key == "unknownContentEncoding":
            suggest = "unknown_content_encoding"
        elif key == "unknownHttpVersion":
            suggest = "unknown_http_version"
        elif key == "verifyDnsForPolicyMatching":
            suggest = "verify_dns_for_policy_matching"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileprotocoloptionsHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileprotocoloptionsHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileprotocoloptionsHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_ip_rating: Optional[str] = None,
                 block_page_status_code: Optional[int] = None,
                 comfort_amount: Optional[int] = None,
                 comfort_interval: Optional[int] = None,
                 fortinet_bar: Optional[str] = None,
                 fortinet_bar_port: Optional[int] = None,
                 h2c: Optional[str] = None,
                 http_policy: Optional[str] = None,
                 inspect_all: Optional[str] = None,
                 options: Optional[str] = None,
                 oversize_limit: Optional[int] = None,
                 ports: Optional[int] = None,
                 post_lang: Optional[str] = None,
                 proxy_after_tcp_handshake: Optional[str] = None,
                 range_block: Optional[str] = None,
                 retry_count: Optional[int] = None,
                 scan_bzip2: Optional[str] = None,
                 ssl_offloaded: Optional[str] = None,
                 status: Optional[str] = None,
                 stream_based_uncompressed_limit: Optional[int] = None,
                 streaming_content_bypass: Optional[str] = None,
                 strip_x_forwarded_for: Optional[str] = None,
                 switching_protocols: Optional[str] = None,
                 tcp_window_maximum: Optional[int] = None,
                 tcp_window_minimum: Optional[int] = None,
                 tcp_window_size: Optional[int] = None,
                 tcp_window_type: Optional[str] = None,
                 tunnel_non_http: Optional[str] = None,
                 uncompressed_nest_limit: Optional[int] = None,
                 uncompressed_oversize_limit: Optional[int] = None,
                 unknown_content_encoding: Optional[str] = None,
                 unknown_http_version: Optional[str] = None,
                 verify_dns_for_policy_matching: Optional[str] = None):
        """
        :param str address_ip_rating: Enable/disable IP based URL rating. Valid values: `enable`, `disable`.
        :param int block_page_status_code: Code number returned for blocked HTTP pages (non-FortiGuard only) (100 - 599, default = 403).
        :param int comfort_amount: Amount of data to send in a transmission for client comforting. On FortiOS versions 6.2.0: 1 - 10240 bytes, default = 1. On FortiOS versions 6.2.4-7.2.3: 1 - 65535 bytes, default = 1.
        :param int comfort_interval: Interval between successive transmissions of data for client comforting (seconds).
        :param str fortinet_bar: Enable/disable Fortinet bar on HTML content. Valid values: `enable`, `disable`.
        :param int fortinet_bar_port: Port for use by Fortinet Bar (1 - 65535, default = 8011).
        :param str h2c: Enable/disable h2c HTTP connection upgrade. Valid values: `enable`, `disable`.
        :param str http_policy: Enable/disable HTTP policy check. Valid values: `disable`, `enable`.
        :param str inspect_all: Enable/disable the inspection of all ports for the protocol. Valid values: `enable`, `disable`.
        :param str options: One or more options that can be applied to the session. Valid values: `clientcomfort`, `servercomfort`, `oversize`, `chunkedbypass`.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (MB). On FortiOS versions 6.2.0-7.2.3: 1 - 383 MB, default = 10.
        :param int ports: Ports to scan for content (1 - 65535, default = 80).
        :param str post_lang: ID codes for character sets to be used to convert to UTF-8 for banned words and DLP on HTTP posts (maximum of 5 character sets). Valid values: `jisx0201`, `jisx0208`, `jisx0212`, `gb2312`, `ksc5601-ex`, `euc-jp`, `sjis`, `iso2022-jp`, `iso2022-jp-1`, `iso2022-jp-2`, `euc-cn`, `ces-gbk`, `hz`, `ces-big5`, `euc-kr`, `iso2022-jp-3`, `iso8859-1`, `tis620`, `cp874`, `cp1252`, `cp1251`.
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        :param str range_block: Enable/disable blocking of partial downloads. Valid values: `disable`, `enable`.
        :param int retry_count: Number of attempts to retry HTTP connection (0 - 100, default = 0).
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        :param str ssl_offloaded: SSL decryption and encryption performed by an external device. Valid values: `no`, `yes`.
        :param str status: Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        :param int stream_based_uncompressed_limit: Maximum stream-based uncompressed data size that will be scanned in megabytes. Stream-based uncompression used only under certain conditions (unlimited = 0, default = 0).
        :param str streaming_content_bypass: Enable/disable bypassing of streaming content from buffering. Valid values: `enable`, `disable`.
        :param str strip_x_forwarded_for: Enable/disable stripping of HTTP X-Forwarded-For header. Valid values: `disable`, `enable`.
        :param str switching_protocols: Bypass from scanning, or block a connection that attempts to switch protocol. Valid values: `bypass`, `block`.
        :param int tcp_window_maximum: Maximum dynamic TCP window size.
        :param int tcp_window_minimum: Minimum dynamic TCP window size.
        :param int tcp_window_size: Set TCP static window size.
        :param str tcp_window_type: Specify type of TCP window to use for this protocol.
        :param str tunnel_non_http: Configure how to process non-HTTP traffic when a profile configured for HTTP traffic accepts a non-HTTP session. Can occur if an application sends non-HTTP traffic using an HTTP destination port. Valid values: `enable`, `disable`.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (MB).
        :param str unknown_content_encoding: Configure the action the FortiGate unit will take on unknown content-encoding. Valid values: `block`, `inspect`, `bypass`.
        :param str unknown_http_version: How to handle HTTP sessions that do not comply with HTTP 0.9, 1.0, or 1.1. Valid values: `reject`, `tunnel`, `best-effort`.
        :param str verify_dns_for_policy_matching: Enable/disable verification of DNS for policy matching. Valid values: `enable`, `disable`.
        """
        if address_ip_rating is not None:
            pulumi.set(__self__, "address_ip_rating", address_ip_rating)
        if block_page_status_code is not None:
            pulumi.set(__self__, "block_page_status_code", block_page_status_code)
        if comfort_amount is not None:
            pulumi.set(__self__, "comfort_amount", comfort_amount)
        if comfort_interval is not None:
            pulumi.set(__self__, "comfort_interval", comfort_interval)
        if fortinet_bar is not None:
            pulumi.set(__self__, "fortinet_bar", fortinet_bar)
        if fortinet_bar_port is not None:
            pulumi.set(__self__, "fortinet_bar_port", fortinet_bar_port)
        if h2c is not None:
            pulumi.set(__self__, "h2c", h2c)
        if http_policy is not None:
            pulumi.set(__self__, "http_policy", http_policy)
        if inspect_all is not None:
            pulumi.set(__self__, "inspect_all", inspect_all)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if oversize_limit is not None:
            pulumi.set(__self__, "oversize_limit", oversize_limit)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if post_lang is not None:
            pulumi.set(__self__, "post_lang", post_lang)
        if proxy_after_tcp_handshake is not None:
            pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        if range_block is not None:
            pulumi.set(__self__, "range_block", range_block)
        if retry_count is not None:
            pulumi.set(__self__, "retry_count", retry_count)
        if scan_bzip2 is not None:
            pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        if ssl_offloaded is not None:
            pulumi.set(__self__, "ssl_offloaded", ssl_offloaded)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if stream_based_uncompressed_limit is not None:
            pulumi.set(__self__, "stream_based_uncompressed_limit", stream_based_uncompressed_limit)
        if streaming_content_bypass is not None:
            pulumi.set(__self__, "streaming_content_bypass", streaming_content_bypass)
        if strip_x_forwarded_for is not None:
            pulumi.set(__self__, "strip_x_forwarded_for", strip_x_forwarded_for)
        if switching_protocols is not None:
            pulumi.set(__self__, "switching_protocols", switching_protocols)
        if tcp_window_maximum is not None:
            pulumi.set(__self__, "tcp_window_maximum", tcp_window_maximum)
        if tcp_window_minimum is not None:
            pulumi.set(__self__, "tcp_window_minimum", tcp_window_minimum)
        if tcp_window_size is not None:
            pulumi.set(__self__, "tcp_window_size", tcp_window_size)
        if tcp_window_type is not None:
            pulumi.set(__self__, "tcp_window_type", tcp_window_type)
        if tunnel_non_http is not None:
            pulumi.set(__self__, "tunnel_non_http", tunnel_non_http)
        if uncompressed_nest_limit is not None:
            pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        if uncompressed_oversize_limit is not None:
            pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)
        if unknown_content_encoding is not None:
            pulumi.set(__self__, "unknown_content_encoding", unknown_content_encoding)
        if unknown_http_version is not None:
            pulumi.set(__self__, "unknown_http_version", unknown_http_version)
        if verify_dns_for_policy_matching is not None:
            pulumi.set(__self__, "verify_dns_for_policy_matching", verify_dns_for_policy_matching)

    @property
    @pulumi.getter(name="addressIpRating")
    def address_ip_rating(self) -> Optional[str]:
        """
        Enable/disable IP based URL rating. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "address_ip_rating")

    @property
    @pulumi.getter(name="blockPageStatusCode")
    def block_page_status_code(self) -> Optional[int]:
        """
        Code number returned for blocked HTTP pages (non-FortiGuard only) (100 - 599, default = 403).
        """
        return pulumi.get(self, "block_page_status_code")

    @property
    @pulumi.getter(name="comfortAmount")
    def comfort_amount(self) -> Optional[int]:
        """
        Amount of data to send in a transmission for client comforting. On FortiOS versions 6.2.0: 1 - 10240 bytes, default = 1. On FortiOS versions 6.2.4-7.2.3: 1 - 65535 bytes, default = 1.
        """
        return pulumi.get(self, "comfort_amount")

    @property
    @pulumi.getter(name="comfortInterval")
    def comfort_interval(self) -> Optional[int]:
        """
        Interval between successive transmissions of data for client comforting (seconds).
        """
        return pulumi.get(self, "comfort_interval")

    @property
    @pulumi.getter(name="fortinetBar")
    def fortinet_bar(self) -> Optional[str]:
        """
        Enable/disable Fortinet bar on HTML content. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "fortinet_bar")

    @property
    @pulumi.getter(name="fortinetBarPort")
    def fortinet_bar_port(self) -> Optional[int]:
        """
        Port for use by Fortinet Bar (1 - 65535, default = 8011).
        """
        return pulumi.get(self, "fortinet_bar_port")

    @property
    @pulumi.getter
    def h2c(self) -> Optional[str]:
        """
        Enable/disable h2c HTTP connection upgrade. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "h2c")

    @property
    @pulumi.getter(name="httpPolicy")
    def http_policy(self) -> Optional[str]:
        """
        Enable/disable HTTP policy check. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "http_policy")

    @property
    @pulumi.getter(name="inspectAll")
    def inspect_all(self) -> Optional[str]:
        """
        Enable/disable the inspection of all ports for the protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "inspect_all")

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        One or more options that can be applied to the session. Valid values: `clientcomfort`, `servercomfort`, `oversize`, `chunkedbypass`.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory file size that can be scanned (MB). On FortiOS versions 6.2.0-7.2.3: 1 - 383 MB, default = 10.
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> Optional[int]:
        """
        Ports to scan for content (1 - 65535, default = 80).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="postLang")
    def post_lang(self) -> Optional[str]:
        """
        ID codes for character sets to be used to convert to UTF-8 for banned words and DLP on HTTP posts (maximum of 5 character sets). Valid values: `jisx0201`, `jisx0208`, `jisx0212`, `gb2312`, `ksc5601-ex`, `euc-jp`, `sjis`, `iso2022-jp`, `iso2022-jp-1`, `iso2022-jp-2`, `euc-cn`, `ces-gbk`, `hz`, `ces-big5`, `euc-kr`, `iso2022-jp-3`, `iso8859-1`, `tis620`, `cp874`, `cp1252`, `cp1251`.
        """
        return pulumi.get(self, "post_lang")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> Optional[str]:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter(name="rangeBlock")
    def range_block(self) -> Optional[str]:
        """
        Enable/disable blocking of partial downloads. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "range_block")

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> Optional[int]:
        """
        Number of attempts to retry HTTP connection (0 - 100, default = 0).
        """
        return pulumi.get(self, "retry_count")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> Optional[str]:
        """
        Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter(name="sslOffloaded")
    def ssl_offloaded(self) -> Optional[str]:
        """
        SSL decryption and encryption performed by an external device. Valid values: `no`, `yes`.
        """
        return pulumi.get(self, "ssl_offloaded")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="streamBasedUncompressedLimit")
    def stream_based_uncompressed_limit(self) -> Optional[int]:
        """
        Maximum stream-based uncompressed data size that will be scanned in megabytes. Stream-based uncompression used only under certain conditions (unlimited = 0, default = 0).
        """
        return pulumi.get(self, "stream_based_uncompressed_limit")

    @property
    @pulumi.getter(name="streamingContentBypass")
    def streaming_content_bypass(self) -> Optional[str]:
        """
        Enable/disable bypassing of streaming content from buffering. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "streaming_content_bypass")

    @property
    @pulumi.getter(name="stripXForwardedFor")
    def strip_x_forwarded_for(self) -> Optional[str]:
        """
        Enable/disable stripping of HTTP X-Forwarded-For header. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "strip_x_forwarded_for")

    @property
    @pulumi.getter(name="switchingProtocols")
    def switching_protocols(self) -> Optional[str]:
        """
        Bypass from scanning, or block a connection that attempts to switch protocol. Valid values: `bypass`, `block`.
        """
        return pulumi.get(self, "switching_protocols")

    @property
    @pulumi.getter(name="tcpWindowMaximum")
    def tcp_window_maximum(self) -> Optional[int]:
        """
        Maximum dynamic TCP window size.
        """
        return pulumi.get(self, "tcp_window_maximum")

    @property
    @pulumi.getter(name="tcpWindowMinimum")
    def tcp_window_minimum(self) -> Optional[int]:
        """
        Minimum dynamic TCP window size.
        """
        return pulumi.get(self, "tcp_window_minimum")

    @property
    @pulumi.getter(name="tcpWindowSize")
    def tcp_window_size(self) -> Optional[int]:
        """
        Set TCP static window size.
        """
        return pulumi.get(self, "tcp_window_size")

    @property
    @pulumi.getter(name="tcpWindowType")
    def tcp_window_type(self) -> Optional[str]:
        """
        Specify type of TCP window to use for this protocol.
        """
        return pulumi.get(self, "tcp_window_type")

    @property
    @pulumi.getter(name="tunnelNonHttp")
    def tunnel_non_http(self) -> Optional[str]:
        """
        Configure how to process non-HTTP traffic when a profile configured for HTTP traffic accepts a non-HTTP session. Can occur if an application sends non-HTTP traffic using an HTTP destination port. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "tunnel_non_http")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> Optional[int]:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")

    @property
    @pulumi.getter(name="unknownContentEncoding")
    def unknown_content_encoding(self) -> Optional[str]:
        """
        Configure the action the FortiGate unit will take on unknown content-encoding. Valid values: `block`, `inspect`, `bypass`.
        """
        return pulumi.get(self, "unknown_content_encoding")

    @property
    @pulumi.getter(name="unknownHttpVersion")
    def unknown_http_version(self) -> Optional[str]:
        """
        How to handle HTTP sessions that do not comply with HTTP 0.9, 1.0, or 1.1. Valid values: `reject`, `tunnel`, `best-effort`.
        """
        return pulumi.get(self, "unknown_http_version")

    @property
    @pulumi.getter(name="verifyDnsForPolicyMatching")
    def verify_dns_for_policy_matching(self) -> Optional[str]:
        """
        Enable/disable verification of DNS for policy matching. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "verify_dns_for_policy_matching")


@pulumi.output_type
class ProfileprotocoloptionsImap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inspectAll":
            suggest = "inspect_all"
        elif key == "oversizeLimit":
            suggest = "oversize_limit"
        elif key == "proxyAfterTcpHandshake":
            suggest = "proxy_after_tcp_handshake"
        elif key == "scanBzip2":
            suggest = "scan_bzip2"
        elif key == "sslOffloaded":
            suggest = "ssl_offloaded"
        elif key == "uncompressedNestLimit":
            suggest = "uncompressed_nest_limit"
        elif key == "uncompressedOversizeLimit":
            suggest = "uncompressed_oversize_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileprotocoloptionsImap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileprotocoloptionsImap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileprotocoloptionsImap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inspect_all: Optional[str] = None,
                 options: Optional[str] = None,
                 oversize_limit: Optional[int] = None,
                 ports: Optional[int] = None,
                 proxy_after_tcp_handshake: Optional[str] = None,
                 scan_bzip2: Optional[str] = None,
                 ssl_offloaded: Optional[str] = None,
                 status: Optional[str] = None,
                 uncompressed_nest_limit: Optional[int] = None,
                 uncompressed_oversize_limit: Optional[int] = None):
        """
        :param str inspect_all: Enable/disable the inspection of all ports for the protocol. Valid values: `enable`, `disable`.
        :param str options: One or more options that can be applied to the session. Valid values: `fragmail`, `oversize`.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (MB).
        :param int ports: Ports to scan for content (1 - 65535, default = 143).
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        :param str ssl_offloaded: SSL decryption and encryption performed by an external device. Valid values: `no`, `yes`.
        :param str status: Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        if inspect_all is not None:
            pulumi.set(__self__, "inspect_all", inspect_all)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if oversize_limit is not None:
            pulumi.set(__self__, "oversize_limit", oversize_limit)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if proxy_after_tcp_handshake is not None:
            pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        if scan_bzip2 is not None:
            pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        if ssl_offloaded is not None:
            pulumi.set(__self__, "ssl_offloaded", ssl_offloaded)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if uncompressed_nest_limit is not None:
            pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        if uncompressed_oversize_limit is not None:
            pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter(name="inspectAll")
    def inspect_all(self) -> Optional[str]:
        """
        Enable/disable the inspection of all ports for the protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "inspect_all")

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        One or more options that can be applied to the session. Valid values: `fragmail`, `oversize`.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory file size that can be scanned (MB).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> Optional[int]:
        """
        Ports to scan for content (1 - 65535, default = 143).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> Optional[str]:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> Optional[str]:
        """
        Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter(name="sslOffloaded")
    def ssl_offloaded(self) -> Optional[str]:
        """
        SSL decryption and encryption performed by an external device. Valid values: `no`, `yes`.
        """
        return pulumi.get(self, "ssl_offloaded")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> Optional[int]:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class ProfileprotocoloptionsMailSignature(dict):
    def __init__(__self__, *,
                 signature: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str signature: Email signature to be added to outgoing email (if the signature contains spaces, enclose with quotation marks).
        :param str status: Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate. Valid values: `disable`, `enable`.
        """
        if signature is not None:
            pulumi.set(__self__, "signature", signature)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def signature(self) -> Optional[str]:
        """
        Email signature to be added to outgoing email (if the signature contains spaces, enclose with quotation marks).
        """
        return pulumi.get(self, "signature")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ProfileprotocoloptionsMapi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oversizeLimit":
            suggest = "oversize_limit"
        elif key == "scanBzip2":
            suggest = "scan_bzip2"
        elif key == "uncompressedNestLimit":
            suggest = "uncompressed_nest_limit"
        elif key == "uncompressedOversizeLimit":
            suggest = "uncompressed_oversize_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileprotocoloptionsMapi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileprotocoloptionsMapi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileprotocoloptionsMapi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 options: Optional[str] = None,
                 oversize_limit: Optional[int] = None,
                 ports: Optional[int] = None,
                 scan_bzip2: Optional[str] = None,
                 status: Optional[str] = None,
                 uncompressed_nest_limit: Optional[int] = None,
                 uncompressed_oversize_limit: Optional[int] = None):
        """
        :param str options: One or more options that can be applied to the session. Valid values: `fragmail`, `oversize`.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (MB).
        :param int ports: Ports to scan for content (1 - 65535, default = 110).
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        :param str status: Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        if options is not None:
            pulumi.set(__self__, "options", options)
        if oversize_limit is not None:
            pulumi.set(__self__, "oversize_limit", oversize_limit)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if scan_bzip2 is not None:
            pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if uncompressed_nest_limit is not None:
            pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        if uncompressed_oversize_limit is not None:
            pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        One or more options that can be applied to the session. Valid values: `fragmail`, `oversize`.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory file size that can be scanned (MB).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> Optional[int]:
        """
        Ports to scan for content (1 - 65535, default = 110).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> Optional[str]:
        """
        Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> Optional[int]:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class ProfileprotocoloptionsNntp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inspectAll":
            suggest = "inspect_all"
        elif key == "oversizeLimit":
            suggest = "oversize_limit"
        elif key == "proxyAfterTcpHandshake":
            suggest = "proxy_after_tcp_handshake"
        elif key == "scanBzip2":
            suggest = "scan_bzip2"
        elif key == "uncompressedNestLimit":
            suggest = "uncompressed_nest_limit"
        elif key == "uncompressedOversizeLimit":
            suggest = "uncompressed_oversize_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileprotocoloptionsNntp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileprotocoloptionsNntp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileprotocoloptionsNntp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inspect_all: Optional[str] = None,
                 options: Optional[str] = None,
                 oversize_limit: Optional[int] = None,
                 ports: Optional[int] = None,
                 proxy_after_tcp_handshake: Optional[str] = None,
                 scan_bzip2: Optional[str] = None,
                 status: Optional[str] = None,
                 uncompressed_nest_limit: Optional[int] = None,
                 uncompressed_oversize_limit: Optional[int] = None):
        """
        :param str inspect_all: Enable/disable the inspection of all ports for the protocol. Valid values: `enable`, `disable`.
        :param str options: One or more options that can be applied to the session. Valid values: `oversize`, `splice`.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (MB).
        :param int ports: Ports to scan for content (1 - 65535, default = 119).
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        :param str status: Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        if inspect_all is not None:
            pulumi.set(__self__, "inspect_all", inspect_all)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if oversize_limit is not None:
            pulumi.set(__self__, "oversize_limit", oversize_limit)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if proxy_after_tcp_handshake is not None:
            pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        if scan_bzip2 is not None:
            pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if uncompressed_nest_limit is not None:
            pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        if uncompressed_oversize_limit is not None:
            pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter(name="inspectAll")
    def inspect_all(self) -> Optional[str]:
        """
        Enable/disable the inspection of all ports for the protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "inspect_all")

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        One or more options that can be applied to the session. Valid values: `oversize`, `splice`.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory file size that can be scanned (MB).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> Optional[int]:
        """
        Ports to scan for content (1 - 65535, default = 119).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> Optional[str]:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> Optional[str]:
        """
        Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> Optional[int]:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class ProfileprotocoloptionsPop3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inspectAll":
            suggest = "inspect_all"
        elif key == "oversizeLimit":
            suggest = "oversize_limit"
        elif key == "proxyAfterTcpHandshake":
            suggest = "proxy_after_tcp_handshake"
        elif key == "scanBzip2":
            suggest = "scan_bzip2"
        elif key == "sslOffloaded":
            suggest = "ssl_offloaded"
        elif key == "uncompressedNestLimit":
            suggest = "uncompressed_nest_limit"
        elif key == "uncompressedOversizeLimit":
            suggest = "uncompressed_oversize_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileprotocoloptionsPop3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileprotocoloptionsPop3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileprotocoloptionsPop3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inspect_all: Optional[str] = None,
                 options: Optional[str] = None,
                 oversize_limit: Optional[int] = None,
                 ports: Optional[int] = None,
                 proxy_after_tcp_handshake: Optional[str] = None,
                 scan_bzip2: Optional[str] = None,
                 ssl_offloaded: Optional[str] = None,
                 status: Optional[str] = None,
                 uncompressed_nest_limit: Optional[int] = None,
                 uncompressed_oversize_limit: Optional[int] = None):
        """
        :param str inspect_all: Enable/disable the inspection of all ports for the protocol. Valid values: `enable`, `disable`.
        :param str options: One or more options that can be applied to the session. Valid values: `oversize`.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (MB).
        :param int ports: Ports to scan for content (1 - 65535, default = 445).
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        :param str ssl_offloaded: SSL decryption and encryption performed by an external device. Valid values: `no`, `yes`.
        :param str status: Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        if inspect_all is not None:
            pulumi.set(__self__, "inspect_all", inspect_all)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if oversize_limit is not None:
            pulumi.set(__self__, "oversize_limit", oversize_limit)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if proxy_after_tcp_handshake is not None:
            pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        if scan_bzip2 is not None:
            pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        if ssl_offloaded is not None:
            pulumi.set(__self__, "ssl_offloaded", ssl_offloaded)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if uncompressed_nest_limit is not None:
            pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        if uncompressed_oversize_limit is not None:
            pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter(name="inspectAll")
    def inspect_all(self) -> Optional[str]:
        """
        Enable/disable the inspection of all ports for the protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "inspect_all")

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        One or more options that can be applied to the session. Valid values: `oversize`.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory file size that can be scanned (MB).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> Optional[int]:
        """
        Ports to scan for content (1 - 65535, default = 445).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> Optional[str]:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> Optional[str]:
        """
        Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter(name="sslOffloaded")
    def ssl_offloaded(self) -> Optional[str]:
        """
        SSL decryption and encryption performed by an external device. Valid values: `no`, `yes`.
        """
        return pulumi.get(self, "ssl_offloaded")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> Optional[int]:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class ProfileprotocoloptionsSmtp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inspectAll":
            suggest = "inspect_all"
        elif key == "oversizeLimit":
            suggest = "oversize_limit"
        elif key == "proxyAfterTcpHandshake":
            suggest = "proxy_after_tcp_handshake"
        elif key == "scanBzip2":
            suggest = "scan_bzip2"
        elif key == "serverBusy":
            suggest = "server_busy"
        elif key == "sslOffloaded":
            suggest = "ssl_offloaded"
        elif key == "uncompressedNestLimit":
            suggest = "uncompressed_nest_limit"
        elif key == "uncompressedOversizeLimit":
            suggest = "uncompressed_oversize_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileprotocoloptionsSmtp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileprotocoloptionsSmtp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileprotocoloptionsSmtp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inspect_all: Optional[str] = None,
                 options: Optional[str] = None,
                 oversize_limit: Optional[int] = None,
                 ports: Optional[int] = None,
                 proxy_after_tcp_handshake: Optional[str] = None,
                 scan_bzip2: Optional[str] = None,
                 server_busy: Optional[str] = None,
                 ssl_offloaded: Optional[str] = None,
                 status: Optional[str] = None,
                 uncompressed_nest_limit: Optional[int] = None,
                 uncompressed_oversize_limit: Optional[int] = None):
        """
        :param str inspect_all: Enable/disable the inspection of all ports for the protocol. Valid values: `enable`, `disable`.
        :param str options: One or more options that can be applied to the session. Valid values: `fragmail`, `oversize`, `splice`.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (MB).
        :param int ports: Ports to scan for content (1 - 65535, default = 25).
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        :param str server_busy: Enable/disable SMTP server busy when server not available. Valid values: `enable`, `disable`.
        :param str ssl_offloaded: SSL decryption and encryption performed by an external device. Valid values: `no`, `yes`.
        :param str status: Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        if inspect_all is not None:
            pulumi.set(__self__, "inspect_all", inspect_all)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if oversize_limit is not None:
            pulumi.set(__self__, "oversize_limit", oversize_limit)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if proxy_after_tcp_handshake is not None:
            pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        if scan_bzip2 is not None:
            pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        if server_busy is not None:
            pulumi.set(__self__, "server_busy", server_busy)
        if ssl_offloaded is not None:
            pulumi.set(__self__, "ssl_offloaded", ssl_offloaded)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if uncompressed_nest_limit is not None:
            pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        if uncompressed_oversize_limit is not None:
            pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter(name="inspectAll")
    def inspect_all(self) -> Optional[str]:
        """
        Enable/disable the inspection of all ports for the protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "inspect_all")

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        One or more options that can be applied to the session. Valid values: `fragmail`, `oversize`, `splice`.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory file size that can be scanned (MB).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> Optional[int]:
        """
        Ports to scan for content (1 - 65535, default = 25).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> Optional[str]:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> Optional[str]:
        """
        Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter(name="serverBusy")
    def server_busy(self) -> Optional[str]:
        """
        Enable/disable SMTP server busy when server not available. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "server_busy")

    @property
    @pulumi.getter(name="sslOffloaded")
    def ssl_offloaded(self) -> Optional[str]:
        """
        SSL decryption and encryption performed by an external device. Valid values: `no`, `yes`.
        """
        return pulumi.get(self, "ssl_offloaded")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable the active status of scanning for this protocol. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> Optional[int]:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class ProfileprotocoloptionsSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "comfortAmount":
            suggest = "comfort_amount"
        elif key == "comfortInterval":
            suggest = "comfort_interval"
        elif key == "oversizeLimit":
            suggest = "oversize_limit"
        elif key == "scanBzip2":
            suggest = "scan_bzip2"
        elif key == "sslOffloaded":
            suggest = "ssl_offloaded"
        elif key == "streamBasedUncompressedLimit":
            suggest = "stream_based_uncompressed_limit"
        elif key == "tcpWindowMaximum":
            suggest = "tcp_window_maximum"
        elif key == "tcpWindowMinimum":
            suggest = "tcp_window_minimum"
        elif key == "tcpWindowSize":
            suggest = "tcp_window_size"
        elif key == "tcpWindowType":
            suggest = "tcp_window_type"
        elif key == "uncompressedNestLimit":
            suggest = "uncompressed_nest_limit"
        elif key == "uncompressedOversizeLimit":
            suggest = "uncompressed_oversize_limit"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileprotocoloptionsSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileprotocoloptionsSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileprotocoloptionsSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comfort_amount: Optional[int] = None,
                 comfort_interval: Optional[int] = None,
                 options: Optional[str] = None,
                 oversize_limit: Optional[int] = None,
                 scan_bzip2: Optional[str] = None,
                 ssl_offloaded: Optional[str] = None,
                 stream_based_uncompressed_limit: Optional[int] = None,
                 tcp_window_maximum: Optional[int] = None,
                 tcp_window_minimum: Optional[int] = None,
                 tcp_window_size: Optional[int] = None,
                 tcp_window_type: Optional[str] = None,
                 uncompressed_nest_limit: Optional[int] = None,
                 uncompressed_oversize_limit: Optional[int] = None):
        """
        :param int comfort_amount: Number of bytes to send in each transmission for client comforting (bytes).
        :param int comfort_interval: Interval between successive transmissions of data for client comforting (seconds).
        :param str options: One or more options that can be applied to the session. Valid values: `oversize`, `clientcomfort`, `servercomfort`.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (MB).
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        :param str ssl_offloaded: SSL decryption and encryption performed by an external device. Valid values: `no`, `yes`.
        :param int stream_based_uncompressed_limit: Maximum stream-based uncompressed data size that will be scanned in megabytes. Stream-based uncompression used only under certain conditions (unlimited = 0, default = 0).
        :param int tcp_window_maximum: Maximum dynamic TCP window size.
        :param int tcp_window_minimum: Minimum dynamic TCP window size.
        :param int tcp_window_size: Set TCP static window size.
        :param str tcp_window_type: TCP window type to use for this protocol.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        if comfort_amount is not None:
            pulumi.set(__self__, "comfort_amount", comfort_amount)
        if comfort_interval is not None:
            pulumi.set(__self__, "comfort_interval", comfort_interval)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if oversize_limit is not None:
            pulumi.set(__self__, "oversize_limit", oversize_limit)
        if scan_bzip2 is not None:
            pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        if ssl_offloaded is not None:
            pulumi.set(__self__, "ssl_offloaded", ssl_offloaded)
        if stream_based_uncompressed_limit is not None:
            pulumi.set(__self__, "stream_based_uncompressed_limit", stream_based_uncompressed_limit)
        if tcp_window_maximum is not None:
            pulumi.set(__self__, "tcp_window_maximum", tcp_window_maximum)
        if tcp_window_minimum is not None:
            pulumi.set(__self__, "tcp_window_minimum", tcp_window_minimum)
        if tcp_window_size is not None:
            pulumi.set(__self__, "tcp_window_size", tcp_window_size)
        if tcp_window_type is not None:
            pulumi.set(__self__, "tcp_window_type", tcp_window_type)
        if uncompressed_nest_limit is not None:
            pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        if uncompressed_oversize_limit is not None:
            pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter(name="comfortAmount")
    def comfort_amount(self) -> Optional[int]:
        """
        Number of bytes to send in each transmission for client comforting (bytes).
        """
        return pulumi.get(self, "comfort_amount")

    @property
    @pulumi.getter(name="comfortInterval")
    def comfort_interval(self) -> Optional[int]:
        """
        Interval between successive transmissions of data for client comforting (seconds).
        """
        return pulumi.get(self, "comfort_interval")

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        One or more options that can be applied to the session. Valid values: `oversize`, `clientcomfort`, `servercomfort`.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory file size that can be scanned (MB).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> Optional[str]:
        """
        Enable/disable scanning of BZip2 compressed files. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter(name="sslOffloaded")
    def ssl_offloaded(self) -> Optional[str]:
        """
        SSL decryption and encryption performed by an external device. Valid values: `no`, `yes`.
        """
        return pulumi.get(self, "ssl_offloaded")

    @property
    @pulumi.getter(name="streamBasedUncompressedLimit")
    def stream_based_uncompressed_limit(self) -> Optional[int]:
        """
        Maximum stream-based uncompressed data size that will be scanned in megabytes. Stream-based uncompression used only under certain conditions (unlimited = 0, default = 0).
        """
        return pulumi.get(self, "stream_based_uncompressed_limit")

    @property
    @pulumi.getter(name="tcpWindowMaximum")
    def tcp_window_maximum(self) -> Optional[int]:
        """
        Maximum dynamic TCP window size.
        """
        return pulumi.get(self, "tcp_window_maximum")

    @property
    @pulumi.getter(name="tcpWindowMinimum")
    def tcp_window_minimum(self) -> Optional[int]:
        """
        Minimum dynamic TCP window size.
        """
        return pulumi.get(self, "tcp_window_minimum")

    @property
    @pulumi.getter(name="tcpWindowSize")
    def tcp_window_size(self) -> Optional[int]:
        """
        Set TCP static window size.
        """
        return pulumi.get(self, "tcp_window_size")

    @property
    @pulumi.getter(name="tcpWindowType")
    def tcp_window_type(self) -> Optional[str]:
        """
        TCP window type to use for this protocol.
        """
        return pulumi.get(self, "tcp_window_type")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> Optional[int]:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> Optional[int]:
        """
        Maximum in-memory uncompressed file size that can be scanned (MB).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class ProxyaddressApplication(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: SaaS applicaton name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        SaaS applicaton name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxyaddressCategory(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Fortiguard category id.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Fortiguard category id.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ProxyaddressHeaderGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caseSensitivity":
            suggest = "case_sensitivity"
        elif key == "headerName":
            suggest = "header_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProxyaddressHeaderGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProxyaddressHeaderGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProxyaddressHeaderGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 case_sensitivity: Optional[str] = None,
                 header: Optional[str] = None,
                 header_name: Optional[str] = None,
                 id: Optional[int] = None):
        """
        :param str case_sensitivity: Case sensitivity in pattern. Valid values: `disable`, `enable`.
        :param str header: HTTP header regular expression.
        :param str header_name: HTTP header.
        :param int id: ID.
        """
        if case_sensitivity is not None:
            pulumi.set(__self__, "case_sensitivity", case_sensitivity)
        if header is not None:
            pulumi.set(__self__, "header", header)
        if header_name is not None:
            pulumi.set(__self__, "header_name", header_name)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="caseSensitivity")
    def case_sensitivity(self) -> Optional[str]:
        """
        Case sensitivity in pattern. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "case_sensitivity")

    @property
    @pulumi.getter
    def header(self) -> Optional[str]:
        """
        HTTP header regular expression.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> Optional[str]:
        """
        HTTP header.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ProxyaddressTagging(dict):
    def __init__(__self__, *,
                 category: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.ProxyaddressTaggingTag']] = None):
        """
        :param str category: Tag category.
        :param str name: Tagging entry name.
        :param Sequence['ProxyaddressTaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tagging entry name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.ProxyaddressTaggingTag']]:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ProxyaddressTaggingTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Tag name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tag name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxyaddrgrpMember(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxyaddrgrpTagging(dict):
    def __init__(__self__, *,
                 category: Optional[str] = None,
                 name: Optional[str] = None,
                 tags: Optional[Sequence['outputs.ProxyaddrgrpTaggingTag']] = None):
        """
        :param str category: Tag category.
        :param str name: Tagging entry name.
        :param Sequence['ProxyaddrgrpTaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tagging entry name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.ProxyaddrgrpTaggingTag']]:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class ProxyaddrgrpTaggingTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Tag name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Tag name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyAccessProxy6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyAccessProxy(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Access proxy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Access proxy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyDstaddr6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyDstaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyDstintf(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyInternetService6Custom(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyInternetService6CustomGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyInternetService6Group(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyInternetService6Name(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyInternetServiceCustom(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Custom name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyInternetServiceCustomGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Custom Internet Service IPv6 group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom Internet Service IPv6 group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyInternetServiceGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyInternetServiceId(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Internet Service ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Internet Service ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ProxypolicyInternetServiceName(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyPoolname(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: IP pool name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        IP pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyService(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicySortStatePolicyList(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 name: Optional[str] = None,
                 policyid: Optional[str] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if policyid is not None:
            pulumi.set(__self__, "policyid", policyid)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def policyid(self) -> Optional[str]:
        return pulumi.get(self, "policyid")


@pulumi.output_type
class ProxypolicySrcaddr6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicySrcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicySrcintf(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyUser(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProxypolicyZtnaEmsTag(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: EMS Tag name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        EMS Tag name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class RegionCity(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: City ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        City ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SecurityPolicyseqStatePolicyList(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 name: Optional[str] = None,
                 policyid: Optional[str] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if policyid is not None:
            pulumi.set(__self__, "policyid", policyid)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def policyid(self) -> Optional[str]:
        return pulumi.get(self, "policyid")


@pulumi.output_type
class SecuritypolicyAppCategory(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Category IDs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Category IDs.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SecuritypolicyAppGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Application group names.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Application group names.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyApplication(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Application IDs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Application IDs.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SecuritypolicyDstaddr4(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyDstaddr6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyDstaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyDstintf(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyFssoGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Names of FSSO groups.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: User group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        User group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetService6Custom(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetService6CustomGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetService6Group(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetService6Name(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetService6SrcCustom(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetService6SrcCustomGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetService6SrcGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetService6SrcName(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetServiceCustom(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Custom Internet Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetServiceCustomGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Custom Internet Service group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom Internet Service group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetServiceGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetServiceId(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Internet Service ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Internet Service ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SecuritypolicyInternetServiceName(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetServiceSrcCustom(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Custom Internet Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetServiceSrcCustomGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Custom Internet Service6 group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom Internet Service6 group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetServiceSrcGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyInternetServiceSrcId(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Internet Service ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Internet Service ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SecuritypolicyInternetServiceSrcName(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyService(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicySortStatePolicyList(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 name: Optional[str] = None,
                 policyid: Optional[str] = None):
        if action is not None:
            pulumi.set(__self__, "action", action)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if policyid is not None:
            pulumi.set(__self__, "policyid", policyid)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def policyid(self) -> Optional[str]:
        return pulumi.get(self, "policyid")


@pulumi.output_type
class SecuritypolicySrcaddr4(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicySrcaddr6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicySrcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicySrcintf(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SecuritypolicyUrlCategory(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: URL category ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        URL category ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SecuritypolicyUser(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: User name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        User name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyAppCategory(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Category IDs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Category IDs.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ShapingpolicyAppGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Application group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Application group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyApplication(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Application IDs.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Application IDs.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ShapingpolicyDstaddr6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Shaping policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Shaping policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyDstaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyDstintf(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyInternetServiceCustom(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Custom Internet Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyInternetServiceCustomGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Custom Internet Service group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom Internet Service group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyInternetServiceGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyInternetServiceId(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Internet Service ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Internet Service ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ShapingpolicyInternetServiceName(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyInternetServiceSrcCustom(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Custom Internet Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyInternetServiceSrcCustomGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Custom Internet Service group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Custom Internet Service group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyInternetServiceSrcGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyInternetServiceSrcId(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: Internet Service ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Internet Service ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ShapingpolicyInternetServiceSrcName(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Internet Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Internet Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyService(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicySrcaddr6(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Shaping policy name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Shaping policy name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicySrcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicySrcintf(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingpolicyUrlCategory(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: URL category ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        URL category ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ShapingpolicyUser(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: User name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        User name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ShapingprofileShapingEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "burstInMsec":
            suggest = "burst_in_msec"
        elif key == "cburstInMsec":
            suggest = "cburst_in_msec"
        elif key == "classId":
            suggest = "class_id"
        elif key == "guaranteedBandwidthPercentage":
            suggest = "guaranteed_bandwidth_percentage"
        elif key == "maximumBandwidthPercentage":
            suggest = "maximum_bandwidth_percentage"
        elif key == "redProbability":
            suggest = "red_probability"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ShapingprofileShapingEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ShapingprofileShapingEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ShapingprofileShapingEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 burst_in_msec: Optional[int] = None,
                 cburst_in_msec: Optional[int] = None,
                 class_id: Optional[int] = None,
                 guaranteed_bandwidth_percentage: Optional[int] = None,
                 id: Optional[int] = None,
                 limit: Optional[int] = None,
                 max: Optional[int] = None,
                 maximum_bandwidth_percentage: Optional[int] = None,
                 min: Optional[int] = None,
                 priority: Optional[str] = None,
                 red_probability: Optional[int] = None):
        """
        :param int burst_in_msec: Number of bytes that can be burst at maximum-bandwidth speed. Formula: burst = maximum-bandwidth*burst-in-msec.
        :param int cburst_in_msec: Number of bytes that can be burst as fast as the interface can transmit. Formula: cburst = maximum-bandwidth*cburst-in-msec.
        :param int class_id: Class ID.
        :param int guaranteed_bandwidth_percentage: Guaranteed bandwith in percentage.
        :param int id: ID number.
        :param int limit: Hard limit on the real queue size in packets.
        :param int max: Average queue size in packets at which RED drop probability is maximal.
        :param int maximum_bandwidth_percentage: Maximum bandwith in percentage.
        :param int min: Average queue size in packets at which RED drop becomes a possibility.
        :param str priority: Priority.
        :param int red_probability: Maximum probability (in percentage) for RED marking.
        """
        if burst_in_msec is not None:
            pulumi.set(__self__, "burst_in_msec", burst_in_msec)
        if cburst_in_msec is not None:
            pulumi.set(__self__, "cburst_in_msec", cburst_in_msec)
        if class_id is not None:
            pulumi.set(__self__, "class_id", class_id)
        if guaranteed_bandwidth_percentage is not None:
            pulumi.set(__self__, "guaranteed_bandwidth_percentage", guaranteed_bandwidth_percentage)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if maximum_bandwidth_percentage is not None:
            pulumi.set(__self__, "maximum_bandwidth_percentage", maximum_bandwidth_percentage)
        if min is not None:
            pulumi.set(__self__, "min", min)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if red_probability is not None:
            pulumi.set(__self__, "red_probability", red_probability)

    @property
    @pulumi.getter(name="burstInMsec")
    def burst_in_msec(self) -> Optional[int]:
        """
        Number of bytes that can be burst at maximum-bandwidth speed. Formula: burst = maximum-bandwidth*burst-in-msec.
        """
        return pulumi.get(self, "burst_in_msec")

    @property
    @pulumi.getter(name="cburstInMsec")
    def cburst_in_msec(self) -> Optional[int]:
        """
        Number of bytes that can be burst as fast as the interface can transmit. Formula: cburst = maximum-bandwidth*cburst-in-msec.
        """
        return pulumi.get(self, "cburst_in_msec")

    @property
    @pulumi.getter(name="classId")
    def class_id(self) -> Optional[int]:
        """
        Class ID.
        """
        return pulumi.get(self, "class_id")

    @property
    @pulumi.getter(name="guaranteedBandwidthPercentage")
    def guaranteed_bandwidth_percentage(self) -> Optional[int]:
        """
        Guaranteed bandwith in percentage.
        """
        return pulumi.get(self, "guaranteed_bandwidth_percentage")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        ID number.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def limit(self) -> Optional[int]:
        """
        Hard limit on the real queue size in packets.
        """
        return pulumi.get(self, "limit")

    @property
    @pulumi.getter
    def max(self) -> Optional[int]:
        """
        Average queue size in packets at which RED drop probability is maximal.
        """
        return pulumi.get(self, "max")

    @property
    @pulumi.getter(name="maximumBandwidthPercentage")
    def maximum_bandwidth_percentage(self) -> Optional[int]:
        """
        Maximum bandwith in percentage.
        """
        return pulumi.get(self, "maximum_bandwidth_percentage")

    @property
    @pulumi.getter
    def min(self) -> Optional[int]:
        """
        Average queue size in packets at which RED drop becomes a possibility.
        """
        return pulumi.get(self, "min")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        Priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter(name="redProbability")
    def red_probability(self) -> Optional[int]:
        """
        Maximum probability (in percentage) for RED marking.
        """
        return pulumi.get(self, "red_probability")


@pulumi.output_type
class SnifferAnomaly(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "quarantineExpiry":
            suggest = "quarantine_expiry"
        elif key == "quarantineLog":
            suggest = "quarantine_log"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnifferAnomaly. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnifferAnomaly.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnifferAnomaly.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 log: Optional[str] = None,
                 name: Optional[str] = None,
                 quarantine: Optional[str] = None,
                 quarantine_expiry: Optional[str] = None,
                 quarantine_log: Optional[str] = None,
                 status: Optional[str] = None,
                 threshold: Optional[int] = None,
                 thresholddefault: Optional[int] = None):
        """
        :param str action: Action taken when the threshold is reached.
        :param str log: Enable/disable anomaly logging. Valid values: `enable`, `disable`.
        :param str name: Anomaly name.
        :param str quarantine: Quarantine method. Valid values: `none`, `attacker`.
        :param str quarantine_expiry: Duration of quarantine. (Format ###d##h##m, minimum 1m, maximum 364d23h59m, default = 5m). Requires quarantine set to attacker.
        :param str quarantine_log: Enable/disable quarantine logging. Valid values: `disable`, `enable`.
        :param str status: Enable/disable this anomaly. Valid values: `disable`, `enable`.
        :param int threshold: Anomaly threshold. Number of detected instances that triggers the anomaly action. On FortiOS versions 6.2.0-6.4.2, 7.0.0-7.0.5, 7.2.0: packets per minute. On FortiOS versions 6.4.10-6.4.14, 7.0.6-7.0.13, >= 7.2.1: packets per second or concurrent session number.
        :param int thresholddefault: Number of detected instances (packets per second or concurrent session number) which triggers action (1 - 2147483647, default = 1000). Note that each anomaly has a different threshold value assigned to it.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if quarantine is not None:
            pulumi.set(__self__, "quarantine", quarantine)
        if quarantine_expiry is not None:
            pulumi.set(__self__, "quarantine_expiry", quarantine_expiry)
        if quarantine_log is not None:
            pulumi.set(__self__, "quarantine_log", quarantine_log)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if thresholddefault is not None:
            pulumi.set(__self__, "thresholddefault", thresholddefault)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action taken when the threshold is reached.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def log(self) -> Optional[str]:
        """
        Enable/disable anomaly logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Anomaly name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def quarantine(self) -> Optional[str]:
        """
        Quarantine method. Valid values: `none`, `attacker`.
        """
        return pulumi.get(self, "quarantine")

    @property
    @pulumi.getter(name="quarantineExpiry")
    def quarantine_expiry(self) -> Optional[str]:
        """
        Duration of quarantine. (Format ###d##h##m, minimum 1m, maximum 364d23h59m, default = 5m). Requires quarantine set to attacker.
        """
        return pulumi.get(self, "quarantine_expiry")

    @property
    @pulumi.getter(name="quarantineLog")
    def quarantine_log(self) -> Optional[str]:
        """
        Enable/disable quarantine logging. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "quarantine_log")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable this anomaly. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[int]:
        """
        Anomaly threshold. Number of detected instances that triggers the anomaly action. On FortiOS versions 6.2.0-6.4.2, 7.0.0-7.0.5, 7.2.0: packets per minute. On FortiOS versions 6.4.10-6.4.14, 7.0.6-7.0.13, >= 7.2.1: packets per second or concurrent session number.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def thresholddefault(self) -> Optional[int]:
        """
        Number of detected instances (packets per second or concurrent session number) which triggers action (1 - 2147483647, default = 1000). Note that each anomaly has a different threshold value assigned to it.
        """
        return pulumi.get(self, "thresholddefault")


@pulumi.output_type
class SnifferIpThreatfeed(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Threat feed name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Threat feed name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SslsshprofileDot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certValidationFailure":
            suggest = "cert_validation_failure"
        elif key == "certValidationTimeout":
            suggest = "cert_validation_timeout"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "expiredServerCert":
            suggest = "expired_server_cert"
        elif key == "proxyAfterTcpHandshake":
            suggest = "proxy_after_tcp_handshake"
        elif key == "revokedServerCert":
            suggest = "revoked_server_cert"
        elif key == "sniServerCertCheck":
            suggest = "sni_server_cert_check"
        elif key == "unsupportedSslCipher":
            suggest = "unsupported_ssl_cipher"
        elif key == "unsupportedSslNegotiation":
            suggest = "unsupported_ssl_negotiation"
        elif key == "unsupportedSslVersion":
            suggest = "unsupported_ssl_version"
        elif key == "untrustedServerCert":
            suggest = "untrusted_server_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslsshprofileDot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslsshprofileDot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslsshprofileDot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_validation_failure: Optional[str] = None,
                 cert_validation_timeout: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 expired_server_cert: Optional[str] = None,
                 proxy_after_tcp_handshake: Optional[str] = None,
                 quic: Optional[str] = None,
                 revoked_server_cert: Optional[str] = None,
                 sni_server_cert_check: Optional[str] = None,
                 status: Optional[str] = None,
                 unsupported_ssl_cipher: Optional[str] = None,
                 unsupported_ssl_negotiation: Optional[str] = None,
                 unsupported_ssl_version: Optional[str] = None,
                 untrusted_server_cert: Optional[str] = None):
        """
        :param str cert_validation_failure: Action based on certificate validation failure. Valid values: `allow`, `block`, `ignore`.
        :param str cert_validation_timeout: Action based on certificate validation timeout. Valid values: `allow`, `block`, `ignore`.
        :param str client_certificate: Action based on received client certificate. Valid values: `bypass`, `inspect`, `block`.
        :param str expired_server_cert: Action based on server certificate is expired. Valid values: `allow`, `block`, `ignore`.
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        :param str quic: QUIC inspection status. On FortiOS versions 7.4.1: default = disable. On FortiOS versions >= 7.4.2: default = inspect.
        :param str revoked_server_cert: Action based on server certificate is revoked. Valid values: `allow`, `block`, `ignore`.
        :param str sni_server_cert_check: Check the SNI in the client hello message with the CN or SAN fields in the returned server certificate. Valid values: `enable`, `strict`, `disable`.
        :param str status: Configure protocol inspection status. Valid values: `disable`, `deep-inspection`.
        :param str unsupported_ssl_cipher: Action based on the SSL cipher used being unsupported. Valid values: `allow`, `block`.
        :param str unsupported_ssl_negotiation: Action based on the SSL negotiation used being unsupported. Valid values: `allow`, `block`.
        :param str unsupported_ssl_version: Action based on the SSL version used being unsupported.
        :param str untrusted_server_cert: Action based on server certificate is not issued by a trusted CA. Valid values: `allow`, `block`, `ignore`.
        """
        if cert_validation_failure is not None:
            pulumi.set(__self__, "cert_validation_failure", cert_validation_failure)
        if cert_validation_timeout is not None:
            pulumi.set(__self__, "cert_validation_timeout", cert_validation_timeout)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if expired_server_cert is not None:
            pulumi.set(__self__, "expired_server_cert", expired_server_cert)
        if proxy_after_tcp_handshake is not None:
            pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        if quic is not None:
            pulumi.set(__self__, "quic", quic)
        if revoked_server_cert is not None:
            pulumi.set(__self__, "revoked_server_cert", revoked_server_cert)
        if sni_server_cert_check is not None:
            pulumi.set(__self__, "sni_server_cert_check", sni_server_cert_check)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if unsupported_ssl_cipher is not None:
            pulumi.set(__self__, "unsupported_ssl_cipher", unsupported_ssl_cipher)
        if unsupported_ssl_negotiation is not None:
            pulumi.set(__self__, "unsupported_ssl_negotiation", unsupported_ssl_negotiation)
        if unsupported_ssl_version is not None:
            pulumi.set(__self__, "unsupported_ssl_version", unsupported_ssl_version)
        if untrusted_server_cert is not None:
            pulumi.set(__self__, "untrusted_server_cert", untrusted_server_cert)

    @property
    @pulumi.getter(name="certValidationFailure")
    def cert_validation_failure(self) -> Optional[str]:
        """
        Action based on certificate validation failure. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "cert_validation_failure")

    @property
    @pulumi.getter(name="certValidationTimeout")
    def cert_validation_timeout(self) -> Optional[str]:
        """
        Action based on certificate validation timeout. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "cert_validation_timeout")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Action based on received client certificate. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="expiredServerCert")
    def expired_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is expired. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "expired_server_cert")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> Optional[str]:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter
    def quic(self) -> Optional[str]:
        """
        QUIC inspection status. On FortiOS versions 7.4.1: default = disable. On FortiOS versions >= 7.4.2: default = inspect.
        """
        return pulumi.get(self, "quic")

    @property
    @pulumi.getter(name="revokedServerCert")
    def revoked_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is revoked. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "revoked_server_cert")

    @property
    @pulumi.getter(name="sniServerCertCheck")
    def sni_server_cert_check(self) -> Optional[str]:
        """
        Check the SNI in the client hello message with the CN or SAN fields in the returned server certificate. Valid values: `enable`, `strict`, `disable`.
        """
        return pulumi.get(self, "sni_server_cert_check")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Configure protocol inspection status. Valid values: `disable`, `deep-inspection`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="unsupportedSslCipher")
    def unsupported_ssl_cipher(self) -> Optional[str]:
        """
        Action based on the SSL cipher used being unsupported. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl_cipher")

    @property
    @pulumi.getter(name="unsupportedSslNegotiation")
    def unsupported_ssl_negotiation(self) -> Optional[str]:
        """
        Action based on the SSL negotiation used being unsupported. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl_negotiation")

    @property
    @pulumi.getter(name="unsupportedSslVersion")
    def unsupported_ssl_version(self) -> Optional[str]:
        """
        Action based on the SSL version used being unsupported.
        """
        return pulumi.get(self, "unsupported_ssl_version")

    @property
    @pulumi.getter(name="untrustedServerCert")
    def untrusted_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is not issued by a trusted CA. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "untrusted_server_cert")


@pulumi.output_type
class SslsshprofileFtps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certValidationFailure":
            suggest = "cert_validation_failure"
        elif key == "certValidationTimeout":
            suggest = "cert_validation_timeout"
        elif key == "clientCertRequest":
            suggest = "client_cert_request"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "expiredServerCert":
            suggest = "expired_server_cert"
        elif key == "invalidServerCert":
            suggest = "invalid_server_cert"
        elif key == "minAllowedSslVersion":
            suggest = "min_allowed_ssl_version"
        elif key == "revokedServerCert":
            suggest = "revoked_server_cert"
        elif key == "sniServerCertCheck":
            suggest = "sni_server_cert_check"
        elif key == "unsupportedSsl":
            suggest = "unsupported_ssl"
        elif key == "unsupportedSslCipher":
            suggest = "unsupported_ssl_cipher"
        elif key == "unsupportedSslNegotiation":
            suggest = "unsupported_ssl_negotiation"
        elif key == "unsupportedSslVersion":
            suggest = "unsupported_ssl_version"
        elif key == "untrustedServerCert":
            suggest = "untrusted_server_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslsshprofileFtps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslsshprofileFtps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslsshprofileFtps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_validation_failure: Optional[str] = None,
                 cert_validation_timeout: Optional[str] = None,
                 client_cert_request: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 expired_server_cert: Optional[str] = None,
                 invalid_server_cert: Optional[str] = None,
                 min_allowed_ssl_version: Optional[str] = None,
                 ports: Optional[str] = None,
                 revoked_server_cert: Optional[str] = None,
                 sni_server_cert_check: Optional[str] = None,
                 status: Optional[str] = None,
                 unsupported_ssl: Optional[str] = None,
                 unsupported_ssl_cipher: Optional[str] = None,
                 unsupported_ssl_negotiation: Optional[str] = None,
                 unsupported_ssl_version: Optional[str] = None,
                 untrusted_server_cert: Optional[str] = None):
        """
        :param str cert_validation_failure: Action based on certificate validation failure. Valid values: `allow`, `block`, `ignore`.
        :param str cert_validation_timeout: Action based on certificate validation timeout. Valid values: `allow`, `block`, `ignore`.
        :param str client_cert_request: Action based on client certificate request. Valid values: `bypass`, `inspect`, `block`.
        :param str client_certificate: Action based on received client certificate. Valid values: `bypass`, `inspect`, `block`.
        :param str expired_server_cert: Action based on server certificate is expired. Valid values: `allow`, `block`, `ignore`.
        :param str invalid_server_cert: Allow or block the invalid SSL session server certificate. Valid values: `allow`, `block`.
        :param str min_allowed_ssl_version: Minimum SSL version to be allowed. Valid values: `ssl-3.0`, `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        :param str ports: Ports to use for scanning (1 - 65535, default = 443).
        :param str revoked_server_cert: Action based on server certificate is revoked. Valid values: `allow`, `block`, `ignore`.
        :param str sni_server_cert_check: Check the SNI in the client hello message with the CN or SAN fields in the returned server certificate. Valid values: `enable`, `strict`, `disable`.
        :param str status: Configure protocol inspection status. Valid values: `disable`, `deep-inspection`.
        :param str unsupported_ssl: Action based on the SSL encryption used being unsupported. Valid values: `bypass`, `inspect`, `block`.
        :param str unsupported_ssl_cipher: Action based on the SSL cipher used being unsupported. Valid values: `allow`, `block`.
        :param str unsupported_ssl_negotiation: Action based on the SSL negotiation used being unsupported. Valid values: `allow`, `block`.
        :param str unsupported_ssl_version: Action based on the SSL version used being unsupported.
        :param str untrusted_server_cert: Allow, ignore, or block the untrusted SSL session server certificate. Valid values: `allow`, `block`, `ignore`.
        """
        if cert_validation_failure is not None:
            pulumi.set(__self__, "cert_validation_failure", cert_validation_failure)
        if cert_validation_timeout is not None:
            pulumi.set(__self__, "cert_validation_timeout", cert_validation_timeout)
        if client_cert_request is not None:
            pulumi.set(__self__, "client_cert_request", client_cert_request)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if expired_server_cert is not None:
            pulumi.set(__self__, "expired_server_cert", expired_server_cert)
        if invalid_server_cert is not None:
            pulumi.set(__self__, "invalid_server_cert", invalid_server_cert)
        if min_allowed_ssl_version is not None:
            pulumi.set(__self__, "min_allowed_ssl_version", min_allowed_ssl_version)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if revoked_server_cert is not None:
            pulumi.set(__self__, "revoked_server_cert", revoked_server_cert)
        if sni_server_cert_check is not None:
            pulumi.set(__self__, "sni_server_cert_check", sni_server_cert_check)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if unsupported_ssl is not None:
            pulumi.set(__self__, "unsupported_ssl", unsupported_ssl)
        if unsupported_ssl_cipher is not None:
            pulumi.set(__self__, "unsupported_ssl_cipher", unsupported_ssl_cipher)
        if unsupported_ssl_negotiation is not None:
            pulumi.set(__self__, "unsupported_ssl_negotiation", unsupported_ssl_negotiation)
        if unsupported_ssl_version is not None:
            pulumi.set(__self__, "unsupported_ssl_version", unsupported_ssl_version)
        if untrusted_server_cert is not None:
            pulumi.set(__self__, "untrusted_server_cert", untrusted_server_cert)

    @property
    @pulumi.getter(name="certValidationFailure")
    def cert_validation_failure(self) -> Optional[str]:
        """
        Action based on certificate validation failure. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "cert_validation_failure")

    @property
    @pulumi.getter(name="certValidationTimeout")
    def cert_validation_timeout(self) -> Optional[str]:
        """
        Action based on certificate validation timeout. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "cert_validation_timeout")

    @property
    @pulumi.getter(name="clientCertRequest")
    def client_cert_request(self) -> Optional[str]:
        """
        Action based on client certificate request. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "client_cert_request")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Action based on received client certificate. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="expiredServerCert")
    def expired_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is expired. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "expired_server_cert")

    @property
    @pulumi.getter(name="invalidServerCert")
    def invalid_server_cert(self) -> Optional[str]:
        """
        Allow or block the invalid SSL session server certificate. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "invalid_server_cert")

    @property
    @pulumi.getter(name="minAllowedSslVersion")
    def min_allowed_ssl_version(self) -> Optional[str]:
        """
        Minimum SSL version to be allowed. Valid values: `ssl-3.0`, `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "min_allowed_ssl_version")

    @property
    @pulumi.getter
    def ports(self) -> Optional[str]:
        """
        Ports to use for scanning (1 - 65535, default = 443).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="revokedServerCert")
    def revoked_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is revoked. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "revoked_server_cert")

    @property
    @pulumi.getter(name="sniServerCertCheck")
    def sni_server_cert_check(self) -> Optional[str]:
        """
        Check the SNI in the client hello message with the CN or SAN fields in the returned server certificate. Valid values: `enable`, `strict`, `disable`.
        """
        return pulumi.get(self, "sni_server_cert_check")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Configure protocol inspection status. Valid values: `disable`, `deep-inspection`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="unsupportedSsl")
    def unsupported_ssl(self) -> Optional[str]:
        """
        Action based on the SSL encryption used being unsupported. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl")

    @property
    @pulumi.getter(name="unsupportedSslCipher")
    def unsupported_ssl_cipher(self) -> Optional[str]:
        """
        Action based on the SSL cipher used being unsupported. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl_cipher")

    @property
    @pulumi.getter(name="unsupportedSslNegotiation")
    def unsupported_ssl_negotiation(self) -> Optional[str]:
        """
        Action based on the SSL negotiation used being unsupported. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl_negotiation")

    @property
    @pulumi.getter(name="unsupportedSslVersion")
    def unsupported_ssl_version(self) -> Optional[str]:
        """
        Action based on the SSL version used being unsupported.
        """
        return pulumi.get(self, "unsupported_ssl_version")

    @property
    @pulumi.getter(name="untrustedServerCert")
    def untrusted_server_cert(self) -> Optional[str]:
        """
        Allow, ignore, or block the untrusted SSL session server certificate. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "untrusted_server_cert")


@pulumi.output_type
class SslsshprofileHttps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certProbeFailure":
            suggest = "cert_probe_failure"
        elif key == "certValidationFailure":
            suggest = "cert_validation_failure"
        elif key == "certValidationTimeout":
            suggest = "cert_validation_timeout"
        elif key == "clientCertRequest":
            suggest = "client_cert_request"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "expiredServerCert":
            suggest = "expired_server_cert"
        elif key == "invalidServerCert":
            suggest = "invalid_server_cert"
        elif key == "minAllowedSslVersion":
            suggest = "min_allowed_ssl_version"
        elif key == "proxyAfterTcpHandshake":
            suggest = "proxy_after_tcp_handshake"
        elif key == "revokedServerCert":
            suggest = "revoked_server_cert"
        elif key == "sniServerCertCheck":
            suggest = "sni_server_cert_check"
        elif key == "unsupportedSsl":
            suggest = "unsupported_ssl"
        elif key == "unsupportedSslCipher":
            suggest = "unsupported_ssl_cipher"
        elif key == "unsupportedSslNegotiation":
            suggest = "unsupported_ssl_negotiation"
        elif key == "unsupportedSslVersion":
            suggest = "unsupported_ssl_version"
        elif key == "untrustedServerCert":
            suggest = "untrusted_server_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslsshprofileHttps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslsshprofileHttps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslsshprofileHttps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_probe_failure: Optional[str] = None,
                 cert_validation_failure: Optional[str] = None,
                 cert_validation_timeout: Optional[str] = None,
                 client_cert_request: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 expired_server_cert: Optional[str] = None,
                 invalid_server_cert: Optional[str] = None,
                 min_allowed_ssl_version: Optional[str] = None,
                 ports: Optional[str] = None,
                 proxy_after_tcp_handshake: Optional[str] = None,
                 quic: Optional[str] = None,
                 revoked_server_cert: Optional[str] = None,
                 sni_server_cert_check: Optional[str] = None,
                 status: Optional[str] = None,
                 unsupported_ssl: Optional[str] = None,
                 unsupported_ssl_cipher: Optional[str] = None,
                 unsupported_ssl_negotiation: Optional[str] = None,
                 unsupported_ssl_version: Optional[str] = None,
                 untrusted_server_cert: Optional[str] = None):
        """
        :param str cert_probe_failure: Action based on certificate probe failure. Valid values: `allow`, `block`.
        :param str cert_validation_failure: Action based on certificate validation failure. Valid values: `allow`, `block`, `ignore`.
        :param str cert_validation_timeout: Action based on certificate validation timeout. Valid values: `allow`, `block`, `ignore`.
        :param str client_cert_request: Action based on client certificate request. Valid values: `bypass`, `inspect`, `block`.
        :param str client_certificate: Action based on received client certificate. Valid values: `bypass`, `inspect`, `block`.
        :param str expired_server_cert: Action based on server certificate is expired. Valid values: `allow`, `block`, `ignore`.
        :param str invalid_server_cert: Allow or block the invalid SSL session server certificate. Valid values: `allow`, `block`.
        :param str min_allowed_ssl_version: Minimum SSL version to be allowed. Valid values: `ssl-3.0`, `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        :param str ports: Ports to use for scanning (1 - 65535, default = 443).
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        :param str quic: QUIC inspection status. On FortiOS versions 7.4.1: default = disable. On FortiOS versions >= 7.4.2: default = inspect.
        :param str revoked_server_cert: Action based on server certificate is revoked. Valid values: `allow`, `block`, `ignore`.
        :param str sni_server_cert_check: Check the SNI in the client hello message with the CN or SAN fields in the returned server certificate. Valid values: `enable`, `strict`, `disable`.
        :param str status: Configure protocol inspection status. Valid values: `disable`, `certificate-inspection`, `deep-inspection`.
        :param str unsupported_ssl: Action based on the SSL encryption used being unsupported. Valid values: `bypass`, `inspect`, `block`.
        :param str unsupported_ssl_cipher: Action based on the SSL cipher used being unsupported. Valid values: `allow`, `block`.
        :param str unsupported_ssl_negotiation: Action based on the SSL negotiation used being unsupported. Valid values: `allow`, `block`.
        :param str unsupported_ssl_version: Action based on the SSL version used being unsupported.
        :param str untrusted_server_cert: Allow, ignore, or block the untrusted SSL session server certificate. Valid values: `allow`, `block`, `ignore`.
        """
        if cert_probe_failure is not None:
            pulumi.set(__self__, "cert_probe_failure", cert_probe_failure)
        if cert_validation_failure is not None:
            pulumi.set(__self__, "cert_validation_failure", cert_validation_failure)
        if cert_validation_timeout is not None:
            pulumi.set(__self__, "cert_validation_timeout", cert_validation_timeout)
        if client_cert_request is not None:
            pulumi.set(__self__, "client_cert_request", client_cert_request)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if expired_server_cert is not None:
            pulumi.set(__self__, "expired_server_cert", expired_server_cert)
        if invalid_server_cert is not None:
            pulumi.set(__self__, "invalid_server_cert", invalid_server_cert)
        if min_allowed_ssl_version is not None:
            pulumi.set(__self__, "min_allowed_ssl_version", min_allowed_ssl_version)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if proxy_after_tcp_handshake is not None:
            pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        if quic is not None:
            pulumi.set(__self__, "quic", quic)
        if revoked_server_cert is not None:
            pulumi.set(__self__, "revoked_server_cert", revoked_server_cert)
        if sni_server_cert_check is not None:
            pulumi.set(__self__, "sni_server_cert_check", sni_server_cert_check)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if unsupported_ssl is not None:
            pulumi.set(__self__, "unsupported_ssl", unsupported_ssl)
        if unsupported_ssl_cipher is not None:
            pulumi.set(__self__, "unsupported_ssl_cipher", unsupported_ssl_cipher)
        if unsupported_ssl_negotiation is not None:
            pulumi.set(__self__, "unsupported_ssl_negotiation", unsupported_ssl_negotiation)
        if unsupported_ssl_version is not None:
            pulumi.set(__self__, "unsupported_ssl_version", unsupported_ssl_version)
        if untrusted_server_cert is not None:
            pulumi.set(__self__, "untrusted_server_cert", untrusted_server_cert)

    @property
    @pulumi.getter(name="certProbeFailure")
    def cert_probe_failure(self) -> Optional[str]:
        """
        Action based on certificate probe failure. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "cert_probe_failure")

    @property
    @pulumi.getter(name="certValidationFailure")
    def cert_validation_failure(self) -> Optional[str]:
        """
        Action based on certificate validation failure. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "cert_validation_failure")

    @property
    @pulumi.getter(name="certValidationTimeout")
    def cert_validation_timeout(self) -> Optional[str]:
        """
        Action based on certificate validation timeout. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "cert_validation_timeout")

    @property
    @pulumi.getter(name="clientCertRequest")
    def client_cert_request(self) -> Optional[str]:
        """
        Action based on client certificate request. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "client_cert_request")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Action based on received client certificate. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="expiredServerCert")
    def expired_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is expired. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "expired_server_cert")

    @property
    @pulumi.getter(name="invalidServerCert")
    def invalid_server_cert(self) -> Optional[str]:
        """
        Allow or block the invalid SSL session server certificate. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "invalid_server_cert")

    @property
    @pulumi.getter(name="minAllowedSslVersion")
    def min_allowed_ssl_version(self) -> Optional[str]:
        """
        Minimum SSL version to be allowed. Valid values: `ssl-3.0`, `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "min_allowed_ssl_version")

    @property
    @pulumi.getter
    def ports(self) -> Optional[str]:
        """
        Ports to use for scanning (1 - 65535, default = 443).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> Optional[str]:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter
    def quic(self) -> Optional[str]:
        """
        QUIC inspection status. On FortiOS versions 7.4.1: default = disable. On FortiOS versions >= 7.4.2: default = inspect.
        """
        return pulumi.get(self, "quic")

    @property
    @pulumi.getter(name="revokedServerCert")
    def revoked_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is revoked. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "revoked_server_cert")

    @property
    @pulumi.getter(name="sniServerCertCheck")
    def sni_server_cert_check(self) -> Optional[str]:
        """
        Check the SNI in the client hello message with the CN or SAN fields in the returned server certificate. Valid values: `enable`, `strict`, `disable`.
        """
        return pulumi.get(self, "sni_server_cert_check")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Configure protocol inspection status. Valid values: `disable`, `certificate-inspection`, `deep-inspection`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="unsupportedSsl")
    def unsupported_ssl(self) -> Optional[str]:
        """
        Action based on the SSL encryption used being unsupported. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl")

    @property
    @pulumi.getter(name="unsupportedSslCipher")
    def unsupported_ssl_cipher(self) -> Optional[str]:
        """
        Action based on the SSL cipher used being unsupported. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl_cipher")

    @property
    @pulumi.getter(name="unsupportedSslNegotiation")
    def unsupported_ssl_negotiation(self) -> Optional[str]:
        """
        Action based on the SSL negotiation used being unsupported. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl_negotiation")

    @property
    @pulumi.getter(name="unsupportedSslVersion")
    def unsupported_ssl_version(self) -> Optional[str]:
        """
        Action based on the SSL version used being unsupported.
        """
        return pulumi.get(self, "unsupported_ssl_version")

    @property
    @pulumi.getter(name="untrustedServerCert")
    def untrusted_server_cert(self) -> Optional[str]:
        """
        Allow, ignore, or block the untrusted SSL session server certificate. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "untrusted_server_cert")


@pulumi.output_type
class SslsshprofileImaps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certValidationFailure":
            suggest = "cert_validation_failure"
        elif key == "certValidationTimeout":
            suggest = "cert_validation_timeout"
        elif key == "clientCertRequest":
            suggest = "client_cert_request"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "expiredServerCert":
            suggest = "expired_server_cert"
        elif key == "invalidServerCert":
            suggest = "invalid_server_cert"
        elif key == "proxyAfterTcpHandshake":
            suggest = "proxy_after_tcp_handshake"
        elif key == "revokedServerCert":
            suggest = "revoked_server_cert"
        elif key == "sniServerCertCheck":
            suggest = "sni_server_cert_check"
        elif key == "unsupportedSsl":
            suggest = "unsupported_ssl"
        elif key == "unsupportedSslCipher":
            suggest = "unsupported_ssl_cipher"
        elif key == "unsupportedSslNegotiation":
            suggest = "unsupported_ssl_negotiation"
        elif key == "unsupportedSslVersion":
            suggest = "unsupported_ssl_version"
        elif key == "untrustedServerCert":
            suggest = "untrusted_server_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslsshprofileImaps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslsshprofileImaps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslsshprofileImaps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_validation_failure: Optional[str] = None,
                 cert_validation_timeout: Optional[str] = None,
                 client_cert_request: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 expired_server_cert: Optional[str] = None,
                 invalid_server_cert: Optional[str] = None,
                 ports: Optional[str] = None,
                 proxy_after_tcp_handshake: Optional[str] = None,
                 revoked_server_cert: Optional[str] = None,
                 sni_server_cert_check: Optional[str] = None,
                 status: Optional[str] = None,
                 unsupported_ssl: Optional[str] = None,
                 unsupported_ssl_cipher: Optional[str] = None,
                 unsupported_ssl_negotiation: Optional[str] = None,
                 unsupported_ssl_version: Optional[str] = None,
                 untrusted_server_cert: Optional[str] = None):
        """
        :param str cert_validation_failure: Action based on certificate validation failure. Valid values: `allow`, `block`, `ignore`.
        :param str cert_validation_timeout: Action based on certificate validation timeout. Valid values: `allow`, `block`, `ignore`.
        :param str client_cert_request: Action based on client certificate request. Valid values: `bypass`, `inspect`, `block`.
        :param str client_certificate: Action based on received client certificate. Valid values: `bypass`, `inspect`, `block`.
        :param str expired_server_cert: Action based on server certificate is expired. Valid values: `allow`, `block`, `ignore`.
        :param str invalid_server_cert: Allow or block the invalid SSL session server certificate. Valid values: `allow`, `block`.
        :param str ports: Ports to use for scanning (1 - 65535, default = 443).
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        :param str revoked_server_cert: Action based on server certificate is revoked. Valid values: `allow`, `block`, `ignore`.
        :param str sni_server_cert_check: Check the SNI in the client hello message with the CN or SAN fields in the returned server certificate. Valid values: `enable`, `strict`, `disable`.
        :param str status: Configure protocol inspection status. Valid values: `disable`, `deep-inspection`.
        :param str unsupported_ssl: Action based on the SSL encryption used being unsupported. Valid values: `bypass`, `inspect`, `block`.
        :param str unsupported_ssl_cipher: Action based on the SSL cipher used being unsupported. Valid values: `allow`, `block`.
        :param str unsupported_ssl_negotiation: Action based on the SSL negotiation used being unsupported. Valid values: `allow`, `block`.
        :param str unsupported_ssl_version: Action based on the SSL version used being unsupported.
        :param str untrusted_server_cert: Allow, ignore, or block the untrusted SSL session server certificate. Valid values: `allow`, `block`, `ignore`.
        """
        if cert_validation_failure is not None:
            pulumi.set(__self__, "cert_validation_failure", cert_validation_failure)
        if cert_validation_timeout is not None:
            pulumi.set(__self__, "cert_validation_timeout", cert_validation_timeout)
        if client_cert_request is not None:
            pulumi.set(__self__, "client_cert_request", client_cert_request)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if expired_server_cert is not None:
            pulumi.set(__self__, "expired_server_cert", expired_server_cert)
        if invalid_server_cert is not None:
            pulumi.set(__self__, "invalid_server_cert", invalid_server_cert)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if proxy_after_tcp_handshake is not None:
            pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        if revoked_server_cert is not None:
            pulumi.set(__self__, "revoked_server_cert", revoked_server_cert)
        if sni_server_cert_check is not None:
            pulumi.set(__self__, "sni_server_cert_check", sni_server_cert_check)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if unsupported_ssl is not None:
            pulumi.set(__self__, "unsupported_ssl", unsupported_ssl)
        if unsupported_ssl_cipher is not None:
            pulumi.set(__self__, "unsupported_ssl_cipher", unsupported_ssl_cipher)
        if unsupported_ssl_negotiation is not None:
            pulumi.set(__self__, "unsupported_ssl_negotiation", unsupported_ssl_negotiation)
        if unsupported_ssl_version is not None:
            pulumi.set(__self__, "unsupported_ssl_version", unsupported_ssl_version)
        if untrusted_server_cert is not None:
            pulumi.set(__self__, "untrusted_server_cert", untrusted_server_cert)

    @property
    @pulumi.getter(name="certValidationFailure")
    def cert_validation_failure(self) -> Optional[str]:
        """
        Action based on certificate validation failure. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "cert_validation_failure")

    @property
    @pulumi.getter(name="certValidationTimeout")
    def cert_validation_timeout(self) -> Optional[str]:
        """
        Action based on certificate validation timeout. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "cert_validation_timeout")

    @property
    @pulumi.getter(name="clientCertRequest")
    def client_cert_request(self) -> Optional[str]:
        """
        Action based on client certificate request. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "client_cert_request")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Action based on received client certificate. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="expiredServerCert")
    def expired_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is expired. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "expired_server_cert")

    @property
    @pulumi.getter(name="invalidServerCert")
    def invalid_server_cert(self) -> Optional[str]:
        """
        Allow or block the invalid SSL session server certificate. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "invalid_server_cert")

    @property
    @pulumi.getter
    def ports(self) -> Optional[str]:
        """
        Ports to use for scanning (1 - 65535, default = 443).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> Optional[str]:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter(name="revokedServerCert")
    def revoked_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is revoked. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "revoked_server_cert")

    @property
    @pulumi.getter(name="sniServerCertCheck")
    def sni_server_cert_check(self) -> Optional[str]:
        """
        Check the SNI in the client hello message with the CN or SAN fields in the returned server certificate. Valid values: `enable`, `strict`, `disable`.
        """
        return pulumi.get(self, "sni_server_cert_check")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Configure protocol inspection status. Valid values: `disable`, `deep-inspection`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="unsupportedSsl")
    def unsupported_ssl(self) -> Optional[str]:
        """
        Action based on the SSL encryption used being unsupported. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl")

    @property
    @pulumi.getter(name="unsupportedSslCipher")
    def unsupported_ssl_cipher(self) -> Optional[str]:
        """
        Action based on the SSL cipher used being unsupported. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl_cipher")

    @property
    @pulumi.getter(name="unsupportedSslNegotiation")
    def unsupported_ssl_negotiation(self) -> Optional[str]:
        """
        Action based on the SSL negotiation used being unsupported. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl_negotiation")

    @property
    @pulumi.getter(name="unsupportedSslVersion")
    def unsupported_ssl_version(self) -> Optional[str]:
        """
        Action based on the SSL version used being unsupported.
        """
        return pulumi.get(self, "unsupported_ssl_version")

    @property
    @pulumi.getter(name="untrustedServerCert")
    def untrusted_server_cert(self) -> Optional[str]:
        """
        Allow, ignore, or block the untrusted SSL session server certificate. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "untrusted_server_cert")


@pulumi.output_type
class SslsshprofilePop3s(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certValidationFailure":
            suggest = "cert_validation_failure"
        elif key == "certValidationTimeout":
            suggest = "cert_validation_timeout"
        elif key == "clientCertRequest":
            suggest = "client_cert_request"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "expiredServerCert":
            suggest = "expired_server_cert"
        elif key == "invalidServerCert":
            suggest = "invalid_server_cert"
        elif key == "proxyAfterTcpHandshake":
            suggest = "proxy_after_tcp_handshake"
        elif key == "revokedServerCert":
            suggest = "revoked_server_cert"
        elif key == "sniServerCertCheck":
            suggest = "sni_server_cert_check"
        elif key == "unsupportedSsl":
            suggest = "unsupported_ssl"
        elif key == "unsupportedSslCipher":
            suggest = "unsupported_ssl_cipher"
        elif key == "unsupportedSslNegotiation":
            suggest = "unsupported_ssl_negotiation"
        elif key == "unsupportedSslVersion":
            suggest = "unsupported_ssl_version"
        elif key == "untrustedServerCert":
            suggest = "untrusted_server_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslsshprofilePop3s. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslsshprofilePop3s.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslsshprofilePop3s.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_validation_failure: Optional[str] = None,
                 cert_validation_timeout: Optional[str] = None,
                 client_cert_request: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 expired_server_cert: Optional[str] = None,
                 invalid_server_cert: Optional[str] = None,
                 ports: Optional[str] = None,
                 proxy_after_tcp_handshake: Optional[str] = None,
                 revoked_server_cert: Optional[str] = None,
                 sni_server_cert_check: Optional[str] = None,
                 status: Optional[str] = None,
                 unsupported_ssl: Optional[str] = None,
                 unsupported_ssl_cipher: Optional[str] = None,
                 unsupported_ssl_negotiation: Optional[str] = None,
                 unsupported_ssl_version: Optional[str] = None,
                 untrusted_server_cert: Optional[str] = None):
        """
        :param str cert_validation_failure: Action based on certificate validation failure. Valid values: `allow`, `block`, `ignore`.
        :param str cert_validation_timeout: Action based on certificate validation timeout. Valid values: `allow`, `block`, `ignore`.
        :param str client_cert_request: Action based on client certificate request. Valid values: `bypass`, `inspect`, `block`.
        :param str client_certificate: Action based on received client certificate. Valid values: `bypass`, `inspect`, `block`.
        :param str expired_server_cert: Action based on server certificate is expired. Valid values: `allow`, `block`, `ignore`.
        :param str invalid_server_cert: Allow or block the invalid SSL session server certificate. Valid values: `allow`, `block`.
        :param str ports: Ports to use for scanning (1 - 65535, default = 443).
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        :param str revoked_server_cert: Action based on server certificate is revoked. Valid values: `allow`, `block`, `ignore`.
        :param str sni_server_cert_check: Check the SNI in the client hello message with the CN or SAN fields in the returned server certificate. Valid values: `enable`, `strict`, `disable`.
        :param str status: Configure protocol inspection status. Valid values: `disable`, `deep-inspection`.
        :param str unsupported_ssl: Action based on the SSL encryption used being unsupported. Valid values: `bypass`, `inspect`, `block`.
        :param str unsupported_ssl_cipher: Action based on the SSL cipher used being unsupported. Valid values: `allow`, `block`.
        :param str unsupported_ssl_negotiation: Action based on the SSL negotiation used being unsupported. Valid values: `allow`, `block`.
        :param str unsupported_ssl_version: Action based on the SSL version used being unsupported.
        :param str untrusted_server_cert: Action based on server certificate is not issued by a trusted CA. Valid values: `allow`, `block`, `ignore`.
        """
        if cert_validation_failure is not None:
            pulumi.set(__self__, "cert_validation_failure", cert_validation_failure)
        if cert_validation_timeout is not None:
            pulumi.set(__self__, "cert_validation_timeout", cert_validation_timeout)
        if client_cert_request is not None:
            pulumi.set(__self__, "client_cert_request", client_cert_request)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if expired_server_cert is not None:
            pulumi.set(__self__, "expired_server_cert", expired_server_cert)
        if invalid_server_cert is not None:
            pulumi.set(__self__, "invalid_server_cert", invalid_server_cert)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if proxy_after_tcp_handshake is not None:
            pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        if revoked_server_cert is not None:
            pulumi.set(__self__, "revoked_server_cert", revoked_server_cert)
        if sni_server_cert_check is not None:
            pulumi.set(__self__, "sni_server_cert_check", sni_server_cert_check)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if unsupported_ssl is not None:
            pulumi.set(__self__, "unsupported_ssl", unsupported_ssl)
        if unsupported_ssl_cipher is not None:
            pulumi.set(__self__, "unsupported_ssl_cipher", unsupported_ssl_cipher)
        if unsupported_ssl_negotiation is not None:
            pulumi.set(__self__, "unsupported_ssl_negotiation", unsupported_ssl_negotiation)
        if unsupported_ssl_version is not None:
            pulumi.set(__self__, "unsupported_ssl_version", unsupported_ssl_version)
        if untrusted_server_cert is not None:
            pulumi.set(__self__, "untrusted_server_cert", untrusted_server_cert)

    @property
    @pulumi.getter(name="certValidationFailure")
    def cert_validation_failure(self) -> Optional[str]:
        """
        Action based on certificate validation failure. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "cert_validation_failure")

    @property
    @pulumi.getter(name="certValidationTimeout")
    def cert_validation_timeout(self) -> Optional[str]:
        """
        Action based on certificate validation timeout. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "cert_validation_timeout")

    @property
    @pulumi.getter(name="clientCertRequest")
    def client_cert_request(self) -> Optional[str]:
        """
        Action based on client certificate request. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "client_cert_request")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Action based on received client certificate. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="expiredServerCert")
    def expired_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is expired. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "expired_server_cert")

    @property
    @pulumi.getter(name="invalidServerCert")
    def invalid_server_cert(self) -> Optional[str]:
        """
        Allow or block the invalid SSL session server certificate. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "invalid_server_cert")

    @property
    @pulumi.getter
    def ports(self) -> Optional[str]:
        """
        Ports to use for scanning (1 - 65535, default = 443).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> Optional[str]:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter(name="revokedServerCert")
    def revoked_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is revoked. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "revoked_server_cert")

    @property
    @pulumi.getter(name="sniServerCertCheck")
    def sni_server_cert_check(self) -> Optional[str]:
        """
        Check the SNI in the client hello message with the CN or SAN fields in the returned server certificate. Valid values: `enable`, `strict`, `disable`.
        """
        return pulumi.get(self, "sni_server_cert_check")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Configure protocol inspection status. Valid values: `disable`, `deep-inspection`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="unsupportedSsl")
    def unsupported_ssl(self) -> Optional[str]:
        """
        Action based on the SSL encryption used being unsupported. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl")

    @property
    @pulumi.getter(name="unsupportedSslCipher")
    def unsupported_ssl_cipher(self) -> Optional[str]:
        """
        Action based on the SSL cipher used being unsupported. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl_cipher")

    @property
    @pulumi.getter(name="unsupportedSslNegotiation")
    def unsupported_ssl_negotiation(self) -> Optional[str]:
        """
        Action based on the SSL negotiation used being unsupported. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl_negotiation")

    @property
    @pulumi.getter(name="unsupportedSslVersion")
    def unsupported_ssl_version(self) -> Optional[str]:
        """
        Action based on the SSL version used being unsupported.
        """
        return pulumi.get(self, "unsupported_ssl_version")

    @property
    @pulumi.getter(name="untrustedServerCert")
    def untrusted_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is not issued by a trusted CA. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "untrusted_server_cert")


@pulumi.output_type
class SslsshprofileSmtps(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certValidationFailure":
            suggest = "cert_validation_failure"
        elif key == "certValidationTimeout":
            suggest = "cert_validation_timeout"
        elif key == "clientCertRequest":
            suggest = "client_cert_request"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "expiredServerCert":
            suggest = "expired_server_cert"
        elif key == "invalidServerCert":
            suggest = "invalid_server_cert"
        elif key == "proxyAfterTcpHandshake":
            suggest = "proxy_after_tcp_handshake"
        elif key == "revokedServerCert":
            suggest = "revoked_server_cert"
        elif key == "sniServerCertCheck":
            suggest = "sni_server_cert_check"
        elif key == "unsupportedSsl":
            suggest = "unsupported_ssl"
        elif key == "unsupportedSslCipher":
            suggest = "unsupported_ssl_cipher"
        elif key == "unsupportedSslNegotiation":
            suggest = "unsupported_ssl_negotiation"
        elif key == "unsupportedSslVersion":
            suggest = "unsupported_ssl_version"
        elif key == "untrustedServerCert":
            suggest = "untrusted_server_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslsshprofileSmtps. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslsshprofileSmtps.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslsshprofileSmtps.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_validation_failure: Optional[str] = None,
                 cert_validation_timeout: Optional[str] = None,
                 client_cert_request: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 expired_server_cert: Optional[str] = None,
                 invalid_server_cert: Optional[str] = None,
                 ports: Optional[str] = None,
                 proxy_after_tcp_handshake: Optional[str] = None,
                 revoked_server_cert: Optional[str] = None,
                 sni_server_cert_check: Optional[str] = None,
                 status: Optional[str] = None,
                 unsupported_ssl: Optional[str] = None,
                 unsupported_ssl_cipher: Optional[str] = None,
                 unsupported_ssl_negotiation: Optional[str] = None,
                 unsupported_ssl_version: Optional[str] = None,
                 untrusted_server_cert: Optional[str] = None):
        """
        :param str cert_validation_failure: Action based on certificate validation failure. Valid values: `allow`, `block`, `ignore`.
        :param str cert_validation_timeout: Action based on certificate validation timeout. Valid values: `allow`, `block`, `ignore`.
        :param str client_cert_request: Action based on client certificate request. Valid values: `bypass`, `inspect`, `block`.
        :param str client_certificate: Action based on received client certificate. Valid values: `bypass`, `inspect`, `block`.
        :param str expired_server_cert: Action based on server certificate is expired. Valid values: `allow`, `block`, `ignore`.
        :param str invalid_server_cert: Allow or block the invalid SSL session server certificate. Valid values: `allow`, `block`.
        :param str ports: Ports to use for scanning (1 - 65535, default = 443).
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        :param str revoked_server_cert: Action based on server certificate is revoked. Valid values: `allow`, `block`, `ignore`.
        :param str sni_server_cert_check: Check the SNI in the client hello message with the CN or SAN fields in the returned server certificate. Valid values: `enable`, `strict`, `disable`.
        :param str status: Configure protocol inspection status. Valid values: `disable`, `deep-inspection`.
        :param str unsupported_ssl: Action based on the SSL encryption used being unsupported. Valid values: `bypass`, `inspect`, `block`.
        :param str unsupported_ssl_cipher: Action based on the SSL cipher used being unsupported. Valid values: `allow`, `block`.
        :param str unsupported_ssl_negotiation: Action based on the SSL negotiation used being unsupported. Valid values: `allow`, `block`.
        :param str unsupported_ssl_version: Action based on the SSL version used being unsupported.
        :param str untrusted_server_cert: Allow, ignore, or block the untrusted SSL session server certificate. Valid values: `allow`, `block`, `ignore`.
        """
        if cert_validation_failure is not None:
            pulumi.set(__self__, "cert_validation_failure", cert_validation_failure)
        if cert_validation_timeout is not None:
            pulumi.set(__self__, "cert_validation_timeout", cert_validation_timeout)
        if client_cert_request is not None:
            pulumi.set(__self__, "client_cert_request", client_cert_request)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if expired_server_cert is not None:
            pulumi.set(__self__, "expired_server_cert", expired_server_cert)
        if invalid_server_cert is not None:
            pulumi.set(__self__, "invalid_server_cert", invalid_server_cert)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if proxy_after_tcp_handshake is not None:
            pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        if revoked_server_cert is not None:
            pulumi.set(__self__, "revoked_server_cert", revoked_server_cert)
        if sni_server_cert_check is not None:
            pulumi.set(__self__, "sni_server_cert_check", sni_server_cert_check)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if unsupported_ssl is not None:
            pulumi.set(__self__, "unsupported_ssl", unsupported_ssl)
        if unsupported_ssl_cipher is not None:
            pulumi.set(__self__, "unsupported_ssl_cipher", unsupported_ssl_cipher)
        if unsupported_ssl_negotiation is not None:
            pulumi.set(__self__, "unsupported_ssl_negotiation", unsupported_ssl_negotiation)
        if unsupported_ssl_version is not None:
            pulumi.set(__self__, "unsupported_ssl_version", unsupported_ssl_version)
        if untrusted_server_cert is not None:
            pulumi.set(__self__, "untrusted_server_cert", untrusted_server_cert)

    @property
    @pulumi.getter(name="certValidationFailure")
    def cert_validation_failure(self) -> Optional[str]:
        """
        Action based on certificate validation failure. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "cert_validation_failure")

    @property
    @pulumi.getter(name="certValidationTimeout")
    def cert_validation_timeout(self) -> Optional[str]:
        """
        Action based on certificate validation timeout. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "cert_validation_timeout")

    @property
    @pulumi.getter(name="clientCertRequest")
    def client_cert_request(self) -> Optional[str]:
        """
        Action based on client certificate request. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "client_cert_request")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Action based on received client certificate. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="expiredServerCert")
    def expired_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is expired. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "expired_server_cert")

    @property
    @pulumi.getter(name="invalidServerCert")
    def invalid_server_cert(self) -> Optional[str]:
        """
        Allow or block the invalid SSL session server certificate. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "invalid_server_cert")

    @property
    @pulumi.getter
    def ports(self) -> Optional[str]:
        """
        Ports to use for scanning (1 - 65535, default = 443).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> Optional[str]:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter(name="revokedServerCert")
    def revoked_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is revoked. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "revoked_server_cert")

    @property
    @pulumi.getter(name="sniServerCertCheck")
    def sni_server_cert_check(self) -> Optional[str]:
        """
        Check the SNI in the client hello message with the CN or SAN fields in the returned server certificate. Valid values: `enable`, `strict`, `disable`.
        """
        return pulumi.get(self, "sni_server_cert_check")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Configure protocol inspection status. Valid values: `disable`, `deep-inspection`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="unsupportedSsl")
    def unsupported_ssl(self) -> Optional[str]:
        """
        Action based on the SSL encryption used being unsupported. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl")

    @property
    @pulumi.getter(name="unsupportedSslCipher")
    def unsupported_ssl_cipher(self) -> Optional[str]:
        """
        Action based on the SSL cipher used being unsupported. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl_cipher")

    @property
    @pulumi.getter(name="unsupportedSslNegotiation")
    def unsupported_ssl_negotiation(self) -> Optional[str]:
        """
        Action based on the SSL negotiation used being unsupported. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl_negotiation")

    @property
    @pulumi.getter(name="unsupportedSslVersion")
    def unsupported_ssl_version(self) -> Optional[str]:
        """
        Action based on the SSL version used being unsupported.
        """
        return pulumi.get(self, "unsupported_ssl_version")

    @property
    @pulumi.getter(name="untrustedServerCert")
    def untrusted_server_cert(self) -> Optional[str]:
        """
        Allow, ignore, or block the untrusted SSL session server certificate. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "untrusted_server_cert")


@pulumi.output_type
class SslsshprofileSsh(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inspectAll":
            suggest = "inspect_all"
        elif key == "proxyAfterTcpHandshake":
            suggest = "proxy_after_tcp_handshake"
        elif key == "sshAlgorithm":
            suggest = "ssh_algorithm"
        elif key == "sshPolicyCheck":
            suggest = "ssh_policy_check"
        elif key == "sshTunPolicyCheck":
            suggest = "ssh_tun_policy_check"
        elif key == "unsupportedVersion":
            suggest = "unsupported_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslsshprofileSsh. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslsshprofileSsh.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslsshprofileSsh.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 inspect_all: Optional[str] = None,
                 ports: Optional[str] = None,
                 proxy_after_tcp_handshake: Optional[str] = None,
                 ssh_algorithm: Optional[str] = None,
                 ssh_policy_check: Optional[str] = None,
                 ssh_tun_policy_check: Optional[str] = None,
                 status: Optional[str] = None,
                 unsupported_version: Optional[str] = None):
        """
        :param str inspect_all: Level of SSL inspection. Valid values: `disable`, `deep-inspection`.
        :param str ports: Ports to use for scanning (1 - 65535, default = 443).
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        :param str ssh_algorithm: Relative strength of encryption algorithms accepted during negotiation. Valid values: `compatible`, `high-encryption`.
        :param str ssh_policy_check: Enable/disable SSH policy check. Valid values: `disable`, `enable`.
        :param str ssh_tun_policy_check: Enable/disable SSH tunnel policy check. Valid values: `disable`, `enable`.
        :param str status: Configure protocol inspection status. Valid values: `disable`, `deep-inspection`.
        :param str unsupported_version: Action based on SSH version being unsupported. Valid values: `bypass`, `block`.
        """
        if inspect_all is not None:
            pulumi.set(__self__, "inspect_all", inspect_all)
        if ports is not None:
            pulumi.set(__self__, "ports", ports)
        if proxy_after_tcp_handshake is not None:
            pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        if ssh_algorithm is not None:
            pulumi.set(__self__, "ssh_algorithm", ssh_algorithm)
        if ssh_policy_check is not None:
            pulumi.set(__self__, "ssh_policy_check", ssh_policy_check)
        if ssh_tun_policy_check is not None:
            pulumi.set(__self__, "ssh_tun_policy_check", ssh_tun_policy_check)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if unsupported_version is not None:
            pulumi.set(__self__, "unsupported_version", unsupported_version)

    @property
    @pulumi.getter(name="inspectAll")
    def inspect_all(self) -> Optional[str]:
        """
        Level of SSL inspection. Valid values: `disable`, `deep-inspection`.
        """
        return pulumi.get(self, "inspect_all")

    @property
    @pulumi.getter
    def ports(self) -> Optional[str]:
        """
        Ports to use for scanning (1 - 65535, default = 443).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> Optional[str]:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter(name="sshAlgorithm")
    def ssh_algorithm(self) -> Optional[str]:
        """
        Relative strength of encryption algorithms accepted during negotiation. Valid values: `compatible`, `high-encryption`.
        """
        return pulumi.get(self, "ssh_algorithm")

    @property
    @pulumi.getter(name="sshPolicyCheck")
    def ssh_policy_check(self) -> Optional[str]:
        """
        Enable/disable SSH policy check. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "ssh_policy_check")

    @property
    @pulumi.getter(name="sshTunPolicyCheck")
    def ssh_tun_policy_check(self) -> Optional[str]:
        """
        Enable/disable SSH tunnel policy check. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "ssh_tun_policy_check")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Configure protocol inspection status. Valid values: `disable`, `deep-inspection`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="unsupportedVersion")
    def unsupported_version(self) -> Optional[str]:
        """
        Action based on SSH version being unsupported. Valid values: `bypass`, `block`.
        """
        return pulumi.get(self, "unsupported_version")


@pulumi.output_type
class SslsshprofileSsl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certProbeFailure":
            suggest = "cert_probe_failure"
        elif key == "certValidationFailure":
            suggest = "cert_validation_failure"
        elif key == "certValidationTimeout":
            suggest = "cert_validation_timeout"
        elif key == "clientCertRequest":
            suggest = "client_cert_request"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "expiredServerCert":
            suggest = "expired_server_cert"
        elif key == "inspectAll":
            suggest = "inspect_all"
        elif key == "invalidServerCert":
            suggest = "invalid_server_cert"
        elif key == "minAllowedSslVersion":
            suggest = "min_allowed_ssl_version"
        elif key == "revokedServerCert":
            suggest = "revoked_server_cert"
        elif key == "sniServerCertCheck":
            suggest = "sni_server_cert_check"
        elif key == "unsupportedSsl":
            suggest = "unsupported_ssl"
        elif key == "unsupportedSslCipher":
            suggest = "unsupported_ssl_cipher"
        elif key == "unsupportedSslNegotiation":
            suggest = "unsupported_ssl_negotiation"
        elif key == "unsupportedSslVersion":
            suggest = "unsupported_ssl_version"
        elif key == "untrustedServerCert":
            suggest = "untrusted_server_cert"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslsshprofileSsl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslsshprofileSsl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslsshprofileSsl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert_probe_failure: Optional[str] = None,
                 cert_validation_failure: Optional[str] = None,
                 cert_validation_timeout: Optional[str] = None,
                 client_cert_request: Optional[str] = None,
                 client_certificate: Optional[str] = None,
                 expired_server_cert: Optional[str] = None,
                 inspect_all: Optional[str] = None,
                 invalid_server_cert: Optional[str] = None,
                 min_allowed_ssl_version: Optional[str] = None,
                 revoked_server_cert: Optional[str] = None,
                 sni_server_cert_check: Optional[str] = None,
                 unsupported_ssl: Optional[str] = None,
                 unsupported_ssl_cipher: Optional[str] = None,
                 unsupported_ssl_negotiation: Optional[str] = None,
                 unsupported_ssl_version: Optional[str] = None,
                 untrusted_server_cert: Optional[str] = None):
        """
        :param str cert_probe_failure: Action based on certificate probe failure. Valid values: `allow`, `block`.
        :param str cert_validation_failure: Action based on certificate validation failure. Valid values: `allow`, `block`, `ignore`.
        :param str cert_validation_timeout: Action based on certificate validation timeout. Valid values: `allow`, `block`, `ignore`.
        :param str client_cert_request: Action based on client certificate request. Valid values: `bypass`, `inspect`, `block`.
        :param str client_certificate: Action based on received client certificate. Valid values: `bypass`, `inspect`, `block`.
        :param str expired_server_cert: Action based on server certificate is expired. Valid values: `allow`, `block`, `ignore`.
        :param str inspect_all: Level of SSL inspection. Valid values: `disable`, `certificate-inspection`, `deep-inspection`.
        :param str invalid_server_cert: Allow or block the invalid SSL session server certificate. Valid values: `allow`, `block`.
        :param str min_allowed_ssl_version: Minimum SSL version to be allowed. Valid values: `ssl-3.0`, `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        :param str revoked_server_cert: Action based on server certificate is revoked. Valid values: `allow`, `block`, `ignore`.
        :param str sni_server_cert_check: Check the SNI in the client hello message with the CN or SAN fields in the returned server certificate. Valid values: `enable`, `strict`, `disable`.
        :param str unsupported_ssl: Action based on the SSL encryption used being unsupported. Valid values: `bypass`, `inspect`, `block`.
        :param str unsupported_ssl_cipher: Action based on the SSL cipher used being unsupported. Valid values: `allow`, `block`.
        :param str unsupported_ssl_negotiation: Action based on the SSL negotiation used being unsupported. Valid values: `allow`, `block`.
        :param str unsupported_ssl_version: Action based on the SSL version used being unsupported.
        :param str untrusted_server_cert: Allow, ignore, or block the untrusted SSL session server certificate. Valid values: `allow`, `block`, `ignore`.
        """
        if cert_probe_failure is not None:
            pulumi.set(__self__, "cert_probe_failure", cert_probe_failure)
        if cert_validation_failure is not None:
            pulumi.set(__self__, "cert_validation_failure", cert_validation_failure)
        if cert_validation_timeout is not None:
            pulumi.set(__self__, "cert_validation_timeout", cert_validation_timeout)
        if client_cert_request is not None:
            pulumi.set(__self__, "client_cert_request", client_cert_request)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if expired_server_cert is not None:
            pulumi.set(__self__, "expired_server_cert", expired_server_cert)
        if inspect_all is not None:
            pulumi.set(__self__, "inspect_all", inspect_all)
        if invalid_server_cert is not None:
            pulumi.set(__self__, "invalid_server_cert", invalid_server_cert)
        if min_allowed_ssl_version is not None:
            pulumi.set(__self__, "min_allowed_ssl_version", min_allowed_ssl_version)
        if revoked_server_cert is not None:
            pulumi.set(__self__, "revoked_server_cert", revoked_server_cert)
        if sni_server_cert_check is not None:
            pulumi.set(__self__, "sni_server_cert_check", sni_server_cert_check)
        if unsupported_ssl is not None:
            pulumi.set(__self__, "unsupported_ssl", unsupported_ssl)
        if unsupported_ssl_cipher is not None:
            pulumi.set(__self__, "unsupported_ssl_cipher", unsupported_ssl_cipher)
        if unsupported_ssl_negotiation is not None:
            pulumi.set(__self__, "unsupported_ssl_negotiation", unsupported_ssl_negotiation)
        if unsupported_ssl_version is not None:
            pulumi.set(__self__, "unsupported_ssl_version", unsupported_ssl_version)
        if untrusted_server_cert is not None:
            pulumi.set(__self__, "untrusted_server_cert", untrusted_server_cert)

    @property
    @pulumi.getter(name="certProbeFailure")
    def cert_probe_failure(self) -> Optional[str]:
        """
        Action based on certificate probe failure. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "cert_probe_failure")

    @property
    @pulumi.getter(name="certValidationFailure")
    def cert_validation_failure(self) -> Optional[str]:
        """
        Action based on certificate validation failure. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "cert_validation_failure")

    @property
    @pulumi.getter(name="certValidationTimeout")
    def cert_validation_timeout(self) -> Optional[str]:
        """
        Action based on certificate validation timeout. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "cert_validation_timeout")

    @property
    @pulumi.getter(name="clientCertRequest")
    def client_cert_request(self) -> Optional[str]:
        """
        Action based on client certificate request. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "client_cert_request")

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[str]:
        """
        Action based on received client certificate. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "client_certificate")

    @property
    @pulumi.getter(name="expiredServerCert")
    def expired_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is expired. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "expired_server_cert")

    @property
    @pulumi.getter(name="inspectAll")
    def inspect_all(self) -> Optional[str]:
        """
        Level of SSL inspection. Valid values: `disable`, `certificate-inspection`, `deep-inspection`.
        """
        return pulumi.get(self, "inspect_all")

    @property
    @pulumi.getter(name="invalidServerCert")
    def invalid_server_cert(self) -> Optional[str]:
        """
        Allow or block the invalid SSL session server certificate. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "invalid_server_cert")

    @property
    @pulumi.getter(name="minAllowedSslVersion")
    def min_allowed_ssl_version(self) -> Optional[str]:
        """
        Minimum SSL version to be allowed. Valid values: `ssl-3.0`, `tls-1.0`, `tls-1.1`, `tls-1.2`, `tls-1.3`.
        """
        return pulumi.get(self, "min_allowed_ssl_version")

    @property
    @pulumi.getter(name="revokedServerCert")
    def revoked_server_cert(self) -> Optional[str]:
        """
        Action based on server certificate is revoked. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "revoked_server_cert")

    @property
    @pulumi.getter(name="sniServerCertCheck")
    def sni_server_cert_check(self) -> Optional[str]:
        """
        Check the SNI in the client hello message with the CN or SAN fields in the returned server certificate. Valid values: `enable`, `strict`, `disable`.
        """
        return pulumi.get(self, "sni_server_cert_check")

    @property
    @pulumi.getter(name="unsupportedSsl")
    def unsupported_ssl(self) -> Optional[str]:
        """
        Action based on the SSL encryption used being unsupported. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl")

    @property
    @pulumi.getter(name="unsupportedSslCipher")
    def unsupported_ssl_cipher(self) -> Optional[str]:
        """
        Action based on the SSL cipher used being unsupported. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl_cipher")

    @property
    @pulumi.getter(name="unsupportedSslNegotiation")
    def unsupported_ssl_negotiation(self) -> Optional[str]:
        """
        Action based on the SSL negotiation used being unsupported. Valid values: `allow`, `block`.
        """
        return pulumi.get(self, "unsupported_ssl_negotiation")

    @property
    @pulumi.getter(name="unsupportedSslVersion")
    def unsupported_ssl_version(self) -> Optional[str]:
        """
        Action based on the SSL version used being unsupported.
        """
        return pulumi.get(self, "unsupported_ssl_version")

    @property
    @pulumi.getter(name="untrustedServerCert")
    def untrusted_server_cert(self) -> Optional[str]:
        """
        Allow, ignore, or block the untrusted SSL session server certificate. Valid values: `allow`, `block`, `ignore`.
        """
        return pulumi.get(self, "untrusted_server_cert")


@pulumi.output_type
class SslsshprofileSslExempt(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fortiguardCategory":
            suggest = "fortiguard_category"
        elif key == "wildcardFqdn":
            suggest = "wildcard_fqdn"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslsshprofileSslExempt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslsshprofileSslExempt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslsshprofileSslExempt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 address6: Optional[str] = None,
                 fortiguard_category: Optional[int] = None,
                 id: Optional[int] = None,
                 regex: Optional[str] = None,
                 type: Optional[str] = None,
                 wildcard_fqdn: Optional[str] = None):
        """
        :param str address: IPv4 address object.
        :param str address6: IPv6 address object.
        :param int fortiguard_category: FortiGuard category ID.
        :param int id: ID number.
        :param str regex: Exempt servers by regular expression.
        :param str type: Type of address object (IPv4 or IPv6) or FortiGuard category. Valid values: `fortiguard-category`, `address`, `address6`, `wildcard-fqdn`, `regex`.
        :param str wildcard_fqdn: Exempt servers by wildcard FQDN.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if address6 is not None:
            pulumi.set(__self__, "address6", address6)
        if fortiguard_category is not None:
            pulumi.set(__self__, "fortiguard_category", fortiguard_category)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wildcard_fqdn is not None:
            pulumi.set(__self__, "wildcard_fqdn", wildcard_fqdn)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        IPv4 address object.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def address6(self) -> Optional[str]:
        """
        IPv6 address object.
        """
        return pulumi.get(self, "address6")

    @property
    @pulumi.getter(name="fortiguardCategory")
    def fortiguard_category(self) -> Optional[int]:
        """
        FortiGuard category ID.
        """
        return pulumi.get(self, "fortiguard_category")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        ID number.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def regex(self) -> Optional[str]:
        """
        Exempt servers by regular expression.
        """
        return pulumi.get(self, "regex")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of address object (IPv4 or IPv6) or FortiGuard category. Valid values: `fortiguard-category`, `address`, `address6`, `wildcard-fqdn`, `regex`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="wildcardFqdn")
    def wildcard_fqdn(self) -> Optional[str]:
        """
        Exempt servers by wildcard FQDN.
        """
        return pulumi.get(self, "wildcard_fqdn")


@pulumi.output_type
class SslsshprofileSslServer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ftpsClientCertRequest":
            suggest = "ftps_client_cert_request"
        elif key == "ftpsClientCertificate":
            suggest = "ftps_client_certificate"
        elif key == "httpsClientCertRequest":
            suggest = "https_client_cert_request"
        elif key == "httpsClientCertificate":
            suggest = "https_client_certificate"
        elif key == "imapsClientCertRequest":
            suggest = "imaps_client_cert_request"
        elif key == "imapsClientCertificate":
            suggest = "imaps_client_certificate"
        elif key == "pop3sClientCertRequest":
            suggest = "pop3s_client_cert_request"
        elif key == "pop3sClientCertificate":
            suggest = "pop3s_client_certificate"
        elif key == "smtpsClientCertRequest":
            suggest = "smtps_client_cert_request"
        elif key == "smtpsClientCertificate":
            suggest = "smtps_client_certificate"
        elif key == "sslOtherClientCertRequest":
            suggest = "ssl_other_client_cert_request"
        elif key == "sslOtherClientCertificate":
            suggest = "ssl_other_client_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SslsshprofileSslServer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SslsshprofileSslServer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SslsshprofileSslServer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ftps_client_cert_request: Optional[str] = None,
                 ftps_client_certificate: Optional[str] = None,
                 https_client_cert_request: Optional[str] = None,
                 https_client_certificate: Optional[str] = None,
                 id: Optional[int] = None,
                 imaps_client_cert_request: Optional[str] = None,
                 imaps_client_certificate: Optional[str] = None,
                 ip: Optional[str] = None,
                 pop3s_client_cert_request: Optional[str] = None,
                 pop3s_client_certificate: Optional[str] = None,
                 smtps_client_cert_request: Optional[str] = None,
                 smtps_client_certificate: Optional[str] = None,
                 ssl_other_client_cert_request: Optional[str] = None,
                 ssl_other_client_certificate: Optional[str] = None):
        """
        :param str ftps_client_cert_request: Action based on client certificate request during the FTPS handshake. Valid values: `bypass`, `inspect`, `block`.
        :param str ftps_client_certificate: Action based on received client certificate during the FTPS handshake. Valid values: `bypass`, `inspect`, `block`.
        :param str https_client_cert_request: Action based on client certificate request during the HTTPS handshake. Valid values: `bypass`, `inspect`, `block`.
        :param str https_client_certificate: Action based on received client certificate during the HTTPS handshake. Valid values: `bypass`, `inspect`, `block`.
        :param int id: SSL server ID.
        :param str imaps_client_cert_request: Action based on client certificate request during the IMAPS handshake. Valid values: `bypass`, `inspect`, `block`.
        :param str imaps_client_certificate: Action based on received client certificate during the IMAPS handshake. Valid values: `bypass`, `inspect`, `block`.
        :param str ip: IPv4 address of the SSL server.
        :param str pop3s_client_cert_request: Action based on client certificate request during the POP3S handshake. Valid values: `bypass`, `inspect`, `block`.
        :param str pop3s_client_certificate: Action based on received client certificate during the POP3S handshake. Valid values: `bypass`, `inspect`, `block`.
        :param str smtps_client_cert_request: Action based on client certificate request during the SMTPS handshake. Valid values: `bypass`, `inspect`, `block`.
        :param str smtps_client_certificate: Action based on received client certificate during the SMTPS handshake. Valid values: `bypass`, `inspect`, `block`.
        :param str ssl_other_client_cert_request: Action based on client certificate request during an SSL protocol handshake. Valid values: `bypass`, `inspect`, `block`.
        :param str ssl_other_client_certificate: Action based on received client certificate during an SSL protocol handshake. Valid values: `bypass`, `inspect`, `block`.
        """
        if ftps_client_cert_request is not None:
            pulumi.set(__self__, "ftps_client_cert_request", ftps_client_cert_request)
        if ftps_client_certificate is not None:
            pulumi.set(__self__, "ftps_client_certificate", ftps_client_certificate)
        if https_client_cert_request is not None:
            pulumi.set(__self__, "https_client_cert_request", https_client_cert_request)
        if https_client_certificate is not None:
            pulumi.set(__self__, "https_client_certificate", https_client_certificate)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if imaps_client_cert_request is not None:
            pulumi.set(__self__, "imaps_client_cert_request", imaps_client_cert_request)
        if imaps_client_certificate is not None:
            pulumi.set(__self__, "imaps_client_certificate", imaps_client_certificate)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if pop3s_client_cert_request is not None:
            pulumi.set(__self__, "pop3s_client_cert_request", pop3s_client_cert_request)
        if pop3s_client_certificate is not None:
            pulumi.set(__self__, "pop3s_client_certificate", pop3s_client_certificate)
        if smtps_client_cert_request is not None:
            pulumi.set(__self__, "smtps_client_cert_request", smtps_client_cert_request)
        if smtps_client_certificate is not None:
            pulumi.set(__self__, "smtps_client_certificate", smtps_client_certificate)
        if ssl_other_client_cert_request is not None:
            pulumi.set(__self__, "ssl_other_client_cert_request", ssl_other_client_cert_request)
        if ssl_other_client_certificate is not None:
            pulumi.set(__self__, "ssl_other_client_certificate", ssl_other_client_certificate)

    @property
    @pulumi.getter(name="ftpsClientCertRequest")
    def ftps_client_cert_request(self) -> Optional[str]:
        """
        Action based on client certificate request during the FTPS handshake. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "ftps_client_cert_request")

    @property
    @pulumi.getter(name="ftpsClientCertificate")
    def ftps_client_certificate(self) -> Optional[str]:
        """
        Action based on received client certificate during the FTPS handshake. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "ftps_client_certificate")

    @property
    @pulumi.getter(name="httpsClientCertRequest")
    def https_client_cert_request(self) -> Optional[str]:
        """
        Action based on client certificate request during the HTTPS handshake. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "https_client_cert_request")

    @property
    @pulumi.getter(name="httpsClientCertificate")
    def https_client_certificate(self) -> Optional[str]:
        """
        Action based on received client certificate during the HTTPS handshake. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "https_client_certificate")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        SSL server ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="imapsClientCertRequest")
    def imaps_client_cert_request(self) -> Optional[str]:
        """
        Action based on client certificate request during the IMAPS handshake. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "imaps_client_cert_request")

    @property
    @pulumi.getter(name="imapsClientCertificate")
    def imaps_client_certificate(self) -> Optional[str]:
        """
        Action based on received client certificate during the IMAPS handshake. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "imaps_client_certificate")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address of the SSL server.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="pop3sClientCertRequest")
    def pop3s_client_cert_request(self) -> Optional[str]:
        """
        Action based on client certificate request during the POP3S handshake. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "pop3s_client_cert_request")

    @property
    @pulumi.getter(name="pop3sClientCertificate")
    def pop3s_client_certificate(self) -> Optional[str]:
        """
        Action based on received client certificate during the POP3S handshake. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "pop3s_client_certificate")

    @property
    @pulumi.getter(name="smtpsClientCertRequest")
    def smtps_client_cert_request(self) -> Optional[str]:
        """
        Action based on client certificate request during the SMTPS handshake. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "smtps_client_cert_request")

    @property
    @pulumi.getter(name="smtpsClientCertificate")
    def smtps_client_certificate(self) -> Optional[str]:
        """
        Action based on received client certificate during the SMTPS handshake. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "smtps_client_certificate")

    @property
    @pulumi.getter(name="sslOtherClientCertRequest")
    def ssl_other_client_cert_request(self) -> Optional[str]:
        """
        Action based on client certificate request during an SSL protocol handshake. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "ssl_other_client_cert_request")

    @property
    @pulumi.getter(name="sslOtherClientCertificate")
    def ssl_other_client_certificate(self) -> Optional[str]:
        """
        Action based on received client certificate during an SSL protocol handshake. Valid values: `bypass`, `inspect`, `block`.
        """
        return pulumi.get(self, "ssl_other_client_certificate")


@pulumi.output_type
class TtlpolicyService(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class TtlpolicySrcaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Vip46Monitor(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Health monitor name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Health monitor name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Vip46Realserver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIp":
            suggest = "client_ip"
        elif key == "holddownInterval":
            suggest = "holddown_interval"
        elif key == "maxConnections":
            suggest = "max_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Vip46Realserver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Vip46Realserver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Vip46Realserver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_ip: Optional[str] = None,
                 healthcheck: Optional[str] = None,
                 holddown_interval: Optional[int] = None,
                 id: Optional[int] = None,
                 ip: Optional[str] = None,
                 max_connections: Optional[int] = None,
                 monitor: Optional[str] = None,
                 port: Optional[int] = None,
                 status: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param str client_ip: Restrict server to a client IP in this range.
        :param str healthcheck: Per server health check. Valid values: `disable`, `enable`, `vip`.
        :param int holddown_interval: Hold down interval.
        :param int id: Real server ID.
        :param str ip: Mapped server IPv6.
        :param int max_connections: Maximum number of connections allowed to server.
        :param str monitor: Health monitors.
        :param int port: Mapped server port.
        :param str status: Server administrative status. Valid values: `active`, `standby`, `disable`.
        :param int weight: weight
        """
        if client_ip is not None:
            pulumi.set(__self__, "client_ip", client_ip)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if holddown_interval is not None:
            pulumi.set(__self__, "holddown_interval", holddown_interval)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if monitor is not None:
            pulumi.set(__self__, "monitor", monitor)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="clientIp")
    def client_ip(self) -> Optional[str]:
        """
        Restrict server to a client IP in this range.
        """
        return pulumi.get(self, "client_ip")

    @property
    @pulumi.getter
    def healthcheck(self) -> Optional[str]:
        """
        Per server health check. Valid values: `disable`, `enable`, `vip`.
        """
        return pulumi.get(self, "healthcheck")

    @property
    @pulumi.getter(name="holddownInterval")
    def holddown_interval(self) -> Optional[int]:
        """
        Hold down interval.
        """
        return pulumi.get(self, "holddown_interval")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Real server ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Mapped server IPv6.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        """
        Maximum number of connections allowed to server.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter
    def monitor(self) -> Optional[str]:
        """
        Health monitors.
        """
        return pulumi.get(self, "monitor")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Mapped server port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Server administrative status. Valid values: `active`, `standby`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        weight
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class Vip46SrcFilter(dict):
    def __init__(__self__, *,
                 range: Optional[str] = None):
        """
        :param str range: Src-filter range.
        """
        if range is not None:
            pulumi.set(__self__, "range", range)

    @property
    @pulumi.getter
    def range(self) -> Optional[str]:
        """
        Src-filter range.
        """
        return pulumi.get(self, "range")


@pulumi.output_type
class Vip46SrcintfFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceName":
            suggest = "interface_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Vip46SrcintfFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Vip46SrcintfFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Vip46SrcintfFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_name: Optional[str] = None):
        """
        :param str interface_name: Interface name.
        """
        if interface_name is not None:
            pulumi.set(__self__, "interface_name", interface_name)

    @property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "interface_name")


@pulumi.output_type
class Vip64Monitor(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Health monitor name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Health monitor name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Vip64Realserver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIp":
            suggest = "client_ip"
        elif key == "holddownInterval":
            suggest = "holddown_interval"
        elif key == "maxConnections":
            suggest = "max_connections"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Vip64Realserver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Vip64Realserver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Vip64Realserver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_ip: Optional[str] = None,
                 healthcheck: Optional[str] = None,
                 holddown_interval: Optional[int] = None,
                 id: Optional[int] = None,
                 ip: Optional[str] = None,
                 max_connections: Optional[int] = None,
                 monitor: Optional[str] = None,
                 port: Optional[int] = None,
                 status: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param str client_ip: Restrict server to a client IP in this range.
        :param str healthcheck: Per server health check. Valid values: `disable`, `enable`, `vip`.
        :param int holddown_interval: Hold down interval.
        :param int id: Real server ID.
        :param str ip: Mapped server IP.
        :param int max_connections: Maximum number of connections allowed to server.
        :param str monitor: Health monitors.
        :param int port: Mapped server port.
        :param str status: Server administrative status. Valid values: `active`, `standby`, `disable`.
        :param int weight: weight
        """
        if client_ip is not None:
            pulumi.set(__self__, "client_ip", client_ip)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if holddown_interval is not None:
            pulumi.set(__self__, "holddown_interval", holddown_interval)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if monitor is not None:
            pulumi.set(__self__, "monitor", monitor)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="clientIp")
    def client_ip(self) -> Optional[str]:
        """
        Restrict server to a client IP in this range.
        """
        return pulumi.get(self, "client_ip")

    @property
    @pulumi.getter
    def healthcheck(self) -> Optional[str]:
        """
        Per server health check. Valid values: `disable`, `enable`, `vip`.
        """
        return pulumi.get(self, "healthcheck")

    @property
    @pulumi.getter(name="holddownInterval")
    def holddown_interval(self) -> Optional[int]:
        """
        Hold down interval.
        """
        return pulumi.get(self, "holddown_interval")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Real server ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Mapped server IP.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        """
        Maximum number of connections allowed to server.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter
    def monitor(self) -> Optional[str]:
        """
        Health monitors.
        """
        return pulumi.get(self, "monitor")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Mapped server port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Server administrative status. Valid values: `active`, `standby`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        weight
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class Vip64SrcFilter(dict):
    def __init__(__self__, *,
                 range: Optional[str] = None):
        """
        :param str range: Src-filter range.
        """
        if range is not None:
            pulumi.set(__self__, "range", range)

    @property
    @pulumi.getter
    def range(self) -> Optional[str]:
        """
        Src-filter range.
        """
        return pulumi.get(self, "range")


@pulumi.output_type
class Vip6Monitor(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Health monitor name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Health monitor name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Vip6Quic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ackDelayExponent":
            suggest = "ack_delay_exponent"
        elif key == "activeConnectionIdLimit":
            suggest = "active_connection_id_limit"
        elif key == "activeMigration":
            suggest = "active_migration"
        elif key == "greaseQuicBit":
            suggest = "grease_quic_bit"
        elif key == "maxAckDelay":
            suggest = "max_ack_delay"
        elif key == "maxDatagramFrameSize":
            suggest = "max_datagram_frame_size"
        elif key == "maxIdleTimeout":
            suggest = "max_idle_timeout"
        elif key == "maxUdpPayloadSize":
            suggest = "max_udp_payload_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Vip6Quic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Vip6Quic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Vip6Quic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ack_delay_exponent: Optional[int] = None,
                 active_connection_id_limit: Optional[int] = None,
                 active_migration: Optional[str] = None,
                 grease_quic_bit: Optional[str] = None,
                 max_ack_delay: Optional[int] = None,
                 max_datagram_frame_size: Optional[int] = None,
                 max_idle_timeout: Optional[int] = None,
                 max_udp_payload_size: Optional[int] = None):
        """
        :param int ack_delay_exponent: ACK delay exponent (1 - 20, default = 3).
        :param int active_connection_id_limit: Active connection ID limit (1 - 8, default = 2).
        :param str active_migration: Enable/disable active migration (default = disable). Valid values: `enable`, `disable`.
        :param str grease_quic_bit: Enable/disable grease QUIC bit (default = enable). Valid values: `enable`, `disable`.
        :param int max_ack_delay: Maximum ACK delay in milliseconds (1 - 16383, default = 25).
        :param int max_datagram_frame_size: Maximum datagram frame size in bytes (1 - 1500, default = 1500).
        :param int max_idle_timeout: Maximum idle timeout milliseconds (1 - 60000, default = 30000).
        :param int max_udp_payload_size: Maximum UDP payload size in bytes (1200 - 1500, default = 1500).
        """
        if ack_delay_exponent is not None:
            pulumi.set(__self__, "ack_delay_exponent", ack_delay_exponent)
        if active_connection_id_limit is not None:
            pulumi.set(__self__, "active_connection_id_limit", active_connection_id_limit)
        if active_migration is not None:
            pulumi.set(__self__, "active_migration", active_migration)
        if grease_quic_bit is not None:
            pulumi.set(__self__, "grease_quic_bit", grease_quic_bit)
        if max_ack_delay is not None:
            pulumi.set(__self__, "max_ack_delay", max_ack_delay)
        if max_datagram_frame_size is not None:
            pulumi.set(__self__, "max_datagram_frame_size", max_datagram_frame_size)
        if max_idle_timeout is not None:
            pulumi.set(__self__, "max_idle_timeout", max_idle_timeout)
        if max_udp_payload_size is not None:
            pulumi.set(__self__, "max_udp_payload_size", max_udp_payload_size)

    @property
    @pulumi.getter(name="ackDelayExponent")
    def ack_delay_exponent(self) -> Optional[int]:
        """
        ACK delay exponent (1 - 20, default = 3).
        """
        return pulumi.get(self, "ack_delay_exponent")

    @property
    @pulumi.getter(name="activeConnectionIdLimit")
    def active_connection_id_limit(self) -> Optional[int]:
        """
        Active connection ID limit (1 - 8, default = 2).
        """
        return pulumi.get(self, "active_connection_id_limit")

    @property
    @pulumi.getter(name="activeMigration")
    def active_migration(self) -> Optional[str]:
        """
        Enable/disable active migration (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "active_migration")

    @property
    @pulumi.getter(name="greaseQuicBit")
    def grease_quic_bit(self) -> Optional[str]:
        """
        Enable/disable grease QUIC bit (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "grease_quic_bit")

    @property
    @pulumi.getter(name="maxAckDelay")
    def max_ack_delay(self) -> Optional[int]:
        """
        Maximum ACK delay in milliseconds (1 - 16383, default = 25).
        """
        return pulumi.get(self, "max_ack_delay")

    @property
    @pulumi.getter(name="maxDatagramFrameSize")
    def max_datagram_frame_size(self) -> Optional[int]:
        """
        Maximum datagram frame size in bytes (1 - 1500, default = 1500).
        """
        return pulumi.get(self, "max_datagram_frame_size")

    @property
    @pulumi.getter(name="maxIdleTimeout")
    def max_idle_timeout(self) -> Optional[int]:
        """
        Maximum idle timeout milliseconds (1 - 60000, default = 30000).
        """
        return pulumi.get(self, "max_idle_timeout")

    @property
    @pulumi.getter(name="maxUdpPayloadSize")
    def max_udp_payload_size(self) -> Optional[int]:
        """
        Maximum UDP payload size in bytes (1200 - 1500, default = 1500).
        """
        return pulumi.get(self, "max_udp_payload_size")


@pulumi.output_type
class Vip6Realserver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIp":
            suggest = "client_ip"
        elif key == "holddownInterval":
            suggest = "holddown_interval"
        elif key == "httpHost":
            suggest = "http_host"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "translateHost":
            suggest = "translate_host"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in Vip6Realserver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        Vip6Realserver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        Vip6Realserver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_ip: Optional[str] = None,
                 healthcheck: Optional[str] = None,
                 holddown_interval: Optional[int] = None,
                 http_host: Optional[str] = None,
                 id: Optional[int] = None,
                 ip: Optional[str] = None,
                 max_connections: Optional[int] = None,
                 monitor: Optional[str] = None,
                 port: Optional[int] = None,
                 status: Optional[str] = None,
                 translate_host: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param str client_ip: Only clients in this IP range can connect to this real server.
        :param str healthcheck: Enable to check the responsiveness of the real server before forwarding traffic. Valid values: `disable`, `enable`, `vip`.
        :param int holddown_interval: Time in seconds that the health check monitor continues to monitor an unresponsive server that should be active.
        :param str http_host: HTTP server domain name in HTTP header.
        :param int id: Real server ID.
        :param str ip: IPv6 address of the real server.
        :param int max_connections: Max number of active connections that can directed to the real server. When reached, sessions are sent to other real servers.
        :param str monitor: Name of the health check monitor to use when polling to determine a virtual server's connectivity status.
        :param int port: Port for communicating with the real server. Required if port forwarding is enabled.
        :param str status: Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent. Valid values: `active`, `standby`, `disable`.
        :param str translate_host: Enable/disable translation of hostname/IP from virtual server to real server. Valid values: `enable`, `disable`.
        :param int weight: Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
        """
        if client_ip is not None:
            pulumi.set(__self__, "client_ip", client_ip)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if holddown_interval is not None:
            pulumi.set(__self__, "holddown_interval", holddown_interval)
        if http_host is not None:
            pulumi.set(__self__, "http_host", http_host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if monitor is not None:
            pulumi.set(__self__, "monitor", monitor)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if translate_host is not None:
            pulumi.set(__self__, "translate_host", translate_host)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter(name="clientIp")
    def client_ip(self) -> Optional[str]:
        """
        Only clients in this IP range can connect to this real server.
        """
        return pulumi.get(self, "client_ip")

    @property
    @pulumi.getter
    def healthcheck(self) -> Optional[str]:
        """
        Enable to check the responsiveness of the real server before forwarding traffic. Valid values: `disable`, `enable`, `vip`.
        """
        return pulumi.get(self, "healthcheck")

    @property
    @pulumi.getter(name="holddownInterval")
    def holddown_interval(self) -> Optional[int]:
        """
        Time in seconds that the health check monitor continues to monitor an unresponsive server that should be active.
        """
        return pulumi.get(self, "holddown_interval")

    @property
    @pulumi.getter(name="httpHost")
    def http_host(self) -> Optional[str]:
        """
        HTTP server domain name in HTTP header.
        """
        return pulumi.get(self, "http_host")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Real server ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv6 address of the real server.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        """
        Max number of active connections that can directed to the real server. When reached, sessions are sent to other real servers.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter
    def monitor(self) -> Optional[str]:
        """
        Name of the health check monitor to use when polling to determine a virtual server's connectivity status.
        """
        return pulumi.get(self, "monitor")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for communicating with the real server. Required if port forwarding is enabled.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent. Valid values: `active`, `standby`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="translateHost")
    def translate_host(self) -> Optional[str]:
        """
        Enable/disable translation of hostname/IP from virtual server to real server. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "translate_host")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class Vip6SrcFilter(dict):
    def __init__(__self__, *,
                 range: Optional[str] = None):
        """
        :param str range: Source-filter range.
        """
        if range is not None:
            pulumi.set(__self__, "range", range)

    @property
    @pulumi.getter
    def range(self) -> Optional[str]:
        """
        Source-filter range.
        """
        return pulumi.get(self, "range")


@pulumi.output_type
class Vip6SslCipherSuite(dict):
    def __init__(__self__, *,
                 cipher: Optional[str] = None,
                 priority: Optional[int] = None,
                 versions: Optional[str] = None):
        """
        :param str cipher: Cipher suite name.
        :param int priority: SSL/TLS cipher suites priority.
        :param str versions: SSL/TLS versions that the cipher suite can be used with.
        """
        if cipher is not None:
            pulumi.set(__self__, "cipher", cipher)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def cipher(self) -> Optional[str]:
        """
        Cipher suite name.
        """
        return pulumi.get(self, "cipher")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        SSL/TLS cipher suites priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def versions(self) -> Optional[str]:
        """
        SSL/TLS versions that the cipher suite can be used with.
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class Vip6SslServerCipherSuite(dict):
    def __init__(__self__, *,
                 cipher: Optional[str] = None,
                 priority: Optional[int] = None,
                 versions: Optional[str] = None):
        """
        :param str cipher: Cipher suite name.
        :param int priority: SSL/TLS cipher suites priority.
        :param str versions: SSL/TLS versions that the cipher suite can be used with.
        """
        if cipher is not None:
            pulumi.set(__self__, "cipher", cipher)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def cipher(self) -> Optional[str]:
        """
        Cipher suite name.
        """
        return pulumi.get(self, "cipher")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        SSL/TLS cipher suites priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def versions(self) -> Optional[str]:
        """
        SSL/TLS versions that the cipher suite can be used with.
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class VipExtaddr(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Address name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Address name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VipGslbPublicIp(dict):
    def __init__(__self__, *,
                 index: Optional[int] = None,
                 ip: Optional[str] = None):
        """
        :param int index: Index of this public IP setting.
        :param str ip: The publicly accessible IP address.
        """
        if index is not None:
            pulumi.set(__self__, "index", index)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def index(self) -> Optional[int]:
        """
        Index of this public IP setting.
        """
        return pulumi.get(self, "index")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        The publicly accessible IP address.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class VipMappedip(dict):
    def __init__(__self__, *,
                 range: Optional[str] = None):
        """
        :param str range: Mapped IP range.
        """
        if range is not None:
            pulumi.set(__self__, "range", range)

    @property
    @pulumi.getter
    def range(self) -> Optional[str]:
        """
        Mapped IP range.
        """
        return pulumi.get(self, "range")


@pulumi.output_type
class VipMonitor(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Health monitor name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Health monitor name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VipQuic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ackDelayExponent":
            suggest = "ack_delay_exponent"
        elif key == "activeConnectionIdLimit":
            suggest = "active_connection_id_limit"
        elif key == "activeMigration":
            suggest = "active_migration"
        elif key == "greaseQuicBit":
            suggest = "grease_quic_bit"
        elif key == "maxAckDelay":
            suggest = "max_ack_delay"
        elif key == "maxDatagramFrameSize":
            suggest = "max_datagram_frame_size"
        elif key == "maxIdleTimeout":
            suggest = "max_idle_timeout"
        elif key == "maxUdpPayloadSize":
            suggest = "max_udp_payload_size"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VipQuic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VipQuic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VipQuic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ack_delay_exponent: Optional[int] = None,
                 active_connection_id_limit: Optional[int] = None,
                 active_migration: Optional[str] = None,
                 grease_quic_bit: Optional[str] = None,
                 max_ack_delay: Optional[int] = None,
                 max_datagram_frame_size: Optional[int] = None,
                 max_idle_timeout: Optional[int] = None,
                 max_udp_payload_size: Optional[int] = None):
        """
        :param int ack_delay_exponent: ACK delay exponent (1 - 20, default = 3).
        :param int active_connection_id_limit: Active connection ID limit (1 - 8, default = 2).
        :param str active_migration: Enable/disable active migration (default = disable). Valid values: `enable`, `disable`.
        :param str grease_quic_bit: Enable/disable grease QUIC bit (default = enable). Valid values: `enable`, `disable`.
        :param int max_ack_delay: Maximum ACK delay in milliseconds (1 - 16383, default = 25).
        :param int max_datagram_frame_size: Maximum datagram frame size in bytes (1 - 1500, default = 1500).
        :param int max_idle_timeout: Maximum idle timeout milliseconds (1 - 60000, default = 30000).
        :param int max_udp_payload_size: Maximum UDP payload size in bytes (1200 - 1500, default = 1500).
        """
        if ack_delay_exponent is not None:
            pulumi.set(__self__, "ack_delay_exponent", ack_delay_exponent)
        if active_connection_id_limit is not None:
            pulumi.set(__self__, "active_connection_id_limit", active_connection_id_limit)
        if active_migration is not None:
            pulumi.set(__self__, "active_migration", active_migration)
        if grease_quic_bit is not None:
            pulumi.set(__self__, "grease_quic_bit", grease_quic_bit)
        if max_ack_delay is not None:
            pulumi.set(__self__, "max_ack_delay", max_ack_delay)
        if max_datagram_frame_size is not None:
            pulumi.set(__self__, "max_datagram_frame_size", max_datagram_frame_size)
        if max_idle_timeout is not None:
            pulumi.set(__self__, "max_idle_timeout", max_idle_timeout)
        if max_udp_payload_size is not None:
            pulumi.set(__self__, "max_udp_payload_size", max_udp_payload_size)

    @property
    @pulumi.getter(name="ackDelayExponent")
    def ack_delay_exponent(self) -> Optional[int]:
        """
        ACK delay exponent (1 - 20, default = 3).
        """
        return pulumi.get(self, "ack_delay_exponent")

    @property
    @pulumi.getter(name="activeConnectionIdLimit")
    def active_connection_id_limit(self) -> Optional[int]:
        """
        Active connection ID limit (1 - 8, default = 2).
        """
        return pulumi.get(self, "active_connection_id_limit")

    @property
    @pulumi.getter(name="activeMigration")
    def active_migration(self) -> Optional[str]:
        """
        Enable/disable active migration (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "active_migration")

    @property
    @pulumi.getter(name="greaseQuicBit")
    def grease_quic_bit(self) -> Optional[str]:
        """
        Enable/disable grease QUIC bit (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "grease_quic_bit")

    @property
    @pulumi.getter(name="maxAckDelay")
    def max_ack_delay(self) -> Optional[int]:
        """
        Maximum ACK delay in milliseconds (1 - 16383, default = 25).
        """
        return pulumi.get(self, "max_ack_delay")

    @property
    @pulumi.getter(name="maxDatagramFrameSize")
    def max_datagram_frame_size(self) -> Optional[int]:
        """
        Maximum datagram frame size in bytes (1 - 1500, default = 1500).
        """
        return pulumi.get(self, "max_datagram_frame_size")

    @property
    @pulumi.getter(name="maxIdleTimeout")
    def max_idle_timeout(self) -> Optional[int]:
        """
        Maximum idle timeout milliseconds (1 - 60000, default = 30000).
        """
        return pulumi.get(self, "max_idle_timeout")

    @property
    @pulumi.getter(name="maxUdpPayloadSize")
    def max_udp_payload_size(self) -> Optional[int]:
        """
        Maximum UDP payload size in bytes (1200 - 1500, default = 1500).
        """
        return pulumi.get(self, "max_udp_payload_size")


@pulumi.output_type
class VipRealserver(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientIp":
            suggest = "client_ip"
        elif key == "holddownInterval":
            suggest = "holddown_interval"
        elif key == "httpHost":
            suggest = "http_host"
        elif key == "maxConnections":
            suggest = "max_connections"
        elif key == "translateHost":
            suggest = "translate_host"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VipRealserver. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VipRealserver.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VipRealserver.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 client_ip: Optional[str] = None,
                 healthcheck: Optional[str] = None,
                 holddown_interval: Optional[int] = None,
                 http_host: Optional[str] = None,
                 id: Optional[int] = None,
                 ip: Optional[str] = None,
                 max_connections: Optional[int] = None,
                 monitor: Optional[str] = None,
                 port: Optional[int] = None,
                 status: Optional[str] = None,
                 translate_host: Optional[str] = None,
                 type: Optional[str] = None,
                 weight: Optional[int] = None):
        """
        :param str address: Dynamic address of the real server.
        :param str client_ip: Only clients in this IP range can connect to this real server.
        :param str healthcheck: Enable to check the responsiveness of the real server before forwarding traffic. Valid values: `disable`, `enable`, `vip`.
        :param int holddown_interval: Time in seconds that the health check monitor continues to monitor and unresponsive server that should be active.
        :param str http_host: HTTP server domain name in HTTP header.
        :param int id: Real server ID.
        :param str ip: IP address of the real server.
        :param int max_connections: Max number of active connections that can be directed to the real server. When reached, sessions are sent to other real servers.
        :param str monitor: Name of the health check monitor to use when polling to determine a virtual server's connectivity status.
        :param int port: Port for communicating with the real server. Required if port forwarding is enabled.
        :param str status: Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent. Valid values: `active`, `standby`, `disable`.
        :param str translate_host: Enable/disable translation of hostname/IP from virtual server to real server. Valid values: `enable`, `disable`.
        :param str type: Type of address. Valid values: `ip`, `address`.
        :param int weight: Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if client_ip is not None:
            pulumi.set(__self__, "client_ip", client_ip)
        if healthcheck is not None:
            pulumi.set(__self__, "healthcheck", healthcheck)
        if holddown_interval is not None:
            pulumi.set(__self__, "holddown_interval", holddown_interval)
        if http_host is not None:
            pulumi.set(__self__, "http_host", http_host)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if max_connections is not None:
            pulumi.set(__self__, "max_connections", max_connections)
        if monitor is not None:
            pulumi.set(__self__, "monitor", monitor)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if translate_host is not None:
            pulumi.set(__self__, "translate_host", translate_host)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if weight is not None:
            pulumi.set(__self__, "weight", weight)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        Dynamic address of the real server.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="clientIp")
    def client_ip(self) -> Optional[str]:
        """
        Only clients in this IP range can connect to this real server.
        """
        return pulumi.get(self, "client_ip")

    @property
    @pulumi.getter
    def healthcheck(self) -> Optional[str]:
        """
        Enable to check the responsiveness of the real server before forwarding traffic. Valid values: `disable`, `enable`, `vip`.
        """
        return pulumi.get(self, "healthcheck")

    @property
    @pulumi.getter(name="holddownInterval")
    def holddown_interval(self) -> Optional[int]:
        """
        Time in seconds that the health check monitor continues to monitor and unresponsive server that should be active.
        """
        return pulumi.get(self, "holddown_interval")

    @property
    @pulumi.getter(name="httpHost")
    def http_host(self) -> Optional[str]:
        """
        HTTP server domain name in HTTP header.
        """
        return pulumi.get(self, "http_host")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Real server ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IP address of the real server.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter(name="maxConnections")
    def max_connections(self) -> Optional[int]:
        """
        Max number of active connections that can be directed to the real server. When reached, sessions are sent to other real servers.
        """
        return pulumi.get(self, "max_connections")

    @property
    @pulumi.getter
    def monitor(self) -> Optional[str]:
        """
        Name of the health check monitor to use when polling to determine a virtual server's connectivity status.
        """
        return pulumi.get(self, "monitor")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Port for communicating with the real server. Required if port forwarding is enabled.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Set the status of the real server to active so that it can accept traffic, or on standby or disabled so no traffic is sent. Valid values: `active`, `standby`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="translateHost")
    def translate_host(self) -> Optional[str]:
        """
        Enable/disable translation of hostname/IP from virtual server to real server. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "translate_host")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of address. Valid values: `ip`, `address`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def weight(self) -> Optional[int]:
        """
        Weight of the real server. If weighted load balancing is enabled, the server with the highest weight gets more connections.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class VipService(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Service name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Service name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VipSrcFilter(dict):
    def __init__(__self__, *,
                 range: Optional[str] = None):
        """
        :param str range: Source-filter range.
        """
        if range is not None:
            pulumi.set(__self__, "range", range)

    @property
    @pulumi.getter
    def range(self) -> Optional[str]:
        """
        Source-filter range.
        """
        return pulumi.get(self, "range")


@pulumi.output_type
class VipSrcintfFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "interfaceName":
            suggest = "interface_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VipSrcintfFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VipSrcintfFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VipSrcintfFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 interface_name: Optional[str] = None):
        """
        :param str interface_name: Interface name.
        """
        if interface_name is not None:
            pulumi.set(__self__, "interface_name", interface_name)

    @property
    @pulumi.getter(name="interfaceName")
    def interface_name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "interface_name")


@pulumi.output_type
class VipSslCipherSuite(dict):
    def __init__(__self__, *,
                 cipher: Optional[str] = None,
                 priority: Optional[int] = None,
                 versions: Optional[str] = None):
        """
        :param str cipher: Cipher suite name.
        :param int priority: SSL/TLS cipher suites priority.
        :param str versions: SSL/TLS versions that the cipher suite can be used with.
        """
        if cipher is not None:
            pulumi.set(__self__, "cipher", cipher)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def cipher(self) -> Optional[str]:
        """
        Cipher suite name.
        """
        return pulumi.get(self, "cipher")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        SSL/TLS cipher suites priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def versions(self) -> Optional[str]:
        """
        SSL/TLS versions that the cipher suite can be used with.
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class VipSslServerCipherSuite(dict):
    def __init__(__self__, *,
                 cipher: Optional[str] = None,
                 priority: Optional[int] = None,
                 versions: Optional[str] = None):
        """
        :param str cipher: Cipher suite name.
        :param int priority: SSL/TLS cipher suites priority.
        :param str versions: SSL/TLS versions that the cipher suite can be used with.
        """
        if cipher is not None:
            pulumi.set(__self__, "cipher", cipher)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @property
    @pulumi.getter
    def cipher(self) -> Optional[str]:
        """
        Cipher suite name.
        """
        return pulumi.get(self, "cipher")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        SSL/TLS cipher suites priority.
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def versions(self) -> Optional[str]:
        """
        SSL/TLS versions that the cipher suite can be used with.
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class Vipgrp46Member(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: VIP46 name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        VIP46 name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Vipgrp64Member(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: VIP64 name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        VIP64 name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class Vipgrp6Member(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: IPv6 VIP name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        IPv6 VIP name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VipgrpMember(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: VIP name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        VIP name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAddress6ListResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: IP.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetAddress6MacaddrResult(dict):
    def __init__(__self__, *,
                 macaddr: str):
        """
        :param str macaddr: MAC address ranges <start>[-<end>] separated by space.
        """
        pulumi.set(__self__, "macaddr", macaddr)

    @property
    @pulumi.getter
    def macaddr(self) -> str:
        """
        MAC address ranges <start>[-<end>] separated by space.
        """
        return pulumi.get(self, "macaddr")


@pulumi.output_type
class GetAddress6SubnetSegmentResult(dict):
    def __init__(__self__, *,
                 name: str,
                 type: str,
                 value: str):
        """
        :param str name: Specify the name of the desired firewall address6.
        :param str type: Subnet segment type.
        :param str value: Subnet segment value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall address6.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Subnet segment type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Subnet segment value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAddress6TaggingResult(dict):
    def __init__(__self__, *,
                 category: str,
                 name: str,
                 tags: Sequence['outputs.GetAddress6TaggingTagResult']):
        """
        :param str category: Tag category.
        :param str name: Specify the name of the desired firewall address6.
        :param Sequence['GetAddress6TaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall address6.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetAddress6TaggingTagResult']:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetAddress6TaggingTagResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall address6.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall address6.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAddress6templateSubnetSegmentResult(dict):
    def __init__(__self__, *,
                 bits: int,
                 exclusive: str,
                 id: int,
                 name: str,
                 values: Sequence['outputs.GetAddress6templateSubnetSegmentValueResult']):
        """
        :param int bits: Number of bits.
        :param str exclusive: Enable/disable exclusive value.
        :param int id: Subnet segment ID.
        :param str name: Specify the name of the desired firewall address6template.
        :param Sequence['GetAddress6templateSubnetSegmentValueArgs'] values: Subnet segment values. The structure of `values` block is documented below.
        """
        pulumi.set(__self__, "bits", bits)
        pulumi.set(__self__, "exclusive", exclusive)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def bits(self) -> int:
        """
        Number of bits.
        """
        return pulumi.get(self, "bits")

    @property
    @pulumi.getter
    def exclusive(self) -> str:
        """
        Enable/disable exclusive value.
        """
        return pulumi.get(self, "exclusive")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Subnet segment ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall address6template.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Sequence['outputs.GetAddress6templateSubnetSegmentValueResult']:
        """
        Subnet segment values. The structure of `values` block is documented below.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAddress6templateSubnetSegmentValueResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: str):
        """
        :param str name: Specify the name of the desired firewall address6template.
        :param str value: Subnet segment value.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall address6template.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Subnet segment value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAddressFssoGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall address.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall address.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAddressListResult(dict):
    def __init__(__self__, *,
                 ip: str):
        """
        :param str ip: IP.
        """
        pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class GetAddressMacaddrResult(dict):
    def __init__(__self__, *,
                 macaddr: str):
        """
        :param str macaddr: MAC address ranges <start>[-<end>] separated by space.
        """
        pulumi.set(__self__, "macaddr", macaddr)

    @property
    @pulumi.getter
    def macaddr(self) -> str:
        """
        MAC address ranges <start>[-<end>] separated by space.
        """
        return pulumi.get(self, "macaddr")


@pulumi.output_type
class GetAddressTaggingResult(dict):
    def __init__(__self__, *,
                 category: str,
                 name: str,
                 tags: Sequence['outputs.GetAddressTaggingTagResult']):
        """
        :param str category: Tag category.
        :param str name: Specify the name of the desired firewall address.
        :param Sequence['GetAddressTaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall address.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetAddressTaggingTagResult']:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetAddressTaggingTagResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall address.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall address.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAddrgrp6ExcludeMemberResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall addrgrp6.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall addrgrp6.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAddrgrp6MemberResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall addrgrp6.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall addrgrp6.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAddrgrp6TaggingResult(dict):
    def __init__(__self__, *,
                 category: str,
                 name: str,
                 tags: Sequence['outputs.GetAddrgrp6TaggingTagResult']):
        """
        :param str category: Tag category.
        :param str name: Specify the name of the desired firewall addrgrp6.
        :param Sequence['GetAddrgrp6TaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall addrgrp6.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetAddrgrp6TaggingTagResult']:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetAddrgrp6TaggingTagResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall addrgrp6.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall addrgrp6.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAddrgrpExcludeMemberResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall addrgrp.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall addrgrp.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAddrgrpMemberResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall addrgrp.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall addrgrp.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetAddrgrpTaggingResult(dict):
    def __init__(__self__, *,
                 category: str,
                 name: str,
                 tags: Sequence['outputs.GetAddrgrpTaggingTagResult']):
        """
        :param str category: Tag category.
        :param str name: Specify the name of the desired firewall addrgrp.
        :param Sequence['GetAddrgrpTaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall addrgrp.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetAddrgrpTaggingTagResult']:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetAddrgrpTaggingTagResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall addrgrp.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall addrgrp.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCentralsnatmapDstAddr6Result(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IPv6 pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IPv6 pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCentralsnatmapDstAddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IPv6 pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IPv6 pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCentralsnatmapDstintfResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IPv6 pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IPv6 pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCentralsnatmapNatIppool6Result(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IPv6 pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IPv6 pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCentralsnatmapNatIppoolResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IPv6 pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IPv6 pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCentralsnatmapOrigAddr6Result(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IPv6 pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IPv6 pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCentralsnatmapOrigAddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IPv6 pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IPv6 pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetCentralsnatmapSrcintfResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IPv6 pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IPv6 pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDoSpolicy6AnomalyResult(dict):
    def __init__(__self__, *,
                 action: str,
                 log: str,
                 name: str,
                 quarantine: str,
                 quarantine_expiry: str,
                 quarantine_log: str,
                 status: str,
                 threshold: int,
                 thresholddefault: int):
        """
        :param str action: Action taken when the threshold is reached.
        :param str log: Enable/disable anomaly logging.
        :param str name: Anomaly name.
        :param str quarantine: Quarantine method.
        :param str quarantine_expiry: Duration of quarantine. (Format ###d##h##m, minimum 1m, maximum 364d23h59m, default = 5m). Requires quarantine set to attacker.
        :param str quarantine_log: Enable/disable quarantine logging.
        :param str status: Enable/disable this anomaly.
        :param int threshold: Anomaly threshold. Number of detected instances per minute that triggers the anomaly action.
        :param int thresholddefault: Number of detected instances per minute which triggers action (1 - 2147483647, default = 1000). Note that each anomaly has a different threshold value assigned to it.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "log", log)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "quarantine", quarantine)
        pulumi.set(__self__, "quarantine_expiry", quarantine_expiry)
        pulumi.set(__self__, "quarantine_log", quarantine_log)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "thresholddefault", thresholddefault)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action taken when the threshold is reached.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def log(self) -> str:
        """
        Enable/disable anomaly logging.
        """
        return pulumi.get(self, "log")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Anomaly name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def quarantine(self) -> str:
        """
        Quarantine method.
        """
        return pulumi.get(self, "quarantine")

    @property
    @pulumi.getter(name="quarantineExpiry")
    def quarantine_expiry(self) -> str:
        """
        Duration of quarantine. (Format ###d##h##m, minimum 1m, maximum 364d23h59m, default = 5m). Requires quarantine set to attacker.
        """
        return pulumi.get(self, "quarantine_expiry")

    @property
    @pulumi.getter(name="quarantineLog")
    def quarantine_log(self) -> str:
        """
        Enable/disable quarantine logging.
        """
        return pulumi.get(self, "quarantine_log")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Enable/disable this anomaly.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        Anomaly threshold. Number of detected instances per minute that triggers the anomaly action.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def thresholddefault(self) -> int:
        """
        Number of detected instances per minute which triggers action (1 - 2147483647, default = 1000). Note that each anomaly has a different threshold value assigned to it.
        """
        return pulumi.get(self, "thresholddefault")


@pulumi.output_type
class GetDoSpolicy6DstaddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Anomaly name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Anomaly name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDoSpolicy6ServiceResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Anomaly name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Anomaly name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDoSpolicy6SrcaddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Anomaly name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Anomaly name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDoSpolicyAnomalyResult(dict):
    def __init__(__self__, *,
                 action: str,
                 log: str,
                 name: str,
                 quarantine: str,
                 quarantine_expiry: str,
                 quarantine_log: str,
                 status: str,
                 threshold: int,
                 thresholddefault: int):
        """
        :param str action: Action taken when the threshold is reached.
        :param str log: Enable/disable anomaly logging.
        :param str name: Anomaly name.
        :param str quarantine: Quarantine method.
        :param str quarantine_expiry: Duration of quarantine. (Format ###d##h##m, minimum 1m, maximum 364d23h59m, default = 5m). Requires quarantine set to attacker.
        :param str quarantine_log: Enable/disable quarantine logging.
        :param str status: Enable/disable this anomaly.
        :param int threshold: Anomaly threshold. Number of detected instances per minute that triggers the anomaly action.
        :param int thresholddefault: Number of detected instances per minute which triggers action (1 - 2147483647, default = 1000). Note that each anomaly has a different threshold value assigned to it.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "log", log)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "quarantine", quarantine)
        pulumi.set(__self__, "quarantine_expiry", quarantine_expiry)
        pulumi.set(__self__, "quarantine_log", quarantine_log)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "threshold", threshold)
        pulumi.set(__self__, "thresholddefault", thresholddefault)

    @property
    @pulumi.getter
    def action(self) -> str:
        """
        Action taken when the threshold is reached.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def log(self) -> str:
        """
        Enable/disable anomaly logging.
        """
        return pulumi.get(self, "log")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Anomaly name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def quarantine(self) -> str:
        """
        Quarantine method.
        """
        return pulumi.get(self, "quarantine")

    @property
    @pulumi.getter(name="quarantineExpiry")
    def quarantine_expiry(self) -> str:
        """
        Duration of quarantine. (Format ###d##h##m, minimum 1m, maximum 364d23h59m, default = 5m). Requires quarantine set to attacker.
        """
        return pulumi.get(self, "quarantine_expiry")

    @property
    @pulumi.getter(name="quarantineLog")
    def quarantine_log(self) -> str:
        """
        Enable/disable quarantine logging.
        """
        return pulumi.get(self, "quarantine_log")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Enable/disable this anomaly.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def threshold(self) -> int:
        """
        Anomaly threshold. Number of detected instances per minute that triggers the anomaly action.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def thresholddefault(self) -> int:
        """
        Number of detected instances per minute which triggers action (1 - 2147483647, default = 1000). Note that each anomaly has a different threshold value assigned to it.
        """
        return pulumi.get(self, "thresholddefault")


@pulumi.output_type
class GetDoSpolicyDstaddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Anomaly name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Anomaly name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDoSpolicyServiceResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Anomaly name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Anomaly name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetDoSpolicySrcaddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Anomaly name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Anomaly name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInternetservicecustomEntryResult(dict):
    def __init__(__self__, *,
                 addr_mode: str,
                 dst6s: Sequence['outputs.GetInternetservicecustomEntryDst6Result'],
                 dsts: Sequence['outputs.GetInternetservicecustomEntryDstResult'],
                 id: int,
                 port_ranges: Sequence['outputs.GetInternetservicecustomEntryPortRangeResult'],
                 protocol: int):
        """
        :param str addr_mode: Address mode (IPv4 or IPv6)
        :param Sequence['GetInternetservicecustomEntryDst6Args'] dst6s: Destination address6 or address6 group name. The structure of `dst6` block is documented below.
        :param Sequence['GetInternetservicecustomEntryDstArgs'] dsts: Destination address or address group name. The structure of `dst` block is documented below.
        :param int id: Custom entry port range ID.
        :param Sequence['GetInternetservicecustomEntryPortRangeArgs'] port_ranges: Port ranges in the custom entry. The structure of `port_range` block is documented below.
        :param int protocol: Integer value for the protocol type as defined by IANA (0 - 255).
        """
        pulumi.set(__self__, "addr_mode", addr_mode)
        pulumi.set(__self__, "dst6s", dst6s)
        pulumi.set(__self__, "dsts", dsts)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="addrMode")
    def addr_mode(self) -> str:
        """
        Address mode (IPv4 or IPv6)
        """
        return pulumi.get(self, "addr_mode")

    @property
    @pulumi.getter
    def dst6s(self) -> Sequence['outputs.GetInternetservicecustomEntryDst6Result']:
        """
        Destination address6 or address6 group name. The structure of `dst6` block is documented below.
        """
        return pulumi.get(self, "dst6s")

    @property
    @pulumi.getter
    def dsts(self) -> Sequence['outputs.GetInternetservicecustomEntryDstResult']:
        """
        Destination address or address group name. The structure of `dst` block is documented below.
        """
        return pulumi.get(self, "dsts")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Custom entry port range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetInternetservicecustomEntryPortRangeResult']:
        """
        Port ranges in the custom entry. The structure of `port_range` block is documented below.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> int:
        """
        Integer value for the protocol type as defined by IANA (0 - 255).
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetInternetservicecustomEntryDst6Result(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall internetservicecustom.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall internetservicecustom.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInternetservicecustomEntryDstResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall internetservicecustom.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall internetservicecustom.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInternetservicecustomEntryPortRangeResult(dict):
    def __init__(__self__, *,
                 end_port: int,
                 id: int,
                 start_port: int):
        """
        :param int end_port: Integer value for ending TCP/UDP/SCTP destination port in range (1 to 65535).
        :param int id: Custom entry port range ID.
        :param int start_port: Integer value for starting TCP/UDP/SCTP destination port in range (1 to 65535).
        """
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> int:
        """
        Integer value for ending TCP/UDP/SCTP destination port in range (1 to 65535).
        """
        return pulumi.get(self, "end_port")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Custom entry port range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> int:
        """
        Integer value for starting TCP/UDP/SCTP destination port in range (1 to 65535).
        """
        return pulumi.get(self, "start_port")


@pulumi.output_type
class GetInternetservicecustomgroupMemberResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall internetservicecustomgroup.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall internetservicecustomgroup.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInternetservicedefinitionEntryResult(dict):
    def __init__(__self__, *,
                 category_id: int,
                 name: str,
                 port: int,
                 port_ranges: Sequence['outputs.GetInternetservicedefinitionEntryPortRangeResult'],
                 protocol: int,
                 seq_num: int):
        """
        :param int category_id: Internet Service category ID.
        :param str name: Internet Service name.
        :param int port: Integer value for ending TCP/UDP/SCTP destination port in range (0 to 65535). 0 means undefined.
        :param Sequence['GetInternetservicedefinitionEntryPortRangeArgs'] port_ranges: Port ranges in the definition entry. The structure of `port_range` block is documented below.
        :param int protocol: Integer value for the protocol type as defined by IANA (0 - 255).
        :param int seq_num: Entry sequence number.
        """
        pulumi.set(__self__, "category_id", category_id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "seq_num", seq_num)

    @property
    @pulumi.getter(name="categoryId")
    def category_id(self) -> int:
        """
        Internet Service category ID.
        """
        return pulumi.get(self, "category_id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Internet Service name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Integer value for ending TCP/UDP/SCTP destination port in range (0 to 65535). 0 means undefined.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetInternetservicedefinitionEntryPortRangeResult']:
        """
        Port ranges in the definition entry. The structure of `port_range` block is documented below.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> int:
        """
        Integer value for the protocol type as defined by IANA (0 - 255).
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="seqNum")
    def seq_num(self) -> int:
        """
        Entry sequence number.
        """
        return pulumi.get(self, "seq_num")


@pulumi.output_type
class GetInternetservicedefinitionEntryPortRangeResult(dict):
    def __init__(__self__, *,
                 end_port: int,
                 id: int,
                 start_port: int):
        """
        :param int end_port: Ending TCP/UDP/SCTP destination port (1 to 65535).
        :param int id: Custom entry port range ID.
        :param int start_port: Starting TCP/UDP/SCTP destination port (1 to 65535).
        """
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> int:
        """
        Ending TCP/UDP/SCTP destination port (1 to 65535).
        """
        return pulumi.get(self, "end_port")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Custom entry port range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> int:
        """
        Starting TCP/UDP/SCTP destination port (1 to 65535).
        """
        return pulumi.get(self, "start_port")


@pulumi.output_type
class GetInternetserviceextensionDisableEntryResult(dict):
    def __init__(__self__, *,
                 addr_mode: str,
                 id: int,
                 ip6_ranges: Sequence['outputs.GetInternetserviceextensionDisableEntryIp6RangeResult'],
                 ip_ranges: Sequence['outputs.GetInternetserviceextensionDisableEntryIpRangeResult'],
                 port: int,
                 port_ranges: Sequence['outputs.GetInternetserviceextensionDisableEntryPortRangeResult'],
                 protocol: int):
        """
        :param str addr_mode: Address mode (IPv4 or IPv6)
        :param int id: Disable entry range ID.
        :param Sequence['GetInternetserviceextensionDisableEntryIp6RangeArgs'] ip6_ranges: IPv6 ranges in the disable entry. The structure of `ip6_range` block is documented below.
        :param Sequence['GetInternetserviceextensionDisableEntryIpRangeArgs'] ip_ranges: IP ranges in the disable entry. The structure of `ip_range` block is documented below.
        :param int port: Integer value for the TCP/IP port (0 - 65535).
        :param Sequence['GetInternetserviceextensionDisableEntryPortRangeArgs'] port_ranges: Port ranges in the disable entry. The structure of `port_range` block is documented below.
        :param int protocol: Integer value for the protocol type as defined by IANA (0 - 255).
        """
        pulumi.set(__self__, "addr_mode", addr_mode)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip6_ranges", ip6_ranges)
        pulumi.set(__self__, "ip_ranges", ip_ranges)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="addrMode")
    def addr_mode(self) -> str:
        """
        Address mode (IPv4 or IPv6)
        """
        return pulumi.get(self, "addr_mode")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Disable entry range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ip6Ranges")
    def ip6_ranges(self) -> Sequence['outputs.GetInternetserviceextensionDisableEntryIp6RangeResult']:
        """
        IPv6 ranges in the disable entry. The structure of `ip6_range` block is documented below.
        """
        return pulumi.get(self, "ip6_ranges")

    @property
    @pulumi.getter(name="ipRanges")
    def ip_ranges(self) -> Sequence['outputs.GetInternetserviceextensionDisableEntryIpRangeResult']:
        """
        IP ranges in the disable entry. The structure of `ip_range` block is documented below.
        """
        return pulumi.get(self, "ip_ranges")

    @property
    @pulumi.getter
    def port(self) -> int:
        """
        Integer value for the TCP/IP port (0 - 65535).
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetInternetserviceextensionDisableEntryPortRangeResult']:
        """
        Port ranges in the disable entry. The structure of `port_range` block is documented below.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> int:
        """
        Integer value for the protocol type as defined by IANA (0 - 255).
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetInternetserviceextensionDisableEntryIp6RangeResult(dict):
    def __init__(__self__, *,
                 end_ip6: str,
                 id: int,
                 start_ip6: str):
        """
        :param str end_ip6: End IPv6 address.
        :param int id: Disable entry range ID.
        :param str start_ip6: Start IPv6 address.
        """
        pulumi.set(__self__, "end_ip6", end_ip6)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "start_ip6", start_ip6)

    @property
    @pulumi.getter(name="endIp6")
    def end_ip6(self) -> str:
        """
        End IPv6 address.
        """
        return pulumi.get(self, "end_ip6")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Disable entry range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startIp6")
    def start_ip6(self) -> str:
        """
        Start IPv6 address.
        """
        return pulumi.get(self, "start_ip6")


@pulumi.output_type
class GetInternetserviceextensionDisableEntryIpRangeResult(dict):
    def __init__(__self__, *,
                 end_ip: str,
                 id: int,
                 start_ip: str):
        """
        :param str end_ip: End IP address.
        :param int id: Disable entry range ID.
        :param str start_ip: Start IP address.
        """
        pulumi.set(__self__, "end_ip", end_ip)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "start_ip", start_ip)

    @property
    @pulumi.getter(name="endIp")
    def end_ip(self) -> str:
        """
        End IP address.
        """
        return pulumi.get(self, "end_ip")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Disable entry range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startIp")
    def start_ip(self) -> str:
        """
        Start IP address.
        """
        return pulumi.get(self, "start_ip")


@pulumi.output_type
class GetInternetserviceextensionDisableEntryPortRangeResult(dict):
    def __init__(__self__, *,
                 end_port: int,
                 id: int,
                 start_port: int):
        """
        :param int end_port: Ending TCP/UDP/SCTP destination port (1 to 65535).
        :param int id: Disable entry range ID.
        :param int start_port: Starting TCP/UDP/SCTP destination port (1 to 65535).
        """
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> int:
        """
        Ending TCP/UDP/SCTP destination port (1 to 65535).
        """
        return pulumi.get(self, "end_port")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Disable entry range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> int:
        """
        Starting TCP/UDP/SCTP destination port (1 to 65535).
        """
        return pulumi.get(self, "start_port")


@pulumi.output_type
class GetInternetserviceextensionEntryResult(dict):
    def __init__(__self__, *,
                 addr_mode: str,
                 dst6s: Sequence['outputs.GetInternetserviceextensionEntryDst6Result'],
                 dsts: Sequence['outputs.GetInternetserviceextensionEntryDstResult'],
                 id: int,
                 port_ranges: Sequence['outputs.GetInternetserviceextensionEntryPortRangeResult'],
                 protocol: int):
        """
        :param str addr_mode: Address mode (IPv4 or IPv6)
        :param Sequence['GetInternetserviceextensionEntryDst6Args'] dst6s: Destination address6 or address6 group name. The structure of `dst6` block is documented below.
        :param Sequence['GetInternetserviceextensionEntryDstArgs'] dsts: Destination address or address group name. The structure of `dst` block is documented below.
        :param int id: Disable entry range ID.
        :param Sequence['GetInternetserviceextensionEntryPortRangeArgs'] port_ranges: Port ranges in the disable entry. The structure of `port_range` block is documented below.
        :param int protocol: Integer value for the protocol type as defined by IANA (0 - 255).
        """
        pulumi.set(__self__, "addr_mode", addr_mode)
        pulumi.set(__self__, "dst6s", dst6s)
        pulumi.set(__self__, "dsts", dsts)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "port_ranges", port_ranges)
        pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter(name="addrMode")
    def addr_mode(self) -> str:
        """
        Address mode (IPv4 or IPv6)
        """
        return pulumi.get(self, "addr_mode")

    @property
    @pulumi.getter
    def dst6s(self) -> Sequence['outputs.GetInternetserviceextensionEntryDst6Result']:
        """
        Destination address6 or address6 group name. The structure of `dst6` block is documented below.
        """
        return pulumi.get(self, "dst6s")

    @property
    @pulumi.getter
    def dsts(self) -> Sequence['outputs.GetInternetserviceextensionEntryDstResult']:
        """
        Destination address or address group name. The structure of `dst` block is documented below.
        """
        return pulumi.get(self, "dsts")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Disable entry range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="portRanges")
    def port_ranges(self) -> Sequence['outputs.GetInternetserviceextensionEntryPortRangeResult']:
        """
        Port ranges in the disable entry. The structure of `port_range` block is documented below.
        """
        return pulumi.get(self, "port_ranges")

    @property
    @pulumi.getter
    def protocol(self) -> int:
        """
        Integer value for the protocol type as defined by IANA (0 - 255).
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class GetInternetserviceextensionEntryDst6Result(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Select the destination address6 or address group object from available options.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Select the destination address6 or address group object from available options.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInternetserviceextensionEntryDstResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Select the destination address6 or address group object from available options.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Select the destination address6 or address group object from available options.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetInternetserviceextensionEntryPortRangeResult(dict):
    def __init__(__self__, *,
                 end_port: int,
                 id: int,
                 start_port: int):
        """
        :param int end_port: Ending TCP/UDP/SCTP destination port (1 to 65535).
        :param int id: Disable entry range ID.
        :param int start_port: Starting TCP/UDP/SCTP destination port (1 to 65535).
        """
        pulumi.set(__self__, "end_port", end_port)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "start_port", start_port)

    @property
    @pulumi.getter(name="endPort")
    def end_port(self) -> int:
        """
        Ending TCP/UDP/SCTP destination port (1 to 65535).
        """
        return pulumi.get(self, "end_port")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Disable entry range ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="startPort")
    def start_port(self) -> int:
        """
        Starting TCP/UDP/SCTP destination port (1 to 65535).
        """
        return pulumi.get(self, "start_port")


@pulumi.output_type
class GetInternetservicegroupMemberResult(dict):
    def __init__(__self__, *,
                 id: int,
                 name: str):
        """
        :param int id: Internet Service ID.
        :param str name: Specify the name of the desired firewall internetservicegroup.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Internet Service ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall internetservicegroup.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetMulticastaddress6TaggingResult(dict):
    def __init__(__self__, *,
                 category: str,
                 name: str,
                 tags: Sequence['outputs.GetMulticastaddress6TaggingTagResult']):
        """
        :param str category: Tag category.
        :param str name: Specify the name of the desired firewall multicastaddress6.
        :param Sequence['GetMulticastaddress6TaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall multicastaddress6.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetMulticastaddress6TaggingTagResult']:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetMulticastaddress6TaggingTagResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall multicastaddress6.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall multicastaddress6.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetMulticastaddressTaggingResult(dict):
    def __init__(__self__, *,
                 category: str,
                 name: str,
                 tags: Sequence['outputs.GetMulticastaddressTaggingTagResult']):
        """
        :param str category: Tag category.
        :param str name: Specify the name of the desired firewall multicastaddress.
        :param Sequence['GetMulticastaddressTaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall multicastaddress.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetMulticastaddressTaggingTagResult']:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetMulticastaddressTaggingTagResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall multicastaddress.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall multicastaddress.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy46DstaddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IP pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IP pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy46PoolnameResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IP pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IP pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy46ServiceResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IP pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IP pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy46SrcaddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IP pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IP pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy64DstaddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IP pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IP pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy64PoolnameResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IP pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IP pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy64ServiceResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IP pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IP pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy64SrcaddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: IP pool name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        IP pool name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy6AppCategoryResult(dict):
    def __init__(__self__, *,
                 id: int):
        """
        :param int id: URL category ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        URL category ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPolicy6AppGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Names of FSSO groups.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy6ApplicationResult(dict):
    def __init__(__self__, *,
                 id: int):
        """
        :param int id: URL category ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        URL category ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPolicy6CustomLogFieldResult(dict):
    def __init__(__self__, *,
                 field_id: str):
        """
        :param str field_id: Custom log field.
        """
        pulumi.set(__self__, "field_id", field_id)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        """
        Custom log field.
        """
        return pulumi.get(self, "field_id")


@pulumi.output_type
class GetPolicy6DeviceResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Names of FSSO groups.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy6DstaddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Names of FSSO groups.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy6DstintfResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Names of FSSO groups.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy6FssoGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Names of FSSO groups.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy6GroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Names of FSSO groups.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy6PoolnameResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Names of FSSO groups.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy6ServiceResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Names of FSSO groups.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy6SrcaddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Names of FSSO groups.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy6SrcintfResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Names of FSSO groups.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy6SslMirrorIntfResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Names of FSSO groups.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicy6UrlCategoryResult(dict):
    def __init__(__self__, *,
                 id: int):
        """
        :param int id: URL category ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        URL category ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPolicy6UserResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Names of FSSO groups.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Names of FSSO groups.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyAppCategoryResult(dict):
    def __init__(__self__, *,
                 id: int):
        """
        :param int id: Security group tag.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Security group tag.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPolicyAppGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyApplicationResult(dict):
    def __init__(__self__, *,
                 id: int):
        """
        :param int id: Security group tag.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Security group tag.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPolicyCustomLogFieldResult(dict):
    def __init__(__self__, *,
                 field_id: str):
        """
        :param str field_id: Custom log field.
        """
        pulumi.set(__self__, "field_id", field_id)

    @property
    @pulumi.getter(name="fieldId")
    def field_id(self) -> str:
        """
        Custom log field.
        """
        return pulumi.get(self, "field_id")


@pulumi.output_type
class GetPolicyDeviceResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyDstaddr6Result(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyDstaddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyDstintfResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyFssoGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetService6CustomResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetService6CustomGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetService6GroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetService6NameResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetService6SrcCustomResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetService6SrcCustomGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetService6SrcGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetService6SrcNameResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetServiceCustomResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetServiceCustomGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetServiceGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetServiceIdResult(dict):
    def __init__(__self__, *,
                 id: int):
        """
        :param int id: Security group tag.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Security group tag.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPolicyInternetServiceNameResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetServiceSrcCustomResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetServiceSrcCustomGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetServiceSrcGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyInternetServiceSrcIdResult(dict):
    def __init__(__self__, *,
                 id: int):
        """
        :param int id: Security group tag.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Security group tag.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPolicyInternetServiceSrcNameResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyNetworkServiceDynamicResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyNetworkServiceSrcDynamicResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyNtlmEnabledBrowserResult(dict):
    def __init__(__self__, *,
                 user_agent_string: str):
        """
        :param str user_agent_string: User agent string.
        """
        pulumi.set(__self__, "user_agent_string", user_agent_string)

    @property
    @pulumi.getter(name="userAgentString")
    def user_agent_string(self) -> str:
        """
        User agent string.
        """
        return pulumi.get(self, "user_agent_string")


@pulumi.output_type
class GetPolicyPcpPoolnameResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyPoolname6Result(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyPoolnameResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyRtpAddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyServiceResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicySgtResult(dict):
    def __init__(__self__, *,
                 id: int):
        """
        :param int id: Security group tag.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Security group tag.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPolicySrcVendorMacResult(dict):
    def __init__(__self__, *,
                 id: int):
        """
        :param int id: Security group tag.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Security group tag.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPolicySrcaddr6Result(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicySrcaddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicySrcintfResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicySslMirrorIntfResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyUrlCategoryResult(dict):
    def __init__(__self__, *,
                 id: int):
        """
        :param int id: Security group tag.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Security group tag.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetPolicyUserResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyZtnaEmsTagResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyZtnaEmsTagSecondaryResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetPolicyZtnaGeoTagResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Mirror Interface name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Mirror Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProfileprotocoloptionsCifResult(dict):
    def __init__(__self__, *,
                 domain_controller: str,
                 options: str,
                 oversize_limit: int,
                 ports: int,
                 scan_bzip2: str,
                 server_credential_type: str,
                 server_keytabs: Sequence['outputs.GetProfileprotocoloptionsCifServerKeytabResult'],
                 status: str,
                 tcp_window_maximum: int,
                 tcp_window_minimum: int,
                 tcp_window_size: int,
                 tcp_window_type: str,
                 uncompressed_nest_limit: int,
                 uncompressed_oversize_limit: int):
        """
        :param str domain_controller: Domain for which to decrypt CIFS traffic.
        :param str options: One or more options that can be applied to the session.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        :param int ports: Ports to scan for content (1 - 65535, default = 445).
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files.
        :param str server_credential_type: CIFS server credential type.
        :param Sequence['GetProfileprotocoloptionsCifServerKeytabArgs'] server_keytabs: Server keytab. The structure of `server_keytab` block is documented below.
        :param str status: Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        :param int tcp_window_maximum: Maximum dynamic TCP window size (default = 8MB).
        :param int tcp_window_minimum: Minimum dynamic TCP window size (default = 128KB).
        :param int tcp_window_size: Set TCP static window size (default = 256KB).
        :param str tcp_window_type: Specify type of TCP window to use for this protocol.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        pulumi.set(__self__, "domain_controller", domain_controller)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "oversize_limit", oversize_limit)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        pulumi.set(__self__, "server_credential_type", server_credential_type)
        pulumi.set(__self__, "server_keytabs", server_keytabs)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tcp_window_maximum", tcp_window_maximum)
        pulumi.set(__self__, "tcp_window_minimum", tcp_window_minimum)
        pulumi.set(__self__, "tcp_window_size", tcp_window_size)
        pulumi.set(__self__, "tcp_window_type", tcp_window_type)
        pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter(name="domainController")
    def domain_controller(self) -> str:
        """
        Domain for which to decrypt CIFS traffic.
        """
        return pulumi.get(self, "domain_controller")

    @property
    @pulumi.getter
    def options(self) -> str:
        """
        One or more options that can be applied to the session.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> int:
        """
        Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> int:
        """
        Ports to scan for content (1 - 65535, default = 445).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> str:
        """
        Enable/disable scanning of BZip2 compressed files.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter(name="serverCredentialType")
    def server_credential_type(self) -> str:
        """
        CIFS server credential type.
        """
        return pulumi.get(self, "server_credential_type")

    @property
    @pulumi.getter(name="serverKeytabs")
    def server_keytabs(self) -> Sequence['outputs.GetProfileprotocoloptionsCifServerKeytabResult']:
        """
        Server keytab. The structure of `server_keytab` block is documented below.
        """
        return pulumi.get(self, "server_keytabs")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tcpWindowMaximum")
    def tcp_window_maximum(self) -> int:
        """
        Maximum dynamic TCP window size (default = 8MB).
        """
        return pulumi.get(self, "tcp_window_maximum")

    @property
    @pulumi.getter(name="tcpWindowMinimum")
    def tcp_window_minimum(self) -> int:
        """
        Minimum dynamic TCP window size (default = 128KB).
        """
        return pulumi.get(self, "tcp_window_minimum")

    @property
    @pulumi.getter(name="tcpWindowSize")
    def tcp_window_size(self) -> int:
        """
        Set TCP static window size (default = 256KB).
        """
        return pulumi.get(self, "tcp_window_size")

    @property
    @pulumi.getter(name="tcpWindowType")
    def tcp_window_type(self) -> str:
        """
        Specify type of TCP window to use for this protocol.
        """
        return pulumi.get(self, "tcp_window_type")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> int:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> int:
        """
        Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class GetProfileprotocoloptionsCifServerKeytabResult(dict):
    def __init__(__self__, *,
                 keytab: str,
                 principal: str):
        """
        :param str keytab: Base64 encoded keytab file containing credential of the server.
        :param str principal: Service principal.  For example, "host/cifsserver.example.com@example.com".
        """
        pulumi.set(__self__, "keytab", keytab)
        pulumi.set(__self__, "principal", principal)

    @property
    @pulumi.getter
    def keytab(self) -> str:
        """
        Base64 encoded keytab file containing credential of the server.
        """
        return pulumi.get(self, "keytab")

    @property
    @pulumi.getter
    def principal(self) -> str:
        """
        Service principal.  For example, "host/cifsserver.example.com@example.com".
        """
        return pulumi.get(self, "principal")


@pulumi.output_type
class GetProfileprotocoloptionsDnResult(dict):
    def __init__(__self__, *,
                 ports: int,
                 status: str):
        """
        :param int ports: Ports to scan for content (1 - 65535, default = 445).
        :param str status: Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        """
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def ports(self) -> int:
        """
        Ports to scan for content (1 - 65535, default = 445).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetProfileprotocoloptionsFtpResult(dict):
    def __init__(__self__, *,
                 comfort_amount: int,
                 comfort_interval: int,
                 explicit_ftp_tls: str,
                 inspect_all: str,
                 options: str,
                 oversize_limit: int,
                 ports: int,
                 scan_bzip2: str,
                 ssl_offloaded: str,
                 status: str,
                 stream_based_uncompressed_limit: int,
                 tcp_window_maximum: int,
                 tcp_window_minimum: int,
                 tcp_window_size: int,
                 tcp_window_type: str,
                 uncompressed_nest_limit: int,
                 uncompressed_oversize_limit: int):
        """
        :param int comfort_amount: Amount of data to send in a transmission for client comforting (1 - 65535 bytes, default = 1).
        :param int comfort_interval: Period of time between start, or last transmission, and the next client comfort transmission of data (1 - 900 sec, default = 10).
        :param str explicit_ftp_tls: Enable/disable FTP redirection for explicit FTPS.
        :param str inspect_all: Enable/disable the inspection of all ports for the protocol.
        :param str options: One or more options that can be applied to the session.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        :param int ports: Ports to scan for content (1 - 65535, default = 445).
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files.
        :param str ssl_offloaded: SSL decryption and encryption performed by an external device.
        :param str status: Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        :param int stream_based_uncompressed_limit: Maximum stream-based uncompressed data size that will be scanned (MB, 0 = unlimited (default).  Stream-based uncompression used only under certain conditions.).
        :param int tcp_window_maximum: Maximum dynamic TCP window size (default = 8MB).
        :param int tcp_window_minimum: Minimum dynamic TCP window size (default = 128KB).
        :param int tcp_window_size: Set TCP static window size (default = 256KB).
        :param str tcp_window_type: Specify type of TCP window to use for this protocol.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        pulumi.set(__self__, "comfort_amount", comfort_amount)
        pulumi.set(__self__, "comfort_interval", comfort_interval)
        pulumi.set(__self__, "explicit_ftp_tls", explicit_ftp_tls)
        pulumi.set(__self__, "inspect_all", inspect_all)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "oversize_limit", oversize_limit)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        pulumi.set(__self__, "ssl_offloaded", ssl_offloaded)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "stream_based_uncompressed_limit", stream_based_uncompressed_limit)
        pulumi.set(__self__, "tcp_window_maximum", tcp_window_maximum)
        pulumi.set(__self__, "tcp_window_minimum", tcp_window_minimum)
        pulumi.set(__self__, "tcp_window_size", tcp_window_size)
        pulumi.set(__self__, "tcp_window_type", tcp_window_type)
        pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter(name="comfortAmount")
    def comfort_amount(self) -> int:
        """
        Amount of data to send in a transmission for client comforting (1 - 65535 bytes, default = 1).
        """
        return pulumi.get(self, "comfort_amount")

    @property
    @pulumi.getter(name="comfortInterval")
    def comfort_interval(self) -> int:
        """
        Period of time between start, or last transmission, and the next client comfort transmission of data (1 - 900 sec, default = 10).
        """
        return pulumi.get(self, "comfort_interval")

    @property
    @pulumi.getter(name="explicitFtpTls")
    def explicit_ftp_tls(self) -> str:
        """
        Enable/disable FTP redirection for explicit FTPS.
        """
        return pulumi.get(self, "explicit_ftp_tls")

    @property
    @pulumi.getter(name="inspectAll")
    def inspect_all(self) -> str:
        """
        Enable/disable the inspection of all ports for the protocol.
        """
        return pulumi.get(self, "inspect_all")

    @property
    @pulumi.getter
    def options(self) -> str:
        """
        One or more options that can be applied to the session.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> int:
        """
        Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> int:
        """
        Ports to scan for content (1 - 65535, default = 445).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> str:
        """
        Enable/disable scanning of BZip2 compressed files.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter(name="sslOffloaded")
    def ssl_offloaded(self) -> str:
        """
        SSL decryption and encryption performed by an external device.
        """
        return pulumi.get(self, "ssl_offloaded")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="streamBasedUncompressedLimit")
    def stream_based_uncompressed_limit(self) -> int:
        """
        Maximum stream-based uncompressed data size that will be scanned (MB, 0 = unlimited (default).  Stream-based uncompression used only under certain conditions.).
        """
        return pulumi.get(self, "stream_based_uncompressed_limit")

    @property
    @pulumi.getter(name="tcpWindowMaximum")
    def tcp_window_maximum(self) -> int:
        """
        Maximum dynamic TCP window size (default = 8MB).
        """
        return pulumi.get(self, "tcp_window_maximum")

    @property
    @pulumi.getter(name="tcpWindowMinimum")
    def tcp_window_minimum(self) -> int:
        """
        Minimum dynamic TCP window size (default = 128KB).
        """
        return pulumi.get(self, "tcp_window_minimum")

    @property
    @pulumi.getter(name="tcpWindowSize")
    def tcp_window_size(self) -> int:
        """
        Set TCP static window size (default = 256KB).
        """
        return pulumi.get(self, "tcp_window_size")

    @property
    @pulumi.getter(name="tcpWindowType")
    def tcp_window_type(self) -> str:
        """
        Specify type of TCP window to use for this protocol.
        """
        return pulumi.get(self, "tcp_window_type")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> int:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> int:
        """
        Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class GetProfileprotocoloptionsHttpResult(dict):
    def __init__(__self__, *,
                 address_ip_rating: str,
                 block_page_status_code: int,
                 comfort_amount: int,
                 comfort_interval: int,
                 fortinet_bar: str,
                 fortinet_bar_port: int,
                 h2c: str,
                 http_policy: str,
                 inspect_all: str,
                 options: str,
                 oversize_limit: int,
                 ports: int,
                 post_lang: str,
                 proxy_after_tcp_handshake: str,
                 range_block: str,
                 retry_count: int,
                 scan_bzip2: str,
                 ssl_offloaded: str,
                 status: str,
                 stream_based_uncompressed_limit: int,
                 streaming_content_bypass: str,
                 strip_x_forwarded_for: str,
                 switching_protocols: str,
                 tcp_window_maximum: int,
                 tcp_window_minimum: int,
                 tcp_window_size: int,
                 tcp_window_type: str,
                 tunnel_non_http: str,
                 uncompressed_nest_limit: int,
                 uncompressed_oversize_limit: int,
                 unknown_content_encoding: str,
                 unknown_http_version: str,
                 verify_dns_for_policy_matching: str):
        """
        :param str address_ip_rating: Enable/disable IP based URL rating.
        :param int block_page_status_code: Code number returned for blocked HTTP pages (non-FortiGuard only) (100 - 599, default = 403).
        :param int comfort_amount: Amount of data to send in a transmission for client comforting (1 - 65535 bytes, default = 1).
        :param int comfort_interval: Period of time between start, or last transmission, and the next client comfort transmission of data (1 - 900 sec, default = 10).
        :param str fortinet_bar: Enable/disable Fortinet bar on HTML content.
        :param int fortinet_bar_port: Port for use by Fortinet Bar (1 - 65535, default = 8011).
        :param str h2c: Enable/disable h2c HTTP connection upgrade.
        :param str http_policy: Enable/disable HTTP policy check.
        :param str inspect_all: Enable/disable the inspection of all ports for the protocol.
        :param str options: One or more options that can be applied to the session.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        :param int ports: Ports to scan for content (1 - 65535, default = 445).
        :param str post_lang: ID codes for character sets to be used to convert to UTF-8 for banned words and DLP on HTTP posts (maximum of 5 character sets).
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before).
        :param str range_block: Enable/disable blocking of partial downloads.
        :param int retry_count: Number of attempts to retry HTTP connection (0 - 100, default = 0).
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files.
        :param str ssl_offloaded: SSL decryption and encryption performed by an external device.
        :param str status: Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        :param int stream_based_uncompressed_limit: Maximum stream-based uncompressed data size that will be scanned (MB, 0 = unlimited (default).  Stream-based uncompression used only under certain conditions.).
        :param str streaming_content_bypass: Enable/disable bypassing of streaming content from buffering.
        :param str strip_x_forwarded_for: Enable/disable stripping of HTTP X-Forwarded-For header.
        :param str switching_protocols: Bypass from scanning, or block a connection that attempts to switch protocol.
        :param int tcp_window_maximum: Maximum dynamic TCP window size (default = 8MB).
        :param int tcp_window_minimum: Minimum dynamic TCP window size (default = 128KB).
        :param int tcp_window_size: Set TCP static window size (default = 256KB).
        :param str tcp_window_type: Specify type of TCP window to use for this protocol.
        :param str tunnel_non_http: Configure how to process non-HTTP traffic when a profile configured for HTTP traffic accepts a non-HTTP session. Can occur if an application sends non-HTTP traffic using an HTTP destination port.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        :param str unknown_content_encoding: Configure the action the FortiGate unit will take on unknown content-encoding.
        :param str unknown_http_version: How to handle HTTP sessions that do not comply with HTTP 0.9, 1.0, or 1.1.
        :param str verify_dns_for_policy_matching: Enable/disable verification of DNS for policy matching.
        """
        pulumi.set(__self__, "address_ip_rating", address_ip_rating)
        pulumi.set(__self__, "block_page_status_code", block_page_status_code)
        pulumi.set(__self__, "comfort_amount", comfort_amount)
        pulumi.set(__self__, "comfort_interval", comfort_interval)
        pulumi.set(__self__, "fortinet_bar", fortinet_bar)
        pulumi.set(__self__, "fortinet_bar_port", fortinet_bar_port)
        pulumi.set(__self__, "h2c", h2c)
        pulumi.set(__self__, "http_policy", http_policy)
        pulumi.set(__self__, "inspect_all", inspect_all)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "oversize_limit", oversize_limit)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "post_lang", post_lang)
        pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        pulumi.set(__self__, "range_block", range_block)
        pulumi.set(__self__, "retry_count", retry_count)
        pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        pulumi.set(__self__, "ssl_offloaded", ssl_offloaded)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "stream_based_uncompressed_limit", stream_based_uncompressed_limit)
        pulumi.set(__self__, "streaming_content_bypass", streaming_content_bypass)
        pulumi.set(__self__, "strip_x_forwarded_for", strip_x_forwarded_for)
        pulumi.set(__self__, "switching_protocols", switching_protocols)
        pulumi.set(__self__, "tcp_window_maximum", tcp_window_maximum)
        pulumi.set(__self__, "tcp_window_minimum", tcp_window_minimum)
        pulumi.set(__self__, "tcp_window_size", tcp_window_size)
        pulumi.set(__self__, "tcp_window_type", tcp_window_type)
        pulumi.set(__self__, "tunnel_non_http", tunnel_non_http)
        pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)
        pulumi.set(__self__, "unknown_content_encoding", unknown_content_encoding)
        pulumi.set(__self__, "unknown_http_version", unknown_http_version)
        pulumi.set(__self__, "verify_dns_for_policy_matching", verify_dns_for_policy_matching)

    @property
    @pulumi.getter(name="addressIpRating")
    def address_ip_rating(self) -> str:
        """
        Enable/disable IP based URL rating.
        """
        return pulumi.get(self, "address_ip_rating")

    @property
    @pulumi.getter(name="blockPageStatusCode")
    def block_page_status_code(self) -> int:
        """
        Code number returned for blocked HTTP pages (non-FortiGuard only) (100 - 599, default = 403).
        """
        return pulumi.get(self, "block_page_status_code")

    @property
    @pulumi.getter(name="comfortAmount")
    def comfort_amount(self) -> int:
        """
        Amount of data to send in a transmission for client comforting (1 - 65535 bytes, default = 1).
        """
        return pulumi.get(self, "comfort_amount")

    @property
    @pulumi.getter(name="comfortInterval")
    def comfort_interval(self) -> int:
        """
        Period of time between start, or last transmission, and the next client comfort transmission of data (1 - 900 sec, default = 10).
        """
        return pulumi.get(self, "comfort_interval")

    @property
    @pulumi.getter(name="fortinetBar")
    def fortinet_bar(self) -> str:
        """
        Enable/disable Fortinet bar on HTML content.
        """
        return pulumi.get(self, "fortinet_bar")

    @property
    @pulumi.getter(name="fortinetBarPort")
    def fortinet_bar_port(self) -> int:
        """
        Port for use by Fortinet Bar (1 - 65535, default = 8011).
        """
        return pulumi.get(self, "fortinet_bar_port")

    @property
    @pulumi.getter
    def h2c(self) -> str:
        """
        Enable/disable h2c HTTP connection upgrade.
        """
        return pulumi.get(self, "h2c")

    @property
    @pulumi.getter(name="httpPolicy")
    def http_policy(self) -> str:
        """
        Enable/disable HTTP policy check.
        """
        return pulumi.get(self, "http_policy")

    @property
    @pulumi.getter(name="inspectAll")
    def inspect_all(self) -> str:
        """
        Enable/disable the inspection of all ports for the protocol.
        """
        return pulumi.get(self, "inspect_all")

    @property
    @pulumi.getter
    def options(self) -> str:
        """
        One or more options that can be applied to the session.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> int:
        """
        Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> int:
        """
        Ports to scan for content (1 - 65535, default = 445).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="postLang")
    def post_lang(self) -> str:
        """
        ID codes for character sets to be used to convert to UTF-8 for banned words and DLP on HTTP posts (maximum of 5 character sets).
        """
        return pulumi.get(self, "post_lang")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> str:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before).
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter(name="rangeBlock")
    def range_block(self) -> str:
        """
        Enable/disable blocking of partial downloads.
        """
        return pulumi.get(self, "range_block")

    @property
    @pulumi.getter(name="retryCount")
    def retry_count(self) -> int:
        """
        Number of attempts to retry HTTP connection (0 - 100, default = 0).
        """
        return pulumi.get(self, "retry_count")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> str:
        """
        Enable/disable scanning of BZip2 compressed files.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter(name="sslOffloaded")
    def ssl_offloaded(self) -> str:
        """
        SSL decryption and encryption performed by an external device.
        """
        return pulumi.get(self, "ssl_offloaded")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="streamBasedUncompressedLimit")
    def stream_based_uncompressed_limit(self) -> int:
        """
        Maximum stream-based uncompressed data size that will be scanned (MB, 0 = unlimited (default).  Stream-based uncompression used only under certain conditions.).
        """
        return pulumi.get(self, "stream_based_uncompressed_limit")

    @property
    @pulumi.getter(name="streamingContentBypass")
    def streaming_content_bypass(self) -> str:
        """
        Enable/disable bypassing of streaming content from buffering.
        """
        return pulumi.get(self, "streaming_content_bypass")

    @property
    @pulumi.getter(name="stripXForwardedFor")
    def strip_x_forwarded_for(self) -> str:
        """
        Enable/disable stripping of HTTP X-Forwarded-For header.
        """
        return pulumi.get(self, "strip_x_forwarded_for")

    @property
    @pulumi.getter(name="switchingProtocols")
    def switching_protocols(self) -> str:
        """
        Bypass from scanning, or block a connection that attempts to switch protocol.
        """
        return pulumi.get(self, "switching_protocols")

    @property
    @pulumi.getter(name="tcpWindowMaximum")
    def tcp_window_maximum(self) -> int:
        """
        Maximum dynamic TCP window size (default = 8MB).
        """
        return pulumi.get(self, "tcp_window_maximum")

    @property
    @pulumi.getter(name="tcpWindowMinimum")
    def tcp_window_minimum(self) -> int:
        """
        Minimum dynamic TCP window size (default = 128KB).
        """
        return pulumi.get(self, "tcp_window_minimum")

    @property
    @pulumi.getter(name="tcpWindowSize")
    def tcp_window_size(self) -> int:
        """
        Set TCP static window size (default = 256KB).
        """
        return pulumi.get(self, "tcp_window_size")

    @property
    @pulumi.getter(name="tcpWindowType")
    def tcp_window_type(self) -> str:
        """
        Specify type of TCP window to use for this protocol.
        """
        return pulumi.get(self, "tcp_window_type")

    @property
    @pulumi.getter(name="tunnelNonHttp")
    def tunnel_non_http(self) -> str:
        """
        Configure how to process non-HTTP traffic when a profile configured for HTTP traffic accepts a non-HTTP session. Can occur if an application sends non-HTTP traffic using an HTTP destination port.
        """
        return pulumi.get(self, "tunnel_non_http")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> int:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> int:
        """
        Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")

    @property
    @pulumi.getter(name="unknownContentEncoding")
    def unknown_content_encoding(self) -> str:
        """
        Configure the action the FortiGate unit will take on unknown content-encoding.
        """
        return pulumi.get(self, "unknown_content_encoding")

    @property
    @pulumi.getter(name="unknownHttpVersion")
    def unknown_http_version(self) -> str:
        """
        How to handle HTTP sessions that do not comply with HTTP 0.9, 1.0, or 1.1.
        """
        return pulumi.get(self, "unknown_http_version")

    @property
    @pulumi.getter(name="verifyDnsForPolicyMatching")
    def verify_dns_for_policy_matching(self) -> str:
        """
        Enable/disable verification of DNS for policy matching.
        """
        return pulumi.get(self, "verify_dns_for_policy_matching")


@pulumi.output_type
class GetProfileprotocoloptionsImapResult(dict):
    def __init__(__self__, *,
                 inspect_all: str,
                 options: str,
                 oversize_limit: int,
                 ports: int,
                 proxy_after_tcp_handshake: str,
                 scan_bzip2: str,
                 ssl_offloaded: str,
                 status: str,
                 uncompressed_nest_limit: int,
                 uncompressed_oversize_limit: int):
        """
        :param str inspect_all: Enable/disable the inspection of all ports for the protocol.
        :param str options: One or more options that can be applied to the session.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        :param int ports: Ports to scan for content (1 - 65535, default = 445).
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before).
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files.
        :param str ssl_offloaded: SSL decryption and encryption performed by an external device.
        :param str status: Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        pulumi.set(__self__, "inspect_all", inspect_all)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "oversize_limit", oversize_limit)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        pulumi.set(__self__, "ssl_offloaded", ssl_offloaded)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter(name="inspectAll")
    def inspect_all(self) -> str:
        """
        Enable/disable the inspection of all ports for the protocol.
        """
        return pulumi.get(self, "inspect_all")

    @property
    @pulumi.getter
    def options(self) -> str:
        """
        One or more options that can be applied to the session.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> int:
        """
        Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> int:
        """
        Ports to scan for content (1 - 65535, default = 445).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> str:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before).
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> str:
        """
        Enable/disable scanning of BZip2 compressed files.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter(name="sslOffloaded")
    def ssl_offloaded(self) -> str:
        """
        SSL decryption and encryption performed by an external device.
        """
        return pulumi.get(self, "ssl_offloaded")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> int:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> int:
        """
        Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class GetProfileprotocoloptionsMailSignatureResult(dict):
    def __init__(__self__, *,
                 signature: str,
                 status: str):
        """
        :param str signature: Email signature to be added to outgoing email (if the signature contains spaces, enclose with quotation marks).
        :param str status: Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        """
        pulumi.set(__self__, "signature", signature)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def signature(self) -> str:
        """
        Email signature to be added to outgoing email (if the signature contains spaces, enclose with quotation marks).
        """
        return pulumi.get(self, "signature")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetProfileprotocoloptionsMapiResult(dict):
    def __init__(__self__, *,
                 options: str,
                 oversize_limit: int,
                 ports: int,
                 scan_bzip2: str,
                 status: str,
                 uncompressed_nest_limit: int,
                 uncompressed_oversize_limit: int):
        """
        :param str options: One or more options that can be applied to the session.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        :param int ports: Ports to scan for content (1 - 65535, default = 445).
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files.
        :param str status: Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "oversize_limit", oversize_limit)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter
    def options(self) -> str:
        """
        One or more options that can be applied to the session.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> int:
        """
        Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> int:
        """
        Ports to scan for content (1 - 65535, default = 445).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> str:
        """
        Enable/disable scanning of BZip2 compressed files.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> int:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> int:
        """
        Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class GetProfileprotocoloptionsNntpResult(dict):
    def __init__(__self__, *,
                 inspect_all: str,
                 options: str,
                 oversize_limit: int,
                 ports: int,
                 proxy_after_tcp_handshake: str,
                 scan_bzip2: str,
                 status: str,
                 uncompressed_nest_limit: int,
                 uncompressed_oversize_limit: int):
        """
        :param str inspect_all: Enable/disable the inspection of all ports for the protocol.
        :param str options: One or more options that can be applied to the session.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        :param int ports: Ports to scan for content (1 - 65535, default = 445).
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before).
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files.
        :param str status: Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        pulumi.set(__self__, "inspect_all", inspect_all)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "oversize_limit", oversize_limit)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter(name="inspectAll")
    def inspect_all(self) -> str:
        """
        Enable/disable the inspection of all ports for the protocol.
        """
        return pulumi.get(self, "inspect_all")

    @property
    @pulumi.getter
    def options(self) -> str:
        """
        One or more options that can be applied to the session.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> int:
        """
        Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> int:
        """
        Ports to scan for content (1 - 65535, default = 445).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> str:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before).
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> str:
        """
        Enable/disable scanning of BZip2 compressed files.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> int:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> int:
        """
        Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class GetProfileprotocoloptionsPop3Result(dict):
    def __init__(__self__, *,
                 inspect_all: str,
                 options: str,
                 oversize_limit: int,
                 ports: int,
                 proxy_after_tcp_handshake: str,
                 scan_bzip2: str,
                 ssl_offloaded: str,
                 status: str,
                 uncompressed_nest_limit: int,
                 uncompressed_oversize_limit: int):
        """
        :param str inspect_all: Enable/disable the inspection of all ports for the protocol.
        :param str options: One or more options that can be applied to the session.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        :param int ports: Ports to scan for content (1 - 65535, default = 445).
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before).
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files.
        :param str ssl_offloaded: SSL decryption and encryption performed by an external device.
        :param str status: Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        pulumi.set(__self__, "inspect_all", inspect_all)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "oversize_limit", oversize_limit)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        pulumi.set(__self__, "ssl_offloaded", ssl_offloaded)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter(name="inspectAll")
    def inspect_all(self) -> str:
        """
        Enable/disable the inspection of all ports for the protocol.
        """
        return pulumi.get(self, "inspect_all")

    @property
    @pulumi.getter
    def options(self) -> str:
        """
        One or more options that can be applied to the session.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> int:
        """
        Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> int:
        """
        Ports to scan for content (1 - 65535, default = 445).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> str:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before).
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> str:
        """
        Enable/disable scanning of BZip2 compressed files.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter(name="sslOffloaded")
    def ssl_offloaded(self) -> str:
        """
        SSL decryption and encryption performed by an external device.
        """
        return pulumi.get(self, "ssl_offloaded")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> int:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> int:
        """
        Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class GetProfileprotocoloptionsSmtpResult(dict):
    def __init__(__self__, *,
                 inspect_all: str,
                 options: str,
                 oversize_limit: int,
                 ports: int,
                 proxy_after_tcp_handshake: str,
                 scan_bzip2: str,
                 server_busy: str,
                 ssl_offloaded: str,
                 status: str,
                 uncompressed_nest_limit: int,
                 uncompressed_oversize_limit: int):
        """
        :param str inspect_all: Enable/disable the inspection of all ports for the protocol.
        :param str options: One or more options that can be applied to the session.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        :param int ports: Ports to scan for content (1 - 65535, default = 445).
        :param str proxy_after_tcp_handshake: Proxy traffic after the TCP 3-way handshake has been established (not before).
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files.
        :param str server_busy: Enable/disable SMTP server busy when server not available.
        :param str ssl_offloaded: SSL decryption and encryption performed by an external device.
        :param str status: Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        pulumi.set(__self__, "inspect_all", inspect_all)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "oversize_limit", oversize_limit)
        pulumi.set(__self__, "ports", ports)
        pulumi.set(__self__, "proxy_after_tcp_handshake", proxy_after_tcp_handshake)
        pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        pulumi.set(__self__, "server_busy", server_busy)
        pulumi.set(__self__, "ssl_offloaded", ssl_offloaded)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter(name="inspectAll")
    def inspect_all(self) -> str:
        """
        Enable/disable the inspection of all ports for the protocol.
        """
        return pulumi.get(self, "inspect_all")

    @property
    @pulumi.getter
    def options(self) -> str:
        """
        One or more options that can be applied to the session.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> int:
        """
        Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter
    def ports(self) -> int:
        """
        Ports to scan for content (1 - 65535, default = 445).
        """
        return pulumi.get(self, "ports")

    @property
    @pulumi.getter(name="proxyAfterTcpHandshake")
    def proxy_after_tcp_handshake(self) -> str:
        """
        Proxy traffic after the TCP 3-way handshake has been established (not before).
        """
        return pulumi.get(self, "proxy_after_tcp_handshake")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> str:
        """
        Enable/disable scanning of BZip2 compressed files.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter(name="serverBusy")
    def server_busy(self) -> str:
        """
        Enable/disable SMTP server busy when server not available.
        """
        return pulumi.get(self, "server_busy")

    @property
    @pulumi.getter(name="sslOffloaded")
    def ssl_offloaded(self) -> str:
        """
        SSL decryption and encryption performed by an external device.
        """
        return pulumi.get(self, "ssl_offloaded")

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        Enable/disable adding an email signature to SMTP email messages as they pass through the FortiGate.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> int:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> int:
        """
        Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class GetProfileprotocoloptionsSshResult(dict):
    def __init__(__self__, *,
                 comfort_amount: int,
                 comfort_interval: int,
                 options: str,
                 oversize_limit: int,
                 scan_bzip2: str,
                 ssl_offloaded: str,
                 stream_based_uncompressed_limit: int,
                 tcp_window_maximum: int,
                 tcp_window_minimum: int,
                 tcp_window_size: int,
                 tcp_window_type: str,
                 uncompressed_nest_limit: int,
                 uncompressed_oversize_limit: int):
        """
        :param int comfort_amount: Amount of data to send in a transmission for client comforting (1 - 65535 bytes, default = 1).
        :param int comfort_interval: Period of time between start, or last transmission, and the next client comfort transmission of data (1 - 900 sec, default = 10).
        :param str options: One or more options that can be applied to the session.
        :param int oversize_limit: Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        :param str scan_bzip2: Enable/disable scanning of BZip2 compressed files.
        :param str ssl_offloaded: SSL decryption and encryption performed by an external device.
        :param int stream_based_uncompressed_limit: Maximum stream-based uncompressed data size that will be scanned (MB, 0 = unlimited (default).  Stream-based uncompression used only under certain conditions.).
        :param int tcp_window_maximum: Maximum dynamic TCP window size (default = 8MB).
        :param int tcp_window_minimum: Minimum dynamic TCP window size (default = 128KB).
        :param int tcp_window_size: Set TCP static window size (default = 256KB).
        :param str tcp_window_type: Specify type of TCP window to use for this protocol.
        :param int uncompressed_nest_limit: Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        :param int uncompressed_oversize_limit: Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        pulumi.set(__self__, "comfort_amount", comfort_amount)
        pulumi.set(__self__, "comfort_interval", comfort_interval)
        pulumi.set(__self__, "options", options)
        pulumi.set(__self__, "oversize_limit", oversize_limit)
        pulumi.set(__self__, "scan_bzip2", scan_bzip2)
        pulumi.set(__self__, "ssl_offloaded", ssl_offloaded)
        pulumi.set(__self__, "stream_based_uncompressed_limit", stream_based_uncompressed_limit)
        pulumi.set(__self__, "tcp_window_maximum", tcp_window_maximum)
        pulumi.set(__self__, "tcp_window_minimum", tcp_window_minimum)
        pulumi.set(__self__, "tcp_window_size", tcp_window_size)
        pulumi.set(__self__, "tcp_window_type", tcp_window_type)
        pulumi.set(__self__, "uncompressed_nest_limit", uncompressed_nest_limit)
        pulumi.set(__self__, "uncompressed_oversize_limit", uncompressed_oversize_limit)

    @property
    @pulumi.getter(name="comfortAmount")
    def comfort_amount(self) -> int:
        """
        Amount of data to send in a transmission for client comforting (1 - 65535 bytes, default = 1).
        """
        return pulumi.get(self, "comfort_amount")

    @property
    @pulumi.getter(name="comfortInterval")
    def comfort_interval(self) -> int:
        """
        Period of time between start, or last transmission, and the next client comfort transmission of data (1 - 900 sec, default = 10).
        """
        return pulumi.get(self, "comfort_interval")

    @property
    @pulumi.getter
    def options(self) -> str:
        """
        One or more options that can be applied to the session.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter(name="oversizeLimit")
    def oversize_limit(self) -> int:
        """
        Maximum in-memory file size that can be scanned (1 - 383 MB, default = 10).
        """
        return pulumi.get(self, "oversize_limit")

    @property
    @pulumi.getter(name="scanBzip2")
    def scan_bzip2(self) -> str:
        """
        Enable/disable scanning of BZip2 compressed files.
        """
        return pulumi.get(self, "scan_bzip2")

    @property
    @pulumi.getter(name="sslOffloaded")
    def ssl_offloaded(self) -> str:
        """
        SSL decryption and encryption performed by an external device.
        """
        return pulumi.get(self, "ssl_offloaded")

    @property
    @pulumi.getter(name="streamBasedUncompressedLimit")
    def stream_based_uncompressed_limit(self) -> int:
        """
        Maximum stream-based uncompressed data size that will be scanned (MB, 0 = unlimited (default).  Stream-based uncompression used only under certain conditions.).
        """
        return pulumi.get(self, "stream_based_uncompressed_limit")

    @property
    @pulumi.getter(name="tcpWindowMaximum")
    def tcp_window_maximum(self) -> int:
        """
        Maximum dynamic TCP window size (default = 8MB).
        """
        return pulumi.get(self, "tcp_window_maximum")

    @property
    @pulumi.getter(name="tcpWindowMinimum")
    def tcp_window_minimum(self) -> int:
        """
        Minimum dynamic TCP window size (default = 128KB).
        """
        return pulumi.get(self, "tcp_window_minimum")

    @property
    @pulumi.getter(name="tcpWindowSize")
    def tcp_window_size(self) -> int:
        """
        Set TCP static window size (default = 256KB).
        """
        return pulumi.get(self, "tcp_window_size")

    @property
    @pulumi.getter(name="tcpWindowType")
    def tcp_window_type(self) -> str:
        """
        Specify type of TCP window to use for this protocol.
        """
        return pulumi.get(self, "tcp_window_type")

    @property
    @pulumi.getter(name="uncompressedNestLimit")
    def uncompressed_nest_limit(self) -> int:
        """
        Maximum nested levels of compression that can be uncompressed and scanned (2 - 100, default = 12).
        """
        return pulumi.get(self, "uncompressed_nest_limit")

    @property
    @pulumi.getter(name="uncompressedOversizeLimit")
    def uncompressed_oversize_limit(self) -> int:
        """
        Maximum in-memory uncompressed file size that can be scanned (0 - 383 MB, 0 = unlimited, default = 10).
        """
        return pulumi.get(self, "uncompressed_oversize_limit")


@pulumi.output_type
class GetProxyaddressApplicationResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall proxyaddress.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall proxyaddress.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxyaddressCategoryResult(dict):
    def __init__(__self__, *,
                 id: int):
        """
        :param int id: ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetProxyaddressHeaderGroupResult(dict):
    def __init__(__self__, *,
                 case_sensitivity: str,
                 header: str,
                 header_name: str,
                 id: int):
        """
        :param str case_sensitivity: Case sensitivity in pattern.
        :param str header: HTTP header regular expression.
        :param str header_name: HTTP header.
        :param int id: ID.
        """
        pulumi.set(__self__, "case_sensitivity", case_sensitivity)
        pulumi.set(__self__, "header", header)
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="caseSensitivity")
    def case_sensitivity(self) -> str:
        """
        Case sensitivity in pattern.
        """
        return pulumi.get(self, "case_sensitivity")

    @property
    @pulumi.getter
    def header(self) -> str:
        """
        HTTP header regular expression.
        """
        return pulumi.get(self, "header")

    @property
    @pulumi.getter(name="headerName")
    def header_name(self) -> str:
        """
        HTTP header.
        """
        return pulumi.get(self, "header_name")

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetProxyaddressTaggingResult(dict):
    def __init__(__self__, *,
                 category: str,
                 name: str,
                 tags: Sequence['outputs.GetProxyaddressTaggingTagResult']):
        """
        :param str category: Tag category.
        :param str name: Specify the name of the desired firewall proxyaddress.
        :param Sequence['GetProxyaddressTaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall proxyaddress.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetProxyaddressTaggingTagResult']:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetProxyaddressTaggingTagResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall proxyaddress.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall proxyaddress.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxyaddrgrpMemberResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall proxyaddrgrp.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall proxyaddrgrp.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxyaddrgrpTaggingResult(dict):
    def __init__(__self__, *,
                 category: str,
                 name: str,
                 tags: Sequence['outputs.GetProxyaddrgrpTaggingTagResult']):
        """
        :param str category: Tag category.
        :param str name: Specify the name of the desired firewall proxyaddrgrp.
        :param Sequence['GetProxyaddrgrpTaggingTagArgs'] tags: Tags. The structure of `tags` block is documented below.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def category(self) -> str:
        """
        Tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall proxyaddrgrp.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def tags(self) -> Sequence['outputs.GetProxyaddrgrpTaggingTagResult']:
        """
        Tags. The structure of `tags` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class GetProxyaddrgrpTaggingTagResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Specify the name of the desired firewall proxyaddrgrp.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Specify the name of the desired firewall proxyaddrgrp.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyAccessProxy6Result(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyAccessProxyResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyDstaddr6Result(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyDstaddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyDstintfResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyInternetService6CustomResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyInternetService6CustomGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyInternetService6GroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyInternetService6NameResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyInternetServiceCustomResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyInternetServiceCustomGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyInternetServiceGroupResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyInternetServiceIdResult(dict):
    def __init__(__self__, *,
                 id: int):
        """
        :param int id: Internet Service ID.
        """
        pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> int:
        """
        Internet Service ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetProxypolicyInternetServiceNameResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyPoolnameResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyServiceResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicySrcaddr6Result(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicySrcaddrResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicySrcintfResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyUserResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetProxypolicyZtnaEmsTagResult(dict):
    def __init__(__self__, *,
                 name: str):
        """
        :param str name: Group name.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Group name.
        """
        return pulumi.get(self, "name")


