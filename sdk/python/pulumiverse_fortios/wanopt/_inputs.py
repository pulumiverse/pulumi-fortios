# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'CacheserviceDstPeerArgs',
    'CacheserviceSrcPeerArgs',
    'ContentdeliverynetworkruleHostDomainNameSuffixArgs',
    'ContentdeliverynetworkruleRuleArgs',
    'ContentdeliverynetworkruleRuleContentIdArgs',
    'ContentdeliverynetworkruleRuleMatchEntryArgs',
    'ContentdeliverynetworkruleRuleMatchEntryPatternArgs',
    'ContentdeliverynetworkruleRuleSkipEntryArgs',
    'ContentdeliverynetworkruleRuleSkipEntryPatternArgs',
    'ProfileCifsArgs',
    'ProfileFtpArgs',
    'ProfileHttpArgs',
    'ProfileMapiArgs',
    'ProfileTcpArgs',
]

@pulumi.input_type
class CacheserviceDstPeerArgs:
    def __init__(__self__, *,
                 auth_type: Optional[pulumi.Input[int]] = None,
                 device_id: Optional[pulumi.Input[str]] = None,
                 encode_type: Optional[pulumi.Input[int]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] auth_type: Set authentication type for this peer.
        :param pulumi.Input[str] device_id: Device ID of this peer.
        :param pulumi.Input[int] encode_type: Set encode type for this peer.
        :param pulumi.Input[str] ip: Set cluster IP address of this peer.
        :param pulumi.Input[int] priority: Set priority for this peer.
        """
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if encode_type is not None:
            pulumi.set(__self__, "encode_type", encode_type)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[int]]:
        """
        Set authentication type for this peer.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[str]]:
        """
        Device ID of this peer.
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_id", value)

    @property
    @pulumi.getter(name="encodeType")
    def encode_type(self) -> Optional[pulumi.Input[int]]:
        """
        Set encode type for this peer.
        """
        return pulumi.get(self, "encode_type")

    @encode_type.setter
    def encode_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "encode_type", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        Set cluster IP address of this peer.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Set priority for this peer.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)


@pulumi.input_type
class CacheserviceSrcPeerArgs:
    def __init__(__self__, *,
                 auth_type: Optional[pulumi.Input[int]] = None,
                 device_id: Optional[pulumi.Input[str]] = None,
                 encode_type: Optional[pulumi.Input[int]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] auth_type: Set authentication type for this peer.
        :param pulumi.Input[str] device_id: Device ID of this peer.
        :param pulumi.Input[int] encode_type: Set encode type for this peer.
        :param pulumi.Input[str] ip: Set cluster IP address of this peer.
        :param pulumi.Input[int] priority: Set priority for this peer.
        """
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if encode_type is not None:
            pulumi.set(__self__, "encode_type", encode_type)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[pulumi.Input[int]]:
        """
        Set authentication type for this peer.
        """
        return pulumi.get(self, "auth_type")

    @auth_type.setter
    def auth_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "auth_type", value)

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[pulumi.Input[str]]:
        """
        Device ID of this peer.
        """
        return pulumi.get(self, "device_id")

    @device_id.setter
    def device_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "device_id", value)

    @property
    @pulumi.getter(name="encodeType")
    def encode_type(self) -> Optional[pulumi.Input[int]]:
        """
        Set encode type for this peer.
        """
        return pulumi.get(self, "encode_type")

    @encode_type.setter
    def encode_type(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "encode_type", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        Set cluster IP address of this peer.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[int]]:
        """
        Set priority for this peer.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "priority", value)


@pulumi.input_type
class ContentdeliverynetworkruleHostDomainNameSuffixArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Suffix portion of the fully qualified domain name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Suffix portion of the fully qualified domain name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


@pulumi.input_type
class ContentdeliverynetworkruleRuleArgs:
    def __init__(__self__, *,
                 content_id: Optional[pulumi.Input['ContentdeliverynetworkruleRuleContentIdArgs']] = None,
                 match_entries: Optional[pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleMatchEntryArgs']]]] = None,
                 match_mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 skip_entries: Optional[pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleSkipEntryArgs']]]] = None,
                 skip_rule_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ContentdeliverynetworkruleRuleContentIdArgs'] content_id: Content ID settings. The structure of `content_id` block is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleMatchEntryArgs']]] match_entries: List of entries to match. The structure of `match_entries` block is documented below.
        :param pulumi.Input[str] match_mode: Match criteria for collecting content ID. Valid values: `all`, `any`.
        :param pulumi.Input[str] name: WAN optimization content delivery network rule name.
        :param pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleSkipEntryArgs']]] skip_entries: List of entries to skip. The structure of `skip_entries` block is documented below.
        :param pulumi.Input[str] skip_rule_mode: Skip mode when evaluating skip-rules. Valid values: `all`, `any`.
        """
        if content_id is not None:
            pulumi.set(__self__, "content_id", content_id)
        if match_entries is not None:
            pulumi.set(__self__, "match_entries", match_entries)
        if match_mode is not None:
            pulumi.set(__self__, "match_mode", match_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if skip_entries is not None:
            pulumi.set(__self__, "skip_entries", skip_entries)
        if skip_rule_mode is not None:
            pulumi.set(__self__, "skip_rule_mode", skip_rule_mode)

    @property
    @pulumi.getter(name="contentId")
    def content_id(self) -> Optional[pulumi.Input['ContentdeliverynetworkruleRuleContentIdArgs']]:
        """
        Content ID settings. The structure of `content_id` block is documented below.
        """
        return pulumi.get(self, "content_id")

    @content_id.setter
    def content_id(self, value: Optional[pulumi.Input['ContentdeliverynetworkruleRuleContentIdArgs']]):
        pulumi.set(self, "content_id", value)

    @property
    @pulumi.getter(name="matchEntries")
    def match_entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleMatchEntryArgs']]]]:
        """
        List of entries to match. The structure of `match_entries` block is documented below.
        """
        return pulumi.get(self, "match_entries")

    @match_entries.setter
    def match_entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleMatchEntryArgs']]]]):
        pulumi.set(self, "match_entries", value)

    @property
    @pulumi.getter(name="matchMode")
    def match_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Match criteria for collecting content ID. Valid values: `all`, `any`.
        """
        return pulumi.get(self, "match_mode")

    @match_mode.setter
    def match_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "match_mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        WAN optimization content delivery network rule name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="skipEntries")
    def skip_entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleSkipEntryArgs']]]]:
        """
        List of entries to skip. The structure of `skip_entries` block is documented below.
        """
        return pulumi.get(self, "skip_entries")

    @skip_entries.setter
    def skip_entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleSkipEntryArgs']]]]):
        pulumi.set(self, "skip_entries", value)

    @property
    @pulumi.getter(name="skipRuleMode")
    def skip_rule_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Skip mode when evaluating skip-rules. Valid values: `all`, `any`.
        """
        return pulumi.get(self, "skip_rule_mode")

    @skip_rule_mode.setter
    def skip_rule_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "skip_rule_mode", value)


@pulumi.input_type
class ContentdeliverynetworkruleRuleContentIdArgs:
    def __init__(__self__, *,
                 end_direction: Optional[pulumi.Input[str]] = None,
                 end_skip: Optional[pulumi.Input[int]] = None,
                 end_str: Optional[pulumi.Input[str]] = None,
                 range_str: Optional[pulumi.Input[str]] = None,
                 start_direction: Optional[pulumi.Input[str]] = None,
                 start_skip: Optional[pulumi.Input[int]] = None,
                 start_str: Optional[pulumi.Input[str]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] end_direction: Search direction from end-str match. Valid values: `forward`, `backward`.
        :param pulumi.Input[int] end_skip: Number of characters in URL to skip after end-str has been matched.
        :param pulumi.Input[str] end_str: String from which to end search.
        :param pulumi.Input[str] range_str: Name of content ID within the start string and end string.
        :param pulumi.Input[str] start_direction: Search direction from start-str match. Valid values: `forward`, `backward`.
        :param pulumi.Input[int] start_skip: Number of characters in URL to skip after start-str has been matched.
        :param pulumi.Input[str] start_str: String from which to start search.
        :param pulumi.Input[str] target: Option in HTTP header or URL parameter to match. Valid values: `path`, `parameter`, `referrer`, `youtube-map`, `youtube-id`, `youku-id`, `hls-manifest`, `dash-manifest`, `hls-fragment`, `dash-fragment`.
        """
        if end_direction is not None:
            pulumi.set(__self__, "end_direction", end_direction)
        if end_skip is not None:
            pulumi.set(__self__, "end_skip", end_skip)
        if end_str is not None:
            pulumi.set(__self__, "end_str", end_str)
        if range_str is not None:
            pulumi.set(__self__, "range_str", range_str)
        if start_direction is not None:
            pulumi.set(__self__, "start_direction", start_direction)
        if start_skip is not None:
            pulumi.set(__self__, "start_skip", start_skip)
        if start_str is not None:
            pulumi.set(__self__, "start_str", start_str)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="endDirection")
    def end_direction(self) -> Optional[pulumi.Input[str]]:
        """
        Search direction from end-str match. Valid values: `forward`, `backward`.
        """
        return pulumi.get(self, "end_direction")

    @end_direction.setter
    def end_direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_direction", value)

    @property
    @pulumi.getter(name="endSkip")
    def end_skip(self) -> Optional[pulumi.Input[int]]:
        """
        Number of characters in URL to skip after end-str has been matched.
        """
        return pulumi.get(self, "end_skip")

    @end_skip.setter
    def end_skip(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "end_skip", value)

    @property
    @pulumi.getter(name="endStr")
    def end_str(self) -> Optional[pulumi.Input[str]]:
        """
        String from which to end search.
        """
        return pulumi.get(self, "end_str")

    @end_str.setter
    def end_str(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_str", value)

    @property
    @pulumi.getter(name="rangeStr")
    def range_str(self) -> Optional[pulumi.Input[str]]:
        """
        Name of content ID within the start string and end string.
        """
        return pulumi.get(self, "range_str")

    @range_str.setter
    def range_str(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "range_str", value)

    @property
    @pulumi.getter(name="startDirection")
    def start_direction(self) -> Optional[pulumi.Input[str]]:
        """
        Search direction from start-str match. Valid values: `forward`, `backward`.
        """
        return pulumi.get(self, "start_direction")

    @start_direction.setter
    def start_direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_direction", value)

    @property
    @pulumi.getter(name="startSkip")
    def start_skip(self) -> Optional[pulumi.Input[int]]:
        """
        Number of characters in URL to skip after start-str has been matched.
        """
        return pulumi.get(self, "start_skip")

    @start_skip.setter
    def start_skip(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "start_skip", value)

    @property
    @pulumi.getter(name="startStr")
    def start_str(self) -> Optional[pulumi.Input[str]]:
        """
        String from which to start search.
        """
        return pulumi.get(self, "start_str")

    @start_str.setter
    def start_str(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_str", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Option in HTTP header or URL parameter to match. Valid values: `path`, `parameter`, `referrer`, `youtube-map`, `youtube-id`, `youku-id`, `hls-manifest`, `dash-manifest`, `hls-fragment`, `dash-fragment`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


@pulumi.input_type
class ContentdeliverynetworkruleRuleMatchEntryArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[int]] = None,
                 patterns: Optional[pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleMatchEntryPatternArgs']]]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] id: Rule ID.
        :param pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleMatchEntryPatternArgs']]] patterns: Pattern string for matching target (Referrer or URL pattern, eg. "a", "a*c", "*a*", "a*c*e", and "*"). The structure of `pattern` block is documented below.
        :param pulumi.Input[str] target: Option in HTTP header or URL parameter to match. Valid values: `path`, `parameter`, `referrer`, `youtube-map`, `youtube-id`, `youku-id`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        Rule ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleMatchEntryPatternArgs']]]]:
        """
        Pattern string for matching target (Referrer or URL pattern, eg. "a", "a*c", "*a*", "a*c*e", and "*"). The structure of `pattern` block is documented below.
        """
        return pulumi.get(self, "patterns")

    @patterns.setter
    def patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleMatchEntryPatternArgs']]]]):
        pulumi.set(self, "patterns", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Option in HTTP header or URL parameter to match. Valid values: `path`, `parameter`, `referrer`, `youtube-map`, `youtube-id`, `youku-id`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


@pulumi.input_type
class ContentdeliverynetworkruleRuleMatchEntryPatternArgs:
    def __init__(__self__, *,
                 string: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] string: Pattern strings.
        """
        if string is not None:
            pulumi.set(__self__, "string", string)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        """
        Pattern strings.
        """
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)


@pulumi.input_type
class ContentdeliverynetworkruleRuleSkipEntryArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[int]] = None,
                 patterns: Optional[pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleSkipEntryPatternArgs']]]] = None,
                 target: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] id: Rule ID.
        :param pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleSkipEntryPatternArgs']]] patterns: Pattern string for matching target (Referrer or URL pattern, eg. "a", "a*c", "*a*", "a*c*e", and "*"). The structure of `pattern` block is documented below.
        :param pulumi.Input[str] target: Option in HTTP header or URL parameter to match. Valid values: `path`, `parameter`, `referrer`, `youtube-map`, `youtube-id`, `youku-id`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[int]]:
        """
        Rule ID.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleSkipEntryPatternArgs']]]]:
        """
        Pattern string for matching target (Referrer or URL pattern, eg. "a", "a*c", "*a*", "a*c*e", and "*"). The structure of `pattern` block is documented below.
        """
        return pulumi.get(self, "patterns")

    @patterns.setter
    def patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ContentdeliverynetworkruleRuleSkipEntryPatternArgs']]]]):
        pulumi.set(self, "patterns", value)

    @property
    @pulumi.getter
    def target(self) -> Optional[pulumi.Input[str]]:
        """
        Option in HTTP header or URL parameter to match. Valid values: `path`, `parameter`, `referrer`, `youtube-map`, `youtube-id`, `youku-id`.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "target", value)


@pulumi.input_type
class ContentdeliverynetworkruleRuleSkipEntryPatternArgs:
    def __init__(__self__, *,
                 string: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] string: Pattern strings.
        """
        if string is not None:
            pulumi.set(__self__, "string", string)

    @property
    @pulumi.getter
    def string(self) -> Optional[pulumi.Input[str]]:
        """
        Pattern strings.
        """
        return pulumi.get(self, "string")

    @string.setter
    def string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string", value)


@pulumi.input_type
class ProfileCifsArgs:
    def __init__(__self__, *,
                 byte_caching: Optional[pulumi.Input[str]] = None,
                 log_traffic: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 prefer_chunking: Optional[pulumi.Input[str]] = None,
                 protocol_opt: Optional[pulumi.Input[str]] = None,
                 secure_tunnel: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tunnel_sharing: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] byte_caching: Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        :param pulumi.Input[str] log_traffic: Enable/disable logging. Valid values: `enable`, `disable`.
        :param pulumi.Input[int] port: Single port number or port number range for CIFS. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        :param pulumi.Input[str] prefer_chunking: Select dynamic or fixed-size data chunking for HTTP WAN Optimization. Valid values: `dynamic`, `fix`.
        :param pulumi.Input[str] protocol_opt: Select Protocol specific optimitation or generic TCP optimization. Valid values: `protocol`, `tcp`.
        :param pulumi.Input[str] secure_tunnel: Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        :param pulumi.Input[str] status: Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        :param pulumi.Input[str] tunnel_sharing: Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        if byte_caching is not None:
            pulumi.set(__self__, "byte_caching", byte_caching)
        if log_traffic is not None:
            pulumi.set(__self__, "log_traffic", log_traffic)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefer_chunking is not None:
            pulumi.set(__self__, "prefer_chunking", prefer_chunking)
        if protocol_opt is not None:
            pulumi.set(__self__, "protocol_opt", protocol_opt)
        if secure_tunnel is not None:
            pulumi.set(__self__, "secure_tunnel", secure_tunnel)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tunnel_sharing is not None:
            pulumi.set(__self__, "tunnel_sharing", tunnel_sharing)

    @property
    @pulumi.getter(name="byteCaching")
    def byte_caching(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "byte_caching")

    @byte_caching.setter
    def byte_caching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "byte_caching", value)

    @property
    @pulumi.getter(name="logTraffic")
    def log_traffic(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log_traffic")

    @log_traffic.setter
    def log_traffic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_traffic", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Single port number or port number range for CIFS. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="preferChunking")
    def prefer_chunking(self) -> Optional[pulumi.Input[str]]:
        """
        Select dynamic or fixed-size data chunking for HTTP WAN Optimization. Valid values: `dynamic`, `fix`.
        """
        return pulumi.get(self, "prefer_chunking")

    @prefer_chunking.setter
    def prefer_chunking(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefer_chunking", value)

    @property
    @pulumi.getter(name="protocolOpt")
    def protocol_opt(self) -> Optional[pulumi.Input[str]]:
        """
        Select Protocol specific optimitation or generic TCP optimization. Valid values: `protocol`, `tcp`.
        """
        return pulumi.get(self, "protocol_opt")

    @protocol_opt.setter
    def protocol_opt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol_opt", value)

    @property
    @pulumi.getter(name="secureTunnel")
    def secure_tunnel(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "secure_tunnel")

    @secure_tunnel.setter
    def secure_tunnel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure_tunnel", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="tunnelSharing")
    def tunnel_sharing(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        return pulumi.get(self, "tunnel_sharing")

    @tunnel_sharing.setter
    def tunnel_sharing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tunnel_sharing", value)


@pulumi.input_type
class ProfileFtpArgs:
    def __init__(__self__, *,
                 byte_caching: Optional[pulumi.Input[str]] = None,
                 log_traffic: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 prefer_chunking: Optional[pulumi.Input[str]] = None,
                 protocol_opt: Optional[pulumi.Input[str]] = None,
                 secure_tunnel: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tunnel_sharing: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] byte_caching: Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        :param pulumi.Input[str] log_traffic: Enable/disable logging. Valid values: `enable`, `disable`.
        :param pulumi.Input[int] port: Single port number or port number range for FTP. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        :param pulumi.Input[str] prefer_chunking: Select dynamic or fixed-size data chunking for HTTP WAN Optimization. Valid values: `dynamic`, `fix`.
        :param pulumi.Input[str] protocol_opt: Select Protocol specific optimitation or generic TCP optimization. Valid values: `protocol`, `tcp`.
        :param pulumi.Input[str] secure_tunnel: Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        :param pulumi.Input[str] ssl: Enable/disable SSL/TLS offloading (hardware acceleration) for traffic in this tunnel. Valid values: `enable`, `disable`.
        :param pulumi.Input[str] status: Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        :param pulumi.Input[str] tunnel_sharing: Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        if byte_caching is not None:
            pulumi.set(__self__, "byte_caching", byte_caching)
        if log_traffic is not None:
            pulumi.set(__self__, "log_traffic", log_traffic)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefer_chunking is not None:
            pulumi.set(__self__, "prefer_chunking", prefer_chunking)
        if protocol_opt is not None:
            pulumi.set(__self__, "protocol_opt", protocol_opt)
        if secure_tunnel is not None:
            pulumi.set(__self__, "secure_tunnel", secure_tunnel)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tunnel_sharing is not None:
            pulumi.set(__self__, "tunnel_sharing", tunnel_sharing)

    @property
    @pulumi.getter(name="byteCaching")
    def byte_caching(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "byte_caching")

    @byte_caching.setter
    def byte_caching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "byte_caching", value)

    @property
    @pulumi.getter(name="logTraffic")
    def log_traffic(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log_traffic")

    @log_traffic.setter
    def log_traffic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_traffic", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Single port number or port number range for FTP. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="preferChunking")
    def prefer_chunking(self) -> Optional[pulumi.Input[str]]:
        """
        Select dynamic or fixed-size data chunking for HTTP WAN Optimization. Valid values: `dynamic`, `fix`.
        """
        return pulumi.get(self, "prefer_chunking")

    @prefer_chunking.setter
    def prefer_chunking(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefer_chunking", value)

    @property
    @pulumi.getter(name="protocolOpt")
    def protocol_opt(self) -> Optional[pulumi.Input[str]]:
        """
        Select Protocol specific optimitation or generic TCP optimization. Valid values: `protocol`, `tcp`.
        """
        return pulumi.get(self, "protocol_opt")

    @protocol_opt.setter
    def protocol_opt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol_opt", value)

    @property
    @pulumi.getter(name="secureTunnel")
    def secure_tunnel(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "secure_tunnel")

    @secure_tunnel.setter
    def secure_tunnel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure_tunnel", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable SSL/TLS offloading (hardware acceleration) for traffic in this tunnel. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="tunnelSharing")
    def tunnel_sharing(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        return pulumi.get(self, "tunnel_sharing")

    @tunnel_sharing.setter
    def tunnel_sharing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tunnel_sharing", value)


@pulumi.input_type
class ProfileHttpArgs:
    def __init__(__self__, *,
                 byte_caching: Optional[pulumi.Input[str]] = None,
                 log_traffic: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 prefer_chunking: Optional[pulumi.Input[str]] = None,
                 protocol_opt: Optional[pulumi.Input[str]] = None,
                 secure_tunnel: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[str]] = None,
                 ssl_port: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tunnel_non_http: Optional[pulumi.Input[str]] = None,
                 tunnel_sharing: Optional[pulumi.Input[str]] = None,
                 unknown_http_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] byte_caching: Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        :param pulumi.Input[str] log_traffic: Enable/disable logging. Valid values: `enable`, `disable`.
        :param pulumi.Input[int] port: Single port number or port number range for HTTP. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        :param pulumi.Input[str] prefer_chunking: Select dynamic or fixed-size data chunking for HTTP WAN Optimization. Valid values: `dynamic`, `fix`.
        :param pulumi.Input[str] protocol_opt: Select Protocol specific optimitation or generic TCP optimization. Valid values: `protocol`, `tcp`.
        :param pulumi.Input[str] secure_tunnel: Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        :param pulumi.Input[str] ssl: Enable/disable SSL/TLS offloading (hardware acceleration) for HTTPS traffic in this tunnel. Valid values: `enable`, `disable`.
        :param pulumi.Input[int] ssl_port: Port on which to expect HTTPS traffic for SSL/TLS offloading.
        :param pulumi.Input[str] status: Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        :param pulumi.Input[str] tunnel_non_http: Configure how to process non-HTTP traffic when a profile configured for HTTP traffic accepts a non-HTTP session. Can occur if an application sends non-HTTP traffic using an HTTP destination port. Valid values: `enable`, `disable`.
        :param pulumi.Input[str] tunnel_sharing: Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        :param pulumi.Input[str] unknown_http_version: How to handle HTTP sessions that do not comply with HTTP 0.9, 1.0, or 1.1. Valid values: `reject`, `tunnel`, `best-effort`.
        """
        if byte_caching is not None:
            pulumi.set(__self__, "byte_caching", byte_caching)
        if log_traffic is not None:
            pulumi.set(__self__, "log_traffic", log_traffic)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefer_chunking is not None:
            pulumi.set(__self__, "prefer_chunking", prefer_chunking)
        if protocol_opt is not None:
            pulumi.set(__self__, "protocol_opt", protocol_opt)
        if secure_tunnel is not None:
            pulumi.set(__self__, "secure_tunnel", secure_tunnel)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_port is not None:
            pulumi.set(__self__, "ssl_port", ssl_port)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tunnel_non_http is not None:
            pulumi.set(__self__, "tunnel_non_http", tunnel_non_http)
        if tunnel_sharing is not None:
            pulumi.set(__self__, "tunnel_sharing", tunnel_sharing)
        if unknown_http_version is not None:
            pulumi.set(__self__, "unknown_http_version", unknown_http_version)

    @property
    @pulumi.getter(name="byteCaching")
    def byte_caching(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "byte_caching")

    @byte_caching.setter
    def byte_caching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "byte_caching", value)

    @property
    @pulumi.getter(name="logTraffic")
    def log_traffic(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log_traffic")

    @log_traffic.setter
    def log_traffic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_traffic", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Single port number or port number range for HTTP. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="preferChunking")
    def prefer_chunking(self) -> Optional[pulumi.Input[str]]:
        """
        Select dynamic or fixed-size data chunking for HTTP WAN Optimization. Valid values: `dynamic`, `fix`.
        """
        return pulumi.get(self, "prefer_chunking")

    @prefer_chunking.setter
    def prefer_chunking(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefer_chunking", value)

    @property
    @pulumi.getter(name="protocolOpt")
    def protocol_opt(self) -> Optional[pulumi.Input[str]]:
        """
        Select Protocol specific optimitation or generic TCP optimization. Valid values: `protocol`, `tcp`.
        """
        return pulumi.get(self, "protocol_opt")

    @protocol_opt.setter
    def protocol_opt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "protocol_opt", value)

    @property
    @pulumi.getter(name="secureTunnel")
    def secure_tunnel(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "secure_tunnel")

    @secure_tunnel.setter
    def secure_tunnel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure_tunnel", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable SSL/TLS offloading (hardware acceleration) for HTTPS traffic in this tunnel. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="sslPort")
    def ssl_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on which to expect HTTPS traffic for SSL/TLS offloading.
        """
        return pulumi.get(self, "ssl_port")

    @ssl_port.setter
    def ssl_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ssl_port", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="tunnelNonHttp")
    def tunnel_non_http(self) -> Optional[pulumi.Input[str]]:
        """
        Configure how to process non-HTTP traffic when a profile configured for HTTP traffic accepts a non-HTTP session. Can occur if an application sends non-HTTP traffic using an HTTP destination port. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "tunnel_non_http")

    @tunnel_non_http.setter
    def tunnel_non_http(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tunnel_non_http", value)

    @property
    @pulumi.getter(name="tunnelSharing")
    def tunnel_sharing(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        return pulumi.get(self, "tunnel_sharing")

    @tunnel_sharing.setter
    def tunnel_sharing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tunnel_sharing", value)

    @property
    @pulumi.getter(name="unknownHttpVersion")
    def unknown_http_version(self) -> Optional[pulumi.Input[str]]:
        """
        How to handle HTTP sessions that do not comply with HTTP 0.9, 1.0, or 1.1. Valid values: `reject`, `tunnel`, `best-effort`.
        """
        return pulumi.get(self, "unknown_http_version")

    @unknown_http_version.setter
    def unknown_http_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "unknown_http_version", value)


@pulumi.input_type
class ProfileMapiArgs:
    def __init__(__self__, *,
                 byte_caching: Optional[pulumi.Input[str]] = None,
                 log_traffic: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 secure_tunnel: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tunnel_sharing: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] byte_caching: Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        :param pulumi.Input[str] log_traffic: Enable/disable logging. Valid values: `enable`, `disable`.
        :param pulumi.Input[int] port: Single port number or port number range for MAPI. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        :param pulumi.Input[str] secure_tunnel: Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        :param pulumi.Input[str] status: Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        :param pulumi.Input[str] tunnel_sharing: Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        if byte_caching is not None:
            pulumi.set(__self__, "byte_caching", byte_caching)
        if log_traffic is not None:
            pulumi.set(__self__, "log_traffic", log_traffic)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secure_tunnel is not None:
            pulumi.set(__self__, "secure_tunnel", secure_tunnel)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tunnel_sharing is not None:
            pulumi.set(__self__, "tunnel_sharing", tunnel_sharing)

    @property
    @pulumi.getter(name="byteCaching")
    def byte_caching(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "byte_caching")

    @byte_caching.setter
    def byte_caching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "byte_caching", value)

    @property
    @pulumi.getter(name="logTraffic")
    def log_traffic(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log_traffic")

    @log_traffic.setter
    def log_traffic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_traffic", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Single port number or port number range for MAPI. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="secureTunnel")
    def secure_tunnel(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "secure_tunnel")

    @secure_tunnel.setter
    def secure_tunnel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure_tunnel", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="tunnelSharing")
    def tunnel_sharing(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        return pulumi.get(self, "tunnel_sharing")

    @tunnel_sharing.setter
    def tunnel_sharing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tunnel_sharing", value)


@pulumi.input_type
class ProfileTcpArgs:
    def __init__(__self__, *,
                 byte_caching: Optional[pulumi.Input[str]] = None,
                 byte_caching_opt: Optional[pulumi.Input[str]] = None,
                 log_traffic: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[str]] = None,
                 secure_tunnel: Optional[pulumi.Input[str]] = None,
                 ssl: Optional[pulumi.Input[str]] = None,
                 ssl_port: Optional[pulumi.Input[int]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 tunnel_sharing: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] byte_caching: Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        :param pulumi.Input[str] byte_caching_opt: Select whether TCP byte-caching uses system memory only or both memory and disk space. Valid values: `mem-only`, `mem-disk`.
        :param pulumi.Input[str] log_traffic: Enable/disable logging. Valid values: `enable`, `disable`.
        :param pulumi.Input[str] port: Single port number or port number range for TCP. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        :param pulumi.Input[str] secure_tunnel: Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        :param pulumi.Input[str] ssl: Enable/disable SSL/TLS offloading. Valid values: `enable`, `disable`.
        :param pulumi.Input[int] ssl_port: Port on which to expect HTTPS traffic for SSL/TLS offloading.
        :param pulumi.Input[str] status: Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        :param pulumi.Input[str] tunnel_sharing: Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        if byte_caching is not None:
            pulumi.set(__self__, "byte_caching", byte_caching)
        if byte_caching_opt is not None:
            pulumi.set(__self__, "byte_caching_opt", byte_caching_opt)
        if log_traffic is not None:
            pulumi.set(__self__, "log_traffic", log_traffic)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secure_tunnel is not None:
            pulumi.set(__self__, "secure_tunnel", secure_tunnel)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_port is not None:
            pulumi.set(__self__, "ssl_port", ssl_port)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tunnel_sharing is not None:
            pulumi.set(__self__, "tunnel_sharing", tunnel_sharing)

    @property
    @pulumi.getter(name="byteCaching")
    def byte_caching(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "byte_caching")

    @byte_caching.setter
    def byte_caching(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "byte_caching", value)

    @property
    @pulumi.getter(name="byteCachingOpt")
    def byte_caching_opt(self) -> Optional[pulumi.Input[str]]:
        """
        Select whether TCP byte-caching uses system memory only or both memory and disk space. Valid values: `mem-only`, `mem-disk`.
        """
        return pulumi.get(self, "byte_caching_opt")

    @byte_caching_opt.setter
    def byte_caching_opt(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "byte_caching_opt", value)

    @property
    @pulumi.getter(name="logTraffic")
    def log_traffic(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log_traffic")

    @log_traffic.setter
    def log_traffic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_traffic", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[str]]:
        """
        Single port number or port number range for TCP. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="secureTunnel")
    def secure_tunnel(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "secure_tunnel")

    @secure_tunnel.setter
    def secure_tunnel(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secure_tunnel", value)

    @property
    @pulumi.getter
    def ssl(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable SSL/TLS offloading. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ssl")

    @ssl.setter
    def ssl(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ssl", value)

    @property
    @pulumi.getter(name="sslPort")
    def ssl_port(self) -> Optional[pulumi.Input[int]]:
        """
        Port on which to expect HTTPS traffic for SSL/TLS offloading.
        """
        return pulumi.get(self, "ssl_port")

    @ssl_port.setter
    def ssl_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ssl_port", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="tunnelSharing")
    def tunnel_sharing(self) -> Optional[pulumi.Input[str]]:
        """
        Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        return pulumi.get(self, "tunnel_sharing")

    @tunnel_sharing.setter
    def tunnel_sharing(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tunnel_sharing", value)


