# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'CacheserviceDstPeer',
    'CacheserviceSrcPeer',
    'ContentdeliverynetworkruleHostDomainNameSuffix',
    'ContentdeliverynetworkruleRule',
    'ContentdeliverynetworkruleRuleContentId',
    'ContentdeliverynetworkruleRuleMatchEntry',
    'ContentdeliverynetworkruleRuleMatchEntryPattern',
    'ContentdeliverynetworkruleRuleSkipEntry',
    'ContentdeliverynetworkruleRuleSkipEntryPattern',
    'ProfileCifs',
    'ProfileFtp',
    'ProfileHttp',
    'ProfileMapi',
    'ProfileTcp',
]

@pulumi.output_type
class CacheserviceDstPeer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "deviceId":
            suggest = "device_id"
        elif key == "encodeType":
            suggest = "encode_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheserviceDstPeer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheserviceDstPeer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheserviceDstPeer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: Optional[int] = None,
                 device_id: Optional[str] = None,
                 encode_type: Optional[int] = None,
                 ip: Optional[str] = None,
                 priority: Optional[int] = None):
        """
        :param int auth_type: Set authentication type for this peer.
        :param str device_id: Device ID of this peer.
        :param int encode_type: Set encode type for this peer.
        :param str ip: Set cluster IP address of this peer.
        :param int priority: Set priority for this peer.
        """
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if encode_type is not None:
            pulumi.set(__self__, "encode_type", encode_type)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[int]:
        """
        Set authentication type for this peer.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[str]:
        """
        Device ID of this peer.
        """
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter(name="encodeType")
    def encode_type(self) -> Optional[int]:
        """
        Set encode type for this peer.
        """
        return pulumi.get(self, "encode_type")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Set cluster IP address of this peer.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Set priority for this peer.
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class CacheserviceSrcPeer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authType":
            suggest = "auth_type"
        elif key == "deviceId":
            suggest = "device_id"
        elif key == "encodeType":
            suggest = "encode_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CacheserviceSrcPeer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CacheserviceSrcPeer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CacheserviceSrcPeer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_type: Optional[int] = None,
                 device_id: Optional[str] = None,
                 encode_type: Optional[int] = None,
                 ip: Optional[str] = None,
                 priority: Optional[int] = None):
        """
        :param int auth_type: Set authentication type for this peer.
        :param str device_id: Device ID of this peer.
        :param int encode_type: Set encode type for this peer.
        :param str ip: Set cluster IP address of this peer.
        :param int priority: Set priority for this peer.
        """
        if auth_type is not None:
            pulumi.set(__self__, "auth_type", auth_type)
        if device_id is not None:
            pulumi.set(__self__, "device_id", device_id)
        if encode_type is not None:
            pulumi.set(__self__, "encode_type", encode_type)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter(name="authType")
    def auth_type(self) -> Optional[int]:
        """
        Set authentication type for this peer.
        """
        return pulumi.get(self, "auth_type")

    @property
    @pulumi.getter(name="deviceId")
    def device_id(self) -> Optional[str]:
        """
        Device ID of this peer.
        """
        return pulumi.get(self, "device_id")

    @property
    @pulumi.getter(name="encodeType")
    def encode_type(self) -> Optional[int]:
        """
        Set encode type for this peer.
        """
        return pulumi.get(self, "encode_type")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Set cluster IP address of this peer.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Set priority for this peer.
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class ContentdeliverynetworkruleHostDomainNameSuffix(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Suffix portion of the fully qualified domain name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Suffix portion of the fully qualified domain name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ContentdeliverynetworkruleRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contentId":
            suggest = "content_id"
        elif key == "matchEntries":
            suggest = "match_entries"
        elif key == "matchMode":
            suggest = "match_mode"
        elif key == "skipEntries":
            suggest = "skip_entries"
        elif key == "skipRuleMode":
            suggest = "skip_rule_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContentdeliverynetworkruleRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContentdeliverynetworkruleRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContentdeliverynetworkruleRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 content_id: Optional['outputs.ContentdeliverynetworkruleRuleContentId'] = None,
                 match_entries: Optional[Sequence['outputs.ContentdeliverynetworkruleRuleMatchEntry']] = None,
                 match_mode: Optional[str] = None,
                 name: Optional[str] = None,
                 skip_entries: Optional[Sequence['outputs.ContentdeliverynetworkruleRuleSkipEntry']] = None,
                 skip_rule_mode: Optional[str] = None):
        """
        :param 'ContentdeliverynetworkruleRuleContentIdArgs' content_id: Content ID settings. The structure of `content_id` block is documented below.
        :param Sequence['ContentdeliverynetworkruleRuleMatchEntryArgs'] match_entries: List of entries to match. The structure of `match_entries` block is documented below.
        :param str match_mode: Match criteria for collecting content ID. Valid values: `all`, `any`.
        :param str name: WAN optimization content delivery network rule name.
        :param Sequence['ContentdeliverynetworkruleRuleSkipEntryArgs'] skip_entries: List of entries to skip. The structure of `skip_entries` block is documented below.
        :param str skip_rule_mode: Skip mode when evaluating skip-rules. Valid values: `all`, `any`.
        """
        if content_id is not None:
            pulumi.set(__self__, "content_id", content_id)
        if match_entries is not None:
            pulumi.set(__self__, "match_entries", match_entries)
        if match_mode is not None:
            pulumi.set(__self__, "match_mode", match_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if skip_entries is not None:
            pulumi.set(__self__, "skip_entries", skip_entries)
        if skip_rule_mode is not None:
            pulumi.set(__self__, "skip_rule_mode", skip_rule_mode)

    @property
    @pulumi.getter(name="contentId")
    def content_id(self) -> Optional['outputs.ContentdeliverynetworkruleRuleContentId']:
        """
        Content ID settings. The structure of `content_id` block is documented below.
        """
        return pulumi.get(self, "content_id")

    @property
    @pulumi.getter(name="matchEntries")
    def match_entries(self) -> Optional[Sequence['outputs.ContentdeliverynetworkruleRuleMatchEntry']]:
        """
        List of entries to match. The structure of `match_entries` block is documented below.
        """
        return pulumi.get(self, "match_entries")

    @property
    @pulumi.getter(name="matchMode")
    def match_mode(self) -> Optional[str]:
        """
        Match criteria for collecting content ID. Valid values: `all`, `any`.
        """
        return pulumi.get(self, "match_mode")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        WAN optimization content delivery network rule name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="skipEntries")
    def skip_entries(self) -> Optional[Sequence['outputs.ContentdeliverynetworkruleRuleSkipEntry']]:
        """
        List of entries to skip. The structure of `skip_entries` block is documented below.
        """
        return pulumi.get(self, "skip_entries")

    @property
    @pulumi.getter(name="skipRuleMode")
    def skip_rule_mode(self) -> Optional[str]:
        """
        Skip mode when evaluating skip-rules. Valid values: `all`, `any`.
        """
        return pulumi.get(self, "skip_rule_mode")


@pulumi.output_type
class ContentdeliverynetworkruleRuleContentId(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endDirection":
            suggest = "end_direction"
        elif key == "endSkip":
            suggest = "end_skip"
        elif key == "endStr":
            suggest = "end_str"
        elif key == "rangeStr":
            suggest = "range_str"
        elif key == "startDirection":
            suggest = "start_direction"
        elif key == "startSkip":
            suggest = "start_skip"
        elif key == "startStr":
            suggest = "start_str"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContentdeliverynetworkruleRuleContentId. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContentdeliverynetworkruleRuleContentId.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContentdeliverynetworkruleRuleContentId.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_direction: Optional[str] = None,
                 end_skip: Optional[int] = None,
                 end_str: Optional[str] = None,
                 range_str: Optional[str] = None,
                 start_direction: Optional[str] = None,
                 start_skip: Optional[int] = None,
                 start_str: Optional[str] = None,
                 target: Optional[str] = None):
        """
        :param str end_direction: Search direction from end-str match. Valid values: `forward`, `backward`.
        :param int end_skip: Number of characters in URL to skip after end-str has been matched.
        :param str end_str: String from which to end search.
        :param str range_str: Name of content ID within the start string and end string.
        :param str start_direction: Search direction from start-str match. Valid values: `forward`, `backward`.
        :param int start_skip: Number of characters in URL to skip after start-str has been matched.
        :param str start_str: String from which to start search.
        :param str target: Option in HTTP header or URL parameter to match. Valid values: `path`, `parameter`, `referrer`, `youtube-map`, `youtube-id`, `youku-id`, `hls-manifest`, `dash-manifest`, `hls-fragment`, `dash-fragment`.
        """
        if end_direction is not None:
            pulumi.set(__self__, "end_direction", end_direction)
        if end_skip is not None:
            pulumi.set(__self__, "end_skip", end_skip)
        if end_str is not None:
            pulumi.set(__self__, "end_str", end_str)
        if range_str is not None:
            pulumi.set(__self__, "range_str", range_str)
        if start_direction is not None:
            pulumi.set(__self__, "start_direction", start_direction)
        if start_skip is not None:
            pulumi.set(__self__, "start_skip", start_skip)
        if start_str is not None:
            pulumi.set(__self__, "start_str", start_str)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter(name="endDirection")
    def end_direction(self) -> Optional[str]:
        """
        Search direction from end-str match. Valid values: `forward`, `backward`.
        """
        return pulumi.get(self, "end_direction")

    @property
    @pulumi.getter(name="endSkip")
    def end_skip(self) -> Optional[int]:
        """
        Number of characters in URL to skip after end-str has been matched.
        """
        return pulumi.get(self, "end_skip")

    @property
    @pulumi.getter(name="endStr")
    def end_str(self) -> Optional[str]:
        """
        String from which to end search.
        """
        return pulumi.get(self, "end_str")

    @property
    @pulumi.getter(name="rangeStr")
    def range_str(self) -> Optional[str]:
        """
        Name of content ID within the start string and end string.
        """
        return pulumi.get(self, "range_str")

    @property
    @pulumi.getter(name="startDirection")
    def start_direction(self) -> Optional[str]:
        """
        Search direction from start-str match. Valid values: `forward`, `backward`.
        """
        return pulumi.get(self, "start_direction")

    @property
    @pulumi.getter(name="startSkip")
    def start_skip(self) -> Optional[int]:
        """
        Number of characters in URL to skip after start-str has been matched.
        """
        return pulumi.get(self, "start_skip")

    @property
    @pulumi.getter(name="startStr")
    def start_str(self) -> Optional[str]:
        """
        String from which to start search.
        """
        return pulumi.get(self, "start_str")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Option in HTTP header or URL parameter to match. Valid values: `path`, `parameter`, `referrer`, `youtube-map`, `youtube-id`, `youku-id`, `hls-manifest`, `dash-manifest`, `hls-fragment`, `dash-fragment`.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ContentdeliverynetworkruleRuleMatchEntry(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None,
                 patterns: Optional[Sequence['outputs.ContentdeliverynetworkruleRuleMatchEntryPattern']] = None,
                 target: Optional[str] = None):
        """
        :param int id: Rule ID.
        :param Sequence['ContentdeliverynetworkruleRuleMatchEntryPatternArgs'] patterns: Pattern string for matching target (Referrer or URL pattern, eg. "a", "a*c", "*a*", "a*c*e", and "*"). The structure of `pattern` block is documented below.
        :param str target: Option in HTTP header or URL parameter to match. Valid values: `path`, `parameter`, `referrer`, `youtube-map`, `youtube-id`, `youku-id`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Rule ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def patterns(self) -> Optional[Sequence['outputs.ContentdeliverynetworkruleRuleMatchEntryPattern']]:
        """
        Pattern string for matching target (Referrer or URL pattern, eg. "a", "a*c", "*a*", "a*c*e", and "*"). The structure of `pattern` block is documented below.
        """
        return pulumi.get(self, "patterns")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Option in HTTP header or URL parameter to match. Valid values: `path`, `parameter`, `referrer`, `youtube-map`, `youtube-id`, `youku-id`.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ContentdeliverynetworkruleRuleMatchEntryPattern(dict):
    def __init__(__self__, *,
                 string: Optional[str] = None):
        """
        :param str string: Pattern strings.
        """
        if string is not None:
            pulumi.set(__self__, "string", string)

    @property
    @pulumi.getter
    def string(self) -> Optional[str]:
        """
        Pattern strings.
        """
        return pulumi.get(self, "string")


@pulumi.output_type
class ContentdeliverynetworkruleRuleSkipEntry(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None,
                 patterns: Optional[Sequence['outputs.ContentdeliverynetworkruleRuleSkipEntryPattern']] = None,
                 target: Optional[str] = None):
        """
        :param int id: Rule ID.
        :param Sequence['ContentdeliverynetworkruleRuleSkipEntryPatternArgs'] patterns: Pattern string for matching target (Referrer or URL pattern, eg. "a", "a*c", "*a*", "a*c*e", and "*"). The structure of `pattern` block is documented below.
        :param str target: Option in HTTP header or URL parameter to match. Valid values: `path`, `parameter`, `referrer`, `youtube-map`, `youtube-id`, `youku-id`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)
        if target is not None:
            pulumi.set(__self__, "target", target)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Rule ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def patterns(self) -> Optional[Sequence['outputs.ContentdeliverynetworkruleRuleSkipEntryPattern']]:
        """
        Pattern string for matching target (Referrer or URL pattern, eg. "a", "a*c", "*a*", "a*c*e", and "*"). The structure of `pattern` block is documented below.
        """
        return pulumi.get(self, "patterns")

    @property
    @pulumi.getter
    def target(self) -> Optional[str]:
        """
        Option in HTTP header or URL parameter to match. Valid values: `path`, `parameter`, `referrer`, `youtube-map`, `youtube-id`, `youku-id`.
        """
        return pulumi.get(self, "target")


@pulumi.output_type
class ContentdeliverynetworkruleRuleSkipEntryPattern(dict):
    def __init__(__self__, *,
                 string: Optional[str] = None):
        """
        :param str string: Pattern strings.
        """
        if string is not None:
            pulumi.set(__self__, "string", string)

    @property
    @pulumi.getter
    def string(self) -> Optional[str]:
        """
        Pattern strings.
        """
        return pulumi.get(self, "string")


@pulumi.output_type
class ProfileCifs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byteCaching":
            suggest = "byte_caching"
        elif key == "logTraffic":
            suggest = "log_traffic"
        elif key == "preferChunking":
            suggest = "prefer_chunking"
        elif key == "protocolOpt":
            suggest = "protocol_opt"
        elif key == "secureTunnel":
            suggest = "secure_tunnel"
        elif key == "tunnelSharing":
            suggest = "tunnel_sharing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileCifs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileCifs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileCifs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 byte_caching: Optional[str] = None,
                 log_traffic: Optional[str] = None,
                 port: Optional[int] = None,
                 prefer_chunking: Optional[str] = None,
                 protocol_opt: Optional[str] = None,
                 secure_tunnel: Optional[str] = None,
                 status: Optional[str] = None,
                 tunnel_sharing: Optional[str] = None):
        """
        :param str byte_caching: Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        :param str log_traffic: Enable/disable logging. Valid values: `enable`, `disable`.
        :param int port: Single port number or port number range for CIFS. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        :param str prefer_chunking: Select dynamic or fixed-size data chunking for HTTP WAN Optimization. Valid values: `dynamic`, `fix`.
        :param str protocol_opt: Select Protocol specific optimitation or generic TCP optimization. Valid values: `protocol`, `tcp`.
        :param str secure_tunnel: Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        :param str status: Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        :param str tunnel_sharing: Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        if byte_caching is not None:
            pulumi.set(__self__, "byte_caching", byte_caching)
        if log_traffic is not None:
            pulumi.set(__self__, "log_traffic", log_traffic)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefer_chunking is not None:
            pulumi.set(__self__, "prefer_chunking", prefer_chunking)
        if protocol_opt is not None:
            pulumi.set(__self__, "protocol_opt", protocol_opt)
        if secure_tunnel is not None:
            pulumi.set(__self__, "secure_tunnel", secure_tunnel)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tunnel_sharing is not None:
            pulumi.set(__self__, "tunnel_sharing", tunnel_sharing)

    @property
    @pulumi.getter(name="byteCaching")
    def byte_caching(self) -> Optional[str]:
        """
        Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "byte_caching")

    @property
    @pulumi.getter(name="logTraffic")
    def log_traffic(self) -> Optional[str]:
        """
        Enable/disable logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log_traffic")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Single port number or port number range for CIFS. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="preferChunking")
    def prefer_chunking(self) -> Optional[str]:
        """
        Select dynamic or fixed-size data chunking for HTTP WAN Optimization. Valid values: `dynamic`, `fix`.
        """
        return pulumi.get(self, "prefer_chunking")

    @property
    @pulumi.getter(name="protocolOpt")
    def protocol_opt(self) -> Optional[str]:
        """
        Select Protocol specific optimitation or generic TCP optimization. Valid values: `protocol`, `tcp`.
        """
        return pulumi.get(self, "protocol_opt")

    @property
    @pulumi.getter(name="secureTunnel")
    def secure_tunnel(self) -> Optional[str]:
        """
        Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "secure_tunnel")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tunnelSharing")
    def tunnel_sharing(self) -> Optional[str]:
        """
        Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        return pulumi.get(self, "tunnel_sharing")


@pulumi.output_type
class ProfileFtp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byteCaching":
            suggest = "byte_caching"
        elif key == "logTraffic":
            suggest = "log_traffic"
        elif key == "preferChunking":
            suggest = "prefer_chunking"
        elif key == "protocolOpt":
            suggest = "protocol_opt"
        elif key == "secureTunnel":
            suggest = "secure_tunnel"
        elif key == "tunnelSharing":
            suggest = "tunnel_sharing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileFtp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileFtp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileFtp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 byte_caching: Optional[str] = None,
                 log_traffic: Optional[str] = None,
                 port: Optional[int] = None,
                 prefer_chunking: Optional[str] = None,
                 protocol_opt: Optional[str] = None,
                 secure_tunnel: Optional[str] = None,
                 ssl: Optional[str] = None,
                 status: Optional[str] = None,
                 tunnel_sharing: Optional[str] = None):
        """
        :param str byte_caching: Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        :param str log_traffic: Enable/disable logging. Valid values: `enable`, `disable`.
        :param int port: Single port number or port number range for FTP. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        :param str prefer_chunking: Select dynamic or fixed-size data chunking for HTTP WAN Optimization. Valid values: `dynamic`, `fix`.
        :param str protocol_opt: Select Protocol specific optimitation or generic TCP optimization. Valid values: `protocol`, `tcp`.
        :param str secure_tunnel: Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        :param str ssl: Enable/disable SSL/TLS offloading (hardware acceleration) for traffic in this tunnel. Valid values: `enable`, `disable`.
        :param str status: Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        :param str tunnel_sharing: Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        if byte_caching is not None:
            pulumi.set(__self__, "byte_caching", byte_caching)
        if log_traffic is not None:
            pulumi.set(__self__, "log_traffic", log_traffic)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefer_chunking is not None:
            pulumi.set(__self__, "prefer_chunking", prefer_chunking)
        if protocol_opt is not None:
            pulumi.set(__self__, "protocol_opt", protocol_opt)
        if secure_tunnel is not None:
            pulumi.set(__self__, "secure_tunnel", secure_tunnel)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tunnel_sharing is not None:
            pulumi.set(__self__, "tunnel_sharing", tunnel_sharing)

    @property
    @pulumi.getter(name="byteCaching")
    def byte_caching(self) -> Optional[str]:
        """
        Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "byte_caching")

    @property
    @pulumi.getter(name="logTraffic")
    def log_traffic(self) -> Optional[str]:
        """
        Enable/disable logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log_traffic")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Single port number or port number range for FTP. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="preferChunking")
    def prefer_chunking(self) -> Optional[str]:
        """
        Select dynamic or fixed-size data chunking for HTTP WAN Optimization. Valid values: `dynamic`, `fix`.
        """
        return pulumi.get(self, "prefer_chunking")

    @property
    @pulumi.getter(name="protocolOpt")
    def protocol_opt(self) -> Optional[str]:
        """
        Select Protocol specific optimitation or generic TCP optimization. Valid values: `protocol`, `tcp`.
        """
        return pulumi.get(self, "protocol_opt")

    @property
    @pulumi.getter(name="secureTunnel")
    def secure_tunnel(self) -> Optional[str]:
        """
        Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "secure_tunnel")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        """
        Enable/disable SSL/TLS offloading (hardware acceleration) for traffic in this tunnel. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tunnelSharing")
    def tunnel_sharing(self) -> Optional[str]:
        """
        Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        return pulumi.get(self, "tunnel_sharing")


@pulumi.output_type
class ProfileHttp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byteCaching":
            suggest = "byte_caching"
        elif key == "logTraffic":
            suggest = "log_traffic"
        elif key == "preferChunking":
            suggest = "prefer_chunking"
        elif key == "protocolOpt":
            suggest = "protocol_opt"
        elif key == "secureTunnel":
            suggest = "secure_tunnel"
        elif key == "sslPort":
            suggest = "ssl_port"
        elif key == "tunnelNonHttp":
            suggest = "tunnel_non_http"
        elif key == "tunnelSharing":
            suggest = "tunnel_sharing"
        elif key == "unknownHttpVersion":
            suggest = "unknown_http_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileHttp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileHttp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileHttp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 byte_caching: Optional[str] = None,
                 log_traffic: Optional[str] = None,
                 port: Optional[int] = None,
                 prefer_chunking: Optional[str] = None,
                 protocol_opt: Optional[str] = None,
                 secure_tunnel: Optional[str] = None,
                 ssl: Optional[str] = None,
                 ssl_port: Optional[int] = None,
                 status: Optional[str] = None,
                 tunnel_non_http: Optional[str] = None,
                 tunnel_sharing: Optional[str] = None,
                 unknown_http_version: Optional[str] = None):
        """
        :param str byte_caching: Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        :param str log_traffic: Enable/disable logging. Valid values: `enable`, `disable`.
        :param int port: Single port number or port number range for HTTP. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        :param str prefer_chunking: Select dynamic or fixed-size data chunking for HTTP WAN Optimization. Valid values: `dynamic`, `fix`.
        :param str protocol_opt: Select Protocol specific optimitation or generic TCP optimization. Valid values: `protocol`, `tcp`.
        :param str secure_tunnel: Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        :param str ssl: Enable/disable SSL/TLS offloading (hardware acceleration) for traffic in this tunnel. Valid values: `enable`, `disable`.
        :param int ssl_port: Port on which to expect HTTPS traffic for SSL/TLS offloading.
        :param str status: Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        :param str tunnel_non_http: Configure how to process non-HTTP traffic when a profile configured for HTTP traffic accepts a non-HTTP session. Can occur if an application sends non-HTTP traffic using an HTTP destination port. Valid values: `enable`, `disable`.
        :param str tunnel_sharing: Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        :param str unknown_http_version: How to handle HTTP sessions that do not comply with HTTP 0.9, 1.0, or 1.1. Valid values: `reject`, `tunnel`, `best-effort`.
        """
        if byte_caching is not None:
            pulumi.set(__self__, "byte_caching", byte_caching)
        if log_traffic is not None:
            pulumi.set(__self__, "log_traffic", log_traffic)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if prefer_chunking is not None:
            pulumi.set(__self__, "prefer_chunking", prefer_chunking)
        if protocol_opt is not None:
            pulumi.set(__self__, "protocol_opt", protocol_opt)
        if secure_tunnel is not None:
            pulumi.set(__self__, "secure_tunnel", secure_tunnel)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_port is not None:
            pulumi.set(__self__, "ssl_port", ssl_port)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tunnel_non_http is not None:
            pulumi.set(__self__, "tunnel_non_http", tunnel_non_http)
        if tunnel_sharing is not None:
            pulumi.set(__self__, "tunnel_sharing", tunnel_sharing)
        if unknown_http_version is not None:
            pulumi.set(__self__, "unknown_http_version", unknown_http_version)

    @property
    @pulumi.getter(name="byteCaching")
    def byte_caching(self) -> Optional[str]:
        """
        Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "byte_caching")

    @property
    @pulumi.getter(name="logTraffic")
    def log_traffic(self) -> Optional[str]:
        """
        Enable/disable logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log_traffic")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Single port number or port number range for HTTP. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="preferChunking")
    def prefer_chunking(self) -> Optional[str]:
        """
        Select dynamic or fixed-size data chunking for HTTP WAN Optimization. Valid values: `dynamic`, `fix`.
        """
        return pulumi.get(self, "prefer_chunking")

    @property
    @pulumi.getter(name="protocolOpt")
    def protocol_opt(self) -> Optional[str]:
        """
        Select Protocol specific optimitation or generic TCP optimization. Valid values: `protocol`, `tcp`.
        """
        return pulumi.get(self, "protocol_opt")

    @property
    @pulumi.getter(name="secureTunnel")
    def secure_tunnel(self) -> Optional[str]:
        """
        Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "secure_tunnel")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        """
        Enable/disable SSL/TLS offloading (hardware acceleration) for traffic in this tunnel. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="sslPort")
    def ssl_port(self) -> Optional[int]:
        """
        Port on which to expect HTTPS traffic for SSL/TLS offloading.
        """
        return pulumi.get(self, "ssl_port")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tunnelNonHttp")
    def tunnel_non_http(self) -> Optional[str]:
        """
        Configure how to process non-HTTP traffic when a profile configured for HTTP traffic accepts a non-HTTP session. Can occur if an application sends non-HTTP traffic using an HTTP destination port. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "tunnel_non_http")

    @property
    @pulumi.getter(name="tunnelSharing")
    def tunnel_sharing(self) -> Optional[str]:
        """
        Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        return pulumi.get(self, "tunnel_sharing")

    @property
    @pulumi.getter(name="unknownHttpVersion")
    def unknown_http_version(self) -> Optional[str]:
        """
        How to handle HTTP sessions that do not comply with HTTP 0.9, 1.0, or 1.1. Valid values: `reject`, `tunnel`, `best-effort`.
        """
        return pulumi.get(self, "unknown_http_version")


@pulumi.output_type
class ProfileMapi(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byteCaching":
            suggest = "byte_caching"
        elif key == "logTraffic":
            suggest = "log_traffic"
        elif key == "secureTunnel":
            suggest = "secure_tunnel"
        elif key == "tunnelSharing":
            suggest = "tunnel_sharing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileMapi. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileMapi.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileMapi.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 byte_caching: Optional[str] = None,
                 log_traffic: Optional[str] = None,
                 port: Optional[int] = None,
                 secure_tunnel: Optional[str] = None,
                 status: Optional[str] = None,
                 tunnel_sharing: Optional[str] = None):
        """
        :param str byte_caching: Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        :param str log_traffic: Enable/disable logging. Valid values: `enable`, `disable`.
        :param int port: Single port number or port number range for MAPI. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        :param str secure_tunnel: Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        :param str status: Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        :param str tunnel_sharing: Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        if byte_caching is not None:
            pulumi.set(__self__, "byte_caching", byte_caching)
        if log_traffic is not None:
            pulumi.set(__self__, "log_traffic", log_traffic)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secure_tunnel is not None:
            pulumi.set(__self__, "secure_tunnel", secure_tunnel)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tunnel_sharing is not None:
            pulumi.set(__self__, "tunnel_sharing", tunnel_sharing)

    @property
    @pulumi.getter(name="byteCaching")
    def byte_caching(self) -> Optional[str]:
        """
        Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "byte_caching")

    @property
    @pulumi.getter(name="logTraffic")
    def log_traffic(self) -> Optional[str]:
        """
        Enable/disable logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log_traffic")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Single port number or port number range for MAPI. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="secureTunnel")
    def secure_tunnel(self) -> Optional[str]:
        """
        Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "secure_tunnel")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tunnelSharing")
    def tunnel_sharing(self) -> Optional[str]:
        """
        Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        return pulumi.get(self, "tunnel_sharing")


@pulumi.output_type
class ProfileTcp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "byteCaching":
            suggest = "byte_caching"
        elif key == "byteCachingOpt":
            suggest = "byte_caching_opt"
        elif key == "logTraffic":
            suggest = "log_traffic"
        elif key == "secureTunnel":
            suggest = "secure_tunnel"
        elif key == "sslPort":
            suggest = "ssl_port"
        elif key == "tunnelSharing":
            suggest = "tunnel_sharing"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileTcp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileTcp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileTcp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 byte_caching: Optional[str] = None,
                 byte_caching_opt: Optional[str] = None,
                 log_traffic: Optional[str] = None,
                 port: Optional[str] = None,
                 secure_tunnel: Optional[str] = None,
                 ssl: Optional[str] = None,
                 ssl_port: Optional[int] = None,
                 status: Optional[str] = None,
                 tunnel_sharing: Optional[str] = None):
        """
        :param str byte_caching: Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        :param str byte_caching_opt: Select whether TCP byte-caching uses system memory only or both memory and disk space. Valid values: `mem-only`, `mem-disk`.
        :param str log_traffic: Enable/disable logging. Valid values: `enable`, `disable`.
        :param str port: Single port number or port number range for TCP. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        :param str secure_tunnel: Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        :param str ssl: Enable/disable SSL/TLS offloading (hardware acceleration) for traffic in this tunnel. Valid values: `enable`, `disable`.
        :param int ssl_port: Port on which to expect HTTPS traffic for SSL/TLS offloading.
        :param str status: Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        :param str tunnel_sharing: Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        if byte_caching is not None:
            pulumi.set(__self__, "byte_caching", byte_caching)
        if byte_caching_opt is not None:
            pulumi.set(__self__, "byte_caching_opt", byte_caching_opt)
        if log_traffic is not None:
            pulumi.set(__self__, "log_traffic", log_traffic)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secure_tunnel is not None:
            pulumi.set(__self__, "secure_tunnel", secure_tunnel)
        if ssl is not None:
            pulumi.set(__self__, "ssl", ssl)
        if ssl_port is not None:
            pulumi.set(__self__, "ssl_port", ssl_port)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if tunnel_sharing is not None:
            pulumi.set(__self__, "tunnel_sharing", tunnel_sharing)

    @property
    @pulumi.getter(name="byteCaching")
    def byte_caching(self) -> Optional[str]:
        """
        Enable/disable byte-caching for HTTP. Byte caching reduces the amount of traffic by caching file data sent across the WAN and in future serving if from the cache. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "byte_caching")

    @property
    @pulumi.getter(name="byteCachingOpt")
    def byte_caching_opt(self) -> Optional[str]:
        """
        Select whether TCP byte-caching uses system memory only or both memory and disk space. Valid values: `mem-only`, `mem-disk`.
        """
        return pulumi.get(self, "byte_caching_opt")

    @property
    @pulumi.getter(name="logTraffic")
    def log_traffic(self) -> Optional[str]:
        """
        Enable/disable logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log_traffic")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Single port number or port number range for TCP. Only packets with a destination port number that matches this port number or range are accepted by this profile.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter(name="secureTunnel")
    def secure_tunnel(self) -> Optional[str]:
        """
        Enable/disable securing the WAN Opt tunnel using SSL. Secure and non-secure tunnels use the same TCP port (7810). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "secure_tunnel")

    @property
    @pulumi.getter
    def ssl(self) -> Optional[str]:
        """
        Enable/disable SSL/TLS offloading (hardware acceleration) for traffic in this tunnel. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ssl")

    @property
    @pulumi.getter(name="sslPort")
    def ssl_port(self) -> Optional[int]:
        """
        Port on which to expect HTTPS traffic for SSL/TLS offloading.
        """
        return pulumi.get(self, "ssl_port")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable HTTP WAN Optimization. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="tunnelSharing")
    def tunnel_sharing(self) -> Optional[str]:
        """
        Tunnel sharing mode for aggressive/non-aggressive and/or interactive/non-interactive protocols. Valid values: `private`, `shared`, `express-shared`.
        """
        return pulumi.get(self, "tunnel_sharing")


