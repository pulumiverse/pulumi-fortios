# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from ... import _utilities
from . import outputs

__all__ = [
    'ContentEntry',
    'ContentheaderEntry',
    'ProfileAntiphish',
    'ProfileAntiphishCustomPattern',
    'ProfileAntiphishInspectionEntry',
    'ProfileFileFilter',
    'ProfileFileFilterEntry',
    'ProfileFileFilterEntryFileType',
    'ProfileFtgdWf',
    'ProfileFtgdWfFilter',
    'ProfileFtgdWfFilterAuthUsrGrp',
    'ProfileFtgdWfQuota',
    'ProfileOverride',
    'ProfileOverrideOvrdUserGroup',
    'ProfileOverrideProfile',
    'ProfileWeb',
    'ProfileWebKeywordMatch',
    'ProfileWispServer',
    'ProfileYoutubeChannelFilter',
    'UrlfilterEntry',
]

@pulumi.output_type
class ContentEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patternType":
            suggest = "pattern_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContentEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContentEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContentEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 lang: Optional[str] = None,
                 name: Optional[str] = None,
                 pattern_type: Optional[str] = None,
                 score: Optional[int] = None,
                 status: Optional[str] = None):
        """
        :param str action: Block or exempt word when a match is found. Valid values: `block`, `exempt`.
        :param str lang: Language of banned word. Valid values: `western`, `simch`, `trach`, `japanese`, `korean`, `french`, `thai`, `spanish`, `cyrillic`.
        :param str name: Banned word.
        :param str pattern_type: Banned word pattern type: wildcard pattern or Perl regular expression. Valid values: `wildcard`, `regexp`.
        :param int score: Score, to be applied every time the word appears on a web page (0 - 4294967295, default = 10).
        :param str status: Enable/disable banned word. Valid values: `enable`, `disable`.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if lang is not None:
            pulumi.set(__self__, "lang", lang)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pattern_type is not None:
            pulumi.set(__self__, "pattern_type", pattern_type)
        if score is not None:
            pulumi.set(__self__, "score", score)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Block or exempt word when a match is found. Valid values: `block`, `exempt`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def lang(self) -> Optional[str]:
        """
        Language of banned word. Valid values: `western`, `simch`, `trach`, `japanese`, `korean`, `french`, `thai`, `spanish`, `cyrillic`.
        """
        return pulumi.get(self, "lang")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Banned word.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="patternType")
    def pattern_type(self) -> Optional[str]:
        """
        Banned word pattern type: wildcard pattern or Perl regular expression. Valid values: `wildcard`, `regexp`.
        """
        return pulumi.get(self, "pattern_type")

    @property
    @pulumi.getter
    def score(self) -> Optional[int]:
        """
        Score, to be applied every time the word appears on a web page (0 - 4294967295, default = 10).
        """
        return pulumi.get(self, "score")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable banned word. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ContentheaderEntry(dict):
    def __init__(__self__, *,
                 action: Optional[str] = None,
                 category: Optional[str] = None,
                 pattern: Optional[str] = None):
        """
        :param str action: Action to take for this content type. Valid values: `block`, `allow`, `exempt`.
        :param str category: Categories that this content type applies to.
        :param str pattern: Content type (regular expression).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action to take for this content type. Valid values: `block`, `allow`, `exempt`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Categories that this content type applies to.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        Content type (regular expression).
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class ProfileAntiphish(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkBasicAuth":
            suggest = "check_basic_auth"
        elif key == "checkUri":
            suggest = "check_uri"
        elif key == "checkUsernameOnly":
            suggest = "check_username_only"
        elif key == "customPatterns":
            suggest = "custom_patterns"
        elif key == "defaultAction":
            suggest = "default_action"
        elif key == "domainController":
            suggest = "domain_controller"
        elif key == "inspectionEntries":
            suggest = "inspection_entries"
        elif key == "maxBodyLen":
            suggest = "max_body_len"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileAntiphish. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileAntiphish.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileAntiphish.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authentication: Optional[str] = None,
                 check_basic_auth: Optional[str] = None,
                 check_uri: Optional[str] = None,
                 check_username_only: Optional[str] = None,
                 custom_patterns: Optional[Sequence['outputs.ProfileAntiphishCustomPattern']] = None,
                 default_action: Optional[str] = None,
                 domain_controller: Optional[str] = None,
                 inspection_entries: Optional[Sequence['outputs.ProfileAntiphishInspectionEntry']] = None,
                 ldap: Optional[str] = None,
                 max_body_len: Optional[int] = None,
                 status: Optional[str] = None):
        """
        :param str authentication: Authentication methods. Valid values: `domain-controller`, `ldap`.
        :param str check_basic_auth: Enable/disable checking of HTTP Basic Auth field for known credentials. Valid values: `enable`, `disable`.
        :param str check_uri: Enable/disable checking of GET URI parameters for known credentials. Valid values: `enable`, `disable`.
        :param str check_username_only: Enable/disable acting only on valid username credentials. Action will be taken for valid usernames regardless of password validity. Valid values: `enable`, `disable`.
        :param Sequence['ProfileAntiphishCustomPatternArgs'] custom_patterns: Custom username and password regex patterns. The structure of `custom_patterns` block is documented below.
        :param str default_action: Action to be taken when there is no matching rule. Valid values: `exempt`, `log`, `block`.
        :param str domain_controller: Domain for which to verify received credentials against.
        :param Sequence['ProfileAntiphishInspectionEntryArgs'] inspection_entries: AntiPhishing entries. The structure of `inspection_entries` block is documented below.
        :param str ldap: LDAP server for which to verify received credentials against.
        :param int max_body_len: Maximum size of a POST body to check for credentials.
        :param str status: Toggle AntiPhishing functionality. Valid values: `enable`, `disable`.
        """
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if check_basic_auth is not None:
            pulumi.set(__self__, "check_basic_auth", check_basic_auth)
        if check_uri is not None:
            pulumi.set(__self__, "check_uri", check_uri)
        if check_username_only is not None:
            pulumi.set(__self__, "check_username_only", check_username_only)
        if custom_patterns is not None:
            pulumi.set(__self__, "custom_patterns", custom_patterns)
        if default_action is not None:
            pulumi.set(__self__, "default_action", default_action)
        if domain_controller is not None:
            pulumi.set(__self__, "domain_controller", domain_controller)
        if inspection_entries is not None:
            pulumi.set(__self__, "inspection_entries", inspection_entries)
        if ldap is not None:
            pulumi.set(__self__, "ldap", ldap)
        if max_body_len is not None:
            pulumi.set(__self__, "max_body_len", max_body_len)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def authentication(self) -> Optional[str]:
        """
        Authentication methods. Valid values: `domain-controller`, `ldap`.
        """
        return pulumi.get(self, "authentication")

    @property
    @pulumi.getter(name="checkBasicAuth")
    def check_basic_auth(self) -> Optional[str]:
        """
        Enable/disable checking of HTTP Basic Auth field for known credentials. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "check_basic_auth")

    @property
    @pulumi.getter(name="checkUri")
    def check_uri(self) -> Optional[str]:
        """
        Enable/disable checking of GET URI parameters for known credentials. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "check_uri")

    @property
    @pulumi.getter(name="checkUsernameOnly")
    def check_username_only(self) -> Optional[str]:
        """
        Enable/disable acting only on valid username credentials. Action will be taken for valid usernames regardless of password validity. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "check_username_only")

    @property
    @pulumi.getter(name="customPatterns")
    def custom_patterns(self) -> Optional[Sequence['outputs.ProfileAntiphishCustomPattern']]:
        """
        Custom username and password regex patterns. The structure of `custom_patterns` block is documented below.
        """
        return pulumi.get(self, "custom_patterns")

    @property
    @pulumi.getter(name="defaultAction")
    def default_action(self) -> Optional[str]:
        """
        Action to be taken when there is no matching rule. Valid values: `exempt`, `log`, `block`.
        """
        return pulumi.get(self, "default_action")

    @property
    @pulumi.getter(name="domainController")
    def domain_controller(self) -> Optional[str]:
        """
        Domain for which to verify received credentials against.
        """
        return pulumi.get(self, "domain_controller")

    @property
    @pulumi.getter(name="inspectionEntries")
    def inspection_entries(self) -> Optional[Sequence['outputs.ProfileAntiphishInspectionEntry']]:
        """
        AntiPhishing entries. The structure of `inspection_entries` block is documented below.
        """
        return pulumi.get(self, "inspection_entries")

    @property
    @pulumi.getter
    def ldap(self) -> Optional[str]:
        """
        LDAP server for which to verify received credentials against.
        """
        return pulumi.get(self, "ldap")

    @property
    @pulumi.getter(name="maxBodyLen")
    def max_body_len(self) -> Optional[int]:
        """
        Maximum size of a POST body to check for credentials.
        """
        return pulumi.get(self, "max_body_len")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Toggle AntiPhishing functionality. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ProfileAntiphishCustomPattern(dict):
    def __init__(__self__, *,
                 category: Optional[str] = None,
                 pattern: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str category: Category that the pattern matches. Valid values: `username`, `password`.
        :param str pattern: Target pattern.
        :param str type: Pattern will be treated either as a regex pattern or literal string. Valid values: `regex`, `literal`.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Category that the pattern matches. Valid values: `username`, `password`.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        Target pattern.
        """
        return pulumi.get(self, "pattern")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Pattern will be treated either as a regex pattern or literal string. Valid values: `regex`, `literal`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ProfileAntiphishInspectionEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fortiguardCategory":
            suggest = "fortiguard_category"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileAntiphishInspectionEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileAntiphishInspectionEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileAntiphishInspectionEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 fortiguard_category: Optional[str] = None,
                 name: Optional[str] = None):
        """
        :param str action: Action to be taken upon an AntiPhishing match. Valid values: `exempt`, `log`, `block`.
        :param str fortiguard_category: FortiGuard category to match.
        :param str name: Inspection target name.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if fortiguard_category is not None:
            pulumi.set(__self__, "fortiguard_category", fortiguard_category)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action to be taken upon an AntiPhishing match. Valid values: `exempt`, `log`, `block`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="fortiguardCategory")
    def fortiguard_category(self) -> Optional[str]:
        """
        FortiGuard category to match.
        """
        return pulumi.get(self, "fortiguard_category")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Inspection target name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProfileFileFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scanArchiveContents":
            suggest = "scan_archive_contents"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileFileFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileFileFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileFileFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entries: Optional[Sequence['outputs.ProfileFileFilterEntry']] = None,
                 log: Optional[str] = None,
                 scan_archive_contents: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param Sequence['ProfileFileFilterEntryArgs'] entries: File filter entries. The structure of `entries` block is documented below.
        :param str log: Enable/disable file filter logging. Valid values: `enable`, `disable`.
        :param str scan_archive_contents: Enable/disable file filter archive contents scan. Valid values: `enable`, `disable`.
        :param str status: Enable/disable file filter. Valid values: `enable`, `disable`.
        """
        if entries is not None:
            pulumi.set(__self__, "entries", entries)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if scan_archive_contents is not None:
            pulumi.set(__self__, "scan_archive_contents", scan_archive_contents)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def entries(self) -> Optional[Sequence['outputs.ProfileFileFilterEntry']]:
        """
        File filter entries. The structure of `entries` block is documented below.
        """
        return pulumi.get(self, "entries")

    @property
    @pulumi.getter
    def log(self) -> Optional[str]:
        """
        Enable/disable file filter logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log")

    @property
    @pulumi.getter(name="scanArchiveContents")
    def scan_archive_contents(self) -> Optional[str]:
        """
        Enable/disable file filter archive contents scan. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "scan_archive_contents")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable file filter. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ProfileFileFilterEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileTypes":
            suggest = "file_types"
        elif key == "passwordProtected":
            suggest = "password_protected"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileFileFilterEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileFileFilterEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileFileFilterEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 comment: Optional[str] = None,
                 direction: Optional[str] = None,
                 file_types: Optional[Sequence['outputs.ProfileFileFilterEntryFileType']] = None,
                 filter: Optional[str] = None,
                 password_protected: Optional[str] = None,
                 protocol: Optional[str] = None):
        """
        :param str action: Action taken for matched file. Valid values: `log`, `block`.
        :param str comment: Comment.
        :param str direction: Match files transmitted in the session's originating or reply direction. Valid values: `incoming`, `outgoing`, `any`.
        :param Sequence['ProfileFileFilterEntryFileTypeArgs'] file_types: Select file type. The structure of `file_type` block is documented below.
        :param str filter: Add a file filter.
        :param str password_protected: Match password-protected files. Valid values: `yes`, `any`.
        :param str protocol: Protocols to apply with. Valid values: `http`, `ftp`.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if file_types is not None:
            pulumi.set(__self__, "file_types", file_types)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)
        if password_protected is not None:
            pulumi.set(__self__, "password_protected", password_protected)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action taken for matched file. Valid values: `log`, `block`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Comment.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Match files transmitted in the session's originating or reply direction. Valid values: `incoming`, `outgoing`, `any`.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Optional[Sequence['outputs.ProfileFileFilterEntryFileType']]:
        """
        Select file type. The structure of `file_type` block is documented below.
        """
        return pulumi.get(self, "file_types")

    @property
    @pulumi.getter
    def filter(self) -> Optional[str]:
        """
        Add a file filter.
        """
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter(name="passwordProtected")
    def password_protected(self) -> Optional[str]:
        """
        Match password-protected files. Valid values: `yes`, `any`.
        """
        return pulumi.get(self, "password_protected")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[str]:
        """
        Protocols to apply with. Valid values: `http`, `ftp`.
        """
        return pulumi.get(self, "protocol")


@pulumi.output_type
class ProfileFileFilterEntryFileType(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: File type name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        File type name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProfileFtgdWf(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "exemptQuota":
            suggest = "exempt_quota"
        elif key == "maxQuotaTimeout":
            suggest = "max_quota_timeout"
        elif key == "rateCrlUrls":
            suggest = "rate_crl_urls"
        elif key == "rateCssUrls":
            suggest = "rate_css_urls"
        elif key == "rateImageUrls":
            suggest = "rate_image_urls"
        elif key == "rateJavascriptUrls":
            suggest = "rate_javascript_urls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileFtgdWf. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileFtgdWf.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileFtgdWf.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exempt_quota: Optional[str] = None,
                 filters: Optional[Sequence['outputs.ProfileFtgdWfFilter']] = None,
                 max_quota_timeout: Optional[int] = None,
                 options: Optional[str] = None,
                 ovrd: Optional[str] = None,
                 quotas: Optional[Sequence['outputs.ProfileFtgdWfQuota']] = None,
                 rate_crl_urls: Optional[str] = None,
                 rate_css_urls: Optional[str] = None,
                 rate_image_urls: Optional[str] = None,
                 rate_javascript_urls: Optional[str] = None):
        """
        :param str exempt_quota: Do not stop quota for these categories.
        :param Sequence['ProfileFtgdWfFilterArgs'] filters: FortiGuard filters. The structure of `filters` block is documented below.
        :param int max_quota_timeout: Maximum FortiGuard quota used by single page view in seconds (excludes streams).
        :param str options: Options for FortiGuard Web Filter. Valid values: `error-allow`, `rate-server-ip`, `connect-request-bypass`, `ftgd-disable`.
        :param str ovrd: Allow web filter profile overrides.
        :param Sequence['ProfileFtgdWfQuotaArgs'] quotas: FortiGuard traffic quota settings. The structure of `quota` block is documented below.
        :param str rate_crl_urls: Enable/disable rating CRL by URL. Valid values: `disable`, `enable`.
        :param str rate_css_urls: Enable/disable rating CSS by URL. Valid values: `disable`, `enable`.
        :param str rate_image_urls: Enable/disable rating images by URL. Valid values: `disable`, `enable`.
        :param str rate_javascript_urls: Enable/disable rating JavaScript by URL. Valid values: `disable`, `enable`.
        """
        if exempt_quota is not None:
            pulumi.set(__self__, "exempt_quota", exempt_quota)
        if filters is not None:
            pulumi.set(__self__, "filters", filters)
        if max_quota_timeout is not None:
            pulumi.set(__self__, "max_quota_timeout", max_quota_timeout)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if ovrd is not None:
            pulumi.set(__self__, "ovrd", ovrd)
        if quotas is not None:
            pulumi.set(__self__, "quotas", quotas)
        if rate_crl_urls is not None:
            pulumi.set(__self__, "rate_crl_urls", rate_crl_urls)
        if rate_css_urls is not None:
            pulumi.set(__self__, "rate_css_urls", rate_css_urls)
        if rate_image_urls is not None:
            pulumi.set(__self__, "rate_image_urls", rate_image_urls)
        if rate_javascript_urls is not None:
            pulumi.set(__self__, "rate_javascript_urls", rate_javascript_urls)

    @property
    @pulumi.getter(name="exemptQuota")
    def exempt_quota(self) -> Optional[str]:
        """
        Do not stop quota for these categories.
        """
        return pulumi.get(self, "exempt_quota")

    @property
    @pulumi.getter
    def filters(self) -> Optional[Sequence['outputs.ProfileFtgdWfFilter']]:
        """
        FortiGuard filters. The structure of `filters` block is documented below.
        """
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter(name="maxQuotaTimeout")
    def max_quota_timeout(self) -> Optional[int]:
        """
        Maximum FortiGuard quota used by single page view in seconds (excludes streams).
        """
        return pulumi.get(self, "max_quota_timeout")

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        Options for FortiGuard Web Filter. Valid values: `error-allow`, `rate-server-ip`, `connect-request-bypass`, `ftgd-disable`.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def ovrd(self) -> Optional[str]:
        """
        Allow web filter profile overrides.
        """
        return pulumi.get(self, "ovrd")

    @property
    @pulumi.getter
    def quotas(self) -> Optional[Sequence['outputs.ProfileFtgdWfQuota']]:
        """
        FortiGuard traffic quota settings. The structure of `quota` block is documented below.
        """
        return pulumi.get(self, "quotas")

    @property
    @pulumi.getter(name="rateCrlUrls")
    def rate_crl_urls(self) -> Optional[str]:
        """
        Enable/disable rating CRL by URL. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "rate_crl_urls")

    @property
    @pulumi.getter(name="rateCssUrls")
    def rate_css_urls(self) -> Optional[str]:
        """
        Enable/disable rating CSS by URL. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "rate_css_urls")

    @property
    @pulumi.getter(name="rateImageUrls")
    def rate_image_urls(self) -> Optional[str]:
        """
        Enable/disable rating images by URL. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "rate_image_urls")

    @property
    @pulumi.getter(name="rateJavascriptUrls")
    def rate_javascript_urls(self) -> Optional[str]:
        """
        Enable/disable rating JavaScript by URL. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "rate_javascript_urls")


@pulumi.output_type
class ProfileFtgdWfFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authUsrGrps":
            suggest = "auth_usr_grps"
        elif key == "overrideReplacemsg":
            suggest = "override_replacemsg"
        elif key == "warnDuration":
            suggest = "warn_duration"
        elif key == "warningDurationType":
            suggest = "warning_duration_type"
        elif key == "warningPrompt":
            suggest = "warning_prompt"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileFtgdWfFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileFtgdWfFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileFtgdWfFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 auth_usr_grps: Optional[Sequence['outputs.ProfileFtgdWfFilterAuthUsrGrp']] = None,
                 category: Optional[int] = None,
                 id: Optional[int] = None,
                 log: Optional[str] = None,
                 override_replacemsg: Optional[str] = None,
                 warn_duration: Optional[str] = None,
                 warning_duration_type: Optional[str] = None,
                 warning_prompt: Optional[str] = None):
        """
        :param str action: Action to take for matches. Valid values: `block`, `authenticate`, `monitor`, `warning`.
        :param Sequence['ProfileFtgdWfFilterAuthUsrGrpArgs'] auth_usr_grps: Groups with permission to authenticate. The structure of `auth_usr_grp` block is documented below.
        :param int category: Categories and groups the filter examines.
        :param int id: ID number.
        :param str log: Enable/disable logging. Valid values: `enable`, `disable`.
        :param str override_replacemsg: Override replacement message.
        :param str warn_duration: Duration of warnings.
        :param str warning_duration_type: Re-display warning after closing browser or after a timeout. Valid values: `session`, `timeout`.
        :param str warning_prompt: Warning prompts in each category or each domain. Valid values: `per-domain`, `per-category`.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if auth_usr_grps is not None:
            pulumi.set(__self__, "auth_usr_grps", auth_usr_grps)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if log is not None:
            pulumi.set(__self__, "log", log)
        if override_replacemsg is not None:
            pulumi.set(__self__, "override_replacemsg", override_replacemsg)
        if warn_duration is not None:
            pulumi.set(__self__, "warn_duration", warn_duration)
        if warning_duration_type is not None:
            pulumi.set(__self__, "warning_duration_type", warning_duration_type)
        if warning_prompt is not None:
            pulumi.set(__self__, "warning_prompt", warning_prompt)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action to take for matches. Valid values: `block`, `authenticate`, `monitor`, `warning`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="authUsrGrps")
    def auth_usr_grps(self) -> Optional[Sequence['outputs.ProfileFtgdWfFilterAuthUsrGrp']]:
        """
        Groups with permission to authenticate. The structure of `auth_usr_grp` block is documented below.
        """
        return pulumi.get(self, "auth_usr_grps")

    @property
    @pulumi.getter
    def category(self) -> Optional[int]:
        """
        Categories and groups the filter examines.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        ID number.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def log(self) -> Optional[str]:
        """
        Enable/disable logging. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log")

    @property
    @pulumi.getter(name="overrideReplacemsg")
    def override_replacemsg(self) -> Optional[str]:
        """
        Override replacement message.
        """
        return pulumi.get(self, "override_replacemsg")

    @property
    @pulumi.getter(name="warnDuration")
    def warn_duration(self) -> Optional[str]:
        """
        Duration of warnings.
        """
        return pulumi.get(self, "warn_duration")

    @property
    @pulumi.getter(name="warningDurationType")
    def warning_duration_type(self) -> Optional[str]:
        """
        Re-display warning after closing browser or after a timeout. Valid values: `session`, `timeout`.
        """
        return pulumi.get(self, "warning_duration_type")

    @property
    @pulumi.getter(name="warningPrompt")
    def warning_prompt(self) -> Optional[str]:
        """
        Warning prompts in each category or each domain. Valid values: `per-domain`, `per-category`.
        """
        return pulumi.get(self, "warning_prompt")


@pulumi.output_type
class ProfileFtgdWfFilterAuthUsrGrp(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: User group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        User group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProfileFtgdWfQuota(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overrideReplacemsg":
            suggest = "override_replacemsg"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileFtgdWfQuota. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileFtgdWfQuota.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileFtgdWfQuota.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 category: Optional[str] = None,
                 duration: Optional[str] = None,
                 id: Optional[int] = None,
                 override_replacemsg: Optional[str] = None,
                 type: Optional[str] = None,
                 unit: Optional[str] = None,
                 value: Optional[int] = None):
        """
        :param str category: FortiGuard categories to apply quota to (category action must be set to monitor).
        :param str duration: Duration of quota.
        :param int id: ID number.
        :param str override_replacemsg: Override replacement message.
        :param str type: Quota type. Valid values: `time`, `traffic`.
        :param str unit: Traffic quota unit of measurement. Valid values: `B`, `KB`, `MB`, `GB`.
        :param int value: Traffic quota value.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if override_replacemsg is not None:
            pulumi.set(__self__, "override_replacemsg", override_replacemsg)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        FortiGuard categories to apply quota to (category action must be set to monitor).
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def duration(self) -> Optional[str]:
        """
        Duration of quota.
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        ID number.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="overrideReplacemsg")
    def override_replacemsg(self) -> Optional[str]:
        """
        Override replacement message.
        """
        return pulumi.get(self, "override_replacemsg")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Quota type. Valid values: `time`, `traffic`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        Traffic quota unit of measurement. Valid values: `B`, `KB`, `MB`, `GB`.
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def value(self) -> Optional[int]:
        """
        Traffic quota value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ProfileOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ovrdCookie":
            suggest = "ovrd_cookie"
        elif key == "ovrdDur":
            suggest = "ovrd_dur"
        elif key == "ovrdDurMode":
            suggest = "ovrd_dur_mode"
        elif key == "ovrdScope":
            suggest = "ovrd_scope"
        elif key == "ovrdUserGroups":
            suggest = "ovrd_user_groups"
        elif key == "profileAttribute":
            suggest = "profile_attribute"
        elif key == "profileType":
            suggest = "profile_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ovrd_cookie: Optional[str] = None,
                 ovrd_dur: Optional[str] = None,
                 ovrd_dur_mode: Optional[str] = None,
                 ovrd_scope: Optional[str] = None,
                 ovrd_user_groups: Optional[Sequence['outputs.ProfileOverrideOvrdUserGroup']] = None,
                 profile_attribute: Optional[str] = None,
                 profile_type: Optional[str] = None,
                 profiles: Optional[Sequence['outputs.ProfileOverrideProfile']] = None):
        """
        :param str ovrd_cookie: Allow/deny browser-based (cookie) overrides. Valid values: `allow`, `deny`.
        :param str ovrd_dur: Override duration.
        :param str ovrd_dur_mode: Override duration mode. Valid values: `constant`, `ask`.
        :param str ovrd_scope: Override scope. Valid values: `user`, `user-group`, `ip`, `browser`, `ask`.
        :param Sequence['ProfileOverrideOvrdUserGroupArgs'] ovrd_user_groups: User groups with permission to use the override. The structure of `ovrd_user_group` block is documented below.
        :param str profile_attribute: Profile attribute to retrieve from the RADIUS server. Valid values: `User-Name`, `NAS-IP-Address`, `Framed-IP-Address`, `Framed-IP-Netmask`, `Filter-Id`, `Login-IP-Host`, `Reply-Message`, `Callback-Number`, `Callback-Id`, `Framed-Route`, `Framed-IPX-Network`, `Class`, `Called-Station-Id`, `Calling-Station-Id`, `NAS-Identifier`, `Proxy-State`, `Login-LAT-Service`, `Login-LAT-Node`, `Login-LAT-Group`, `Framed-AppleTalk-Zone`, `Acct-Session-Id`, `Acct-Multi-Session-Id`.
        :param str profile_type: Override profile type. Valid values: `list`, `radius`.
        :param Sequence['ProfileOverrideProfileArgs'] profiles: Web filter profile with permission to create overrides. The structure of `profile` block is documented below.
        """
        if ovrd_cookie is not None:
            pulumi.set(__self__, "ovrd_cookie", ovrd_cookie)
        if ovrd_dur is not None:
            pulumi.set(__self__, "ovrd_dur", ovrd_dur)
        if ovrd_dur_mode is not None:
            pulumi.set(__self__, "ovrd_dur_mode", ovrd_dur_mode)
        if ovrd_scope is not None:
            pulumi.set(__self__, "ovrd_scope", ovrd_scope)
        if ovrd_user_groups is not None:
            pulumi.set(__self__, "ovrd_user_groups", ovrd_user_groups)
        if profile_attribute is not None:
            pulumi.set(__self__, "profile_attribute", profile_attribute)
        if profile_type is not None:
            pulumi.set(__self__, "profile_type", profile_type)
        if profiles is not None:
            pulumi.set(__self__, "profiles", profiles)

    @property
    @pulumi.getter(name="ovrdCookie")
    def ovrd_cookie(self) -> Optional[str]:
        """
        Allow/deny browser-based (cookie) overrides. Valid values: `allow`, `deny`.
        """
        return pulumi.get(self, "ovrd_cookie")

    @property
    @pulumi.getter(name="ovrdDur")
    def ovrd_dur(self) -> Optional[str]:
        """
        Override duration.
        """
        return pulumi.get(self, "ovrd_dur")

    @property
    @pulumi.getter(name="ovrdDurMode")
    def ovrd_dur_mode(self) -> Optional[str]:
        """
        Override duration mode. Valid values: `constant`, `ask`.
        """
        return pulumi.get(self, "ovrd_dur_mode")

    @property
    @pulumi.getter(name="ovrdScope")
    def ovrd_scope(self) -> Optional[str]:
        """
        Override scope. Valid values: `user`, `user-group`, `ip`, `browser`, `ask`.
        """
        return pulumi.get(self, "ovrd_scope")

    @property
    @pulumi.getter(name="ovrdUserGroups")
    def ovrd_user_groups(self) -> Optional[Sequence['outputs.ProfileOverrideOvrdUserGroup']]:
        """
        User groups with permission to use the override. The structure of `ovrd_user_group` block is documented below.
        """
        return pulumi.get(self, "ovrd_user_groups")

    @property
    @pulumi.getter(name="profileAttribute")
    def profile_attribute(self) -> Optional[str]:
        """
        Profile attribute to retrieve from the RADIUS server. Valid values: `User-Name`, `NAS-IP-Address`, `Framed-IP-Address`, `Framed-IP-Netmask`, `Filter-Id`, `Login-IP-Host`, `Reply-Message`, `Callback-Number`, `Callback-Id`, `Framed-Route`, `Framed-IPX-Network`, `Class`, `Called-Station-Id`, `Calling-Station-Id`, `NAS-Identifier`, `Proxy-State`, `Login-LAT-Service`, `Login-LAT-Node`, `Login-LAT-Group`, `Framed-AppleTalk-Zone`, `Acct-Session-Id`, `Acct-Multi-Session-Id`.
        """
        return pulumi.get(self, "profile_attribute")

    @property
    @pulumi.getter(name="profileType")
    def profile_type(self) -> Optional[str]:
        """
        Override profile type. Valid values: `list`, `radius`.
        """
        return pulumi.get(self, "profile_type")

    @property
    @pulumi.getter
    def profiles(self) -> Optional[Sequence['outputs.ProfileOverrideProfile']]:
        """
        Web filter profile with permission to create overrides. The structure of `profile` block is documented below.
        """
        return pulumi.get(self, "profiles")


@pulumi.output_type
class ProfileOverrideOvrdUserGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: User group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        User group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProfileOverrideProfile(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Web profile.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Web profile.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProfileWeb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bwordTable":
            suggest = "bword_table"
        elif key == "bwordThreshold":
            suggest = "bword_threshold"
        elif key == "contentHeaderList":
            suggest = "content_header_list"
        elif key == "keywordMatches":
            suggest = "keyword_matches"
        elif key == "logSearch":
            suggest = "log_search"
        elif key == "safeSearch":
            suggest = "safe_search"
        elif key == "urlfilterTable":
            suggest = "urlfilter_table"
        elif key == "vimeoRestrict":
            suggest = "vimeo_restrict"
        elif key == "youtubeRestrict":
            suggest = "youtube_restrict"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileWeb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileWeb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileWeb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowlist: Optional[str] = None,
                 blacklist: Optional[str] = None,
                 blocklist: Optional[str] = None,
                 bword_table: Optional[int] = None,
                 bword_threshold: Optional[int] = None,
                 content_header_list: Optional[int] = None,
                 keyword_matches: Optional[Sequence['outputs.ProfileWebKeywordMatch']] = None,
                 log_search: Optional[str] = None,
                 safe_search: Optional[str] = None,
                 urlfilter_table: Optional[int] = None,
                 vimeo_restrict: Optional[str] = None,
                 whitelist: Optional[str] = None,
                 youtube_restrict: Optional[str] = None):
        """
        :param str allowlist: FortiGuard allowlist settings. Valid values: `exempt-av`, `exempt-webcontent`, `exempt-activex-java-cookie`, `exempt-dlp`, `exempt-rangeblock`, `extended-log-others`.
        :param str blacklist: Enable/disable automatic addition of URLs detected by FortiSandbox to blacklist. Valid values: `enable`, `disable`.
        :param str blocklist: Enable/disable automatic addition of URLs detected by FortiSandbox to blocklist. Valid values: `enable`, `disable`.
        :param int bword_table: Banned word table ID.
        :param int bword_threshold: Banned word score threshold.
        :param int content_header_list: Content header list.
        :param Sequence['ProfileWebKeywordMatchArgs'] keyword_matches: Search keywords to log when match is found. The structure of `keyword_match` block is documented below.
        :param str log_search: Enable/disable logging all search phrases. Valid values: `enable`, `disable`.
        :param str safe_search: Safe search type. Valid values: `url`, `header`.
        :param int urlfilter_table: URL filter table ID.
        :param str vimeo_restrict: Set Vimeo-restrict ("7" = don't show mature content, "134" = don't show unrated and mature content). A value of cookie "content_rating".
        :param str whitelist: FortiGuard whitelist settings. Valid values: `exempt-av`, `exempt-webcontent`, `exempt-activex-java-cookie`, `exempt-dlp`, `exempt-rangeblock`, `extended-log-others`.
        :param str youtube_restrict: YouTube EDU filter level. Valid values: `none`, `strict`, `moderate`.
        """
        if allowlist is not None:
            pulumi.set(__self__, "allowlist", allowlist)
        if blacklist is not None:
            pulumi.set(__self__, "blacklist", blacklist)
        if blocklist is not None:
            pulumi.set(__self__, "blocklist", blocklist)
        if bword_table is not None:
            pulumi.set(__self__, "bword_table", bword_table)
        if bword_threshold is not None:
            pulumi.set(__self__, "bword_threshold", bword_threshold)
        if content_header_list is not None:
            pulumi.set(__self__, "content_header_list", content_header_list)
        if keyword_matches is not None:
            pulumi.set(__self__, "keyword_matches", keyword_matches)
        if log_search is not None:
            pulumi.set(__self__, "log_search", log_search)
        if safe_search is not None:
            pulumi.set(__self__, "safe_search", safe_search)
        if urlfilter_table is not None:
            pulumi.set(__self__, "urlfilter_table", urlfilter_table)
        if vimeo_restrict is not None:
            pulumi.set(__self__, "vimeo_restrict", vimeo_restrict)
        if whitelist is not None:
            pulumi.set(__self__, "whitelist", whitelist)
        if youtube_restrict is not None:
            pulumi.set(__self__, "youtube_restrict", youtube_restrict)

    @property
    @pulumi.getter
    def allowlist(self) -> Optional[str]:
        """
        FortiGuard allowlist settings. Valid values: `exempt-av`, `exempt-webcontent`, `exempt-activex-java-cookie`, `exempt-dlp`, `exempt-rangeblock`, `extended-log-others`.
        """
        return pulumi.get(self, "allowlist")

    @property
    @pulumi.getter
    def blacklist(self) -> Optional[str]:
        """
        Enable/disable automatic addition of URLs detected by FortiSandbox to blacklist. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "blacklist")

    @property
    @pulumi.getter
    def blocklist(self) -> Optional[str]:
        """
        Enable/disable automatic addition of URLs detected by FortiSandbox to blocklist. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "blocklist")

    @property
    @pulumi.getter(name="bwordTable")
    def bword_table(self) -> Optional[int]:
        """
        Banned word table ID.
        """
        return pulumi.get(self, "bword_table")

    @property
    @pulumi.getter(name="bwordThreshold")
    def bword_threshold(self) -> Optional[int]:
        """
        Banned word score threshold.
        """
        return pulumi.get(self, "bword_threshold")

    @property
    @pulumi.getter(name="contentHeaderList")
    def content_header_list(self) -> Optional[int]:
        """
        Content header list.
        """
        return pulumi.get(self, "content_header_list")

    @property
    @pulumi.getter(name="keywordMatches")
    def keyword_matches(self) -> Optional[Sequence['outputs.ProfileWebKeywordMatch']]:
        """
        Search keywords to log when match is found. The structure of `keyword_match` block is documented below.
        """
        return pulumi.get(self, "keyword_matches")

    @property
    @pulumi.getter(name="logSearch")
    def log_search(self) -> Optional[str]:
        """
        Enable/disable logging all search phrases. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "log_search")

    @property
    @pulumi.getter(name="safeSearch")
    def safe_search(self) -> Optional[str]:
        """
        Safe search type. Valid values: `url`, `header`.
        """
        return pulumi.get(self, "safe_search")

    @property
    @pulumi.getter(name="urlfilterTable")
    def urlfilter_table(self) -> Optional[int]:
        """
        URL filter table ID.
        """
        return pulumi.get(self, "urlfilter_table")

    @property
    @pulumi.getter(name="vimeoRestrict")
    def vimeo_restrict(self) -> Optional[str]:
        """
        Set Vimeo-restrict ("7" = don't show mature content, "134" = don't show unrated and mature content). A value of cookie "content_rating".
        """
        return pulumi.get(self, "vimeo_restrict")

    @property
    @pulumi.getter
    def whitelist(self) -> Optional[str]:
        """
        FortiGuard whitelist settings. Valid values: `exempt-av`, `exempt-webcontent`, `exempt-activex-java-cookie`, `exempt-dlp`, `exempt-rangeblock`, `extended-log-others`.
        """
        return pulumi.get(self, "whitelist")

    @property
    @pulumi.getter(name="youtubeRestrict")
    def youtube_restrict(self) -> Optional[str]:
        """
        YouTube EDU filter level. Valid values: `none`, `strict`, `moderate`.
        """
        return pulumi.get(self, "youtube_restrict")


@pulumi.output_type
class ProfileWebKeywordMatch(dict):
    def __init__(__self__, *,
                 pattern: Optional[str] = None):
        """
        :param str pattern: Pattern/keyword to search for.
        """
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[str]:
        """
        Pattern/keyword to search for.
        """
        return pulumi.get(self, "pattern")


@pulumi.output_type
class ProfileWispServer(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Server name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Server name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ProfileYoutubeChannelFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelId":
            suggest = "channel_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ProfileYoutubeChannelFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ProfileYoutubeChannelFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ProfileYoutubeChannelFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_id: Optional[str] = None,
                 comment: Optional[str] = None,
                 id: Optional[int] = None):
        """
        :param str channel_id: YouTube channel ID to be filtered.
        :param str comment: Comment.
        :param int id: ID.
        """
        if channel_id is not None:
            pulumi.set(__self__, "channel_id", channel_id)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="channelId")
    def channel_id(self) -> Optional[str]:
        """
        YouTube channel ID to be filtered.
        """
        return pulumi.get(self, "channel_id")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Comment.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class UrlfilterEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "antiphishAction":
            suggest = "antiphish_action"
        elif key == "dnsAddressFamily":
            suggest = "dns_address_family"
        elif key == "referrerHost":
            suggest = "referrer_host"
        elif key == "webProxyProfile":
            suggest = "web_proxy_profile"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in UrlfilterEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        UrlfilterEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        UrlfilterEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 antiphish_action: Optional[str] = None,
                 dns_address_family: Optional[str] = None,
                 exempt: Optional[str] = None,
                 id: Optional[int] = None,
                 referrer_host: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None,
                 url: Optional[str] = None,
                 web_proxy_profile: Optional[str] = None):
        """
        :param str action: Action to take for URL filter matches. Valid values: `exempt`, `block`, `allow`, `monitor`.
        :param str antiphish_action: Action to take for AntiPhishing matches. Valid values: `block`, `log`.
        :param str dns_address_family: Resolve IPv4 address, IPv6 address, or both from DNS server. Valid values: `ipv4`, `ipv6`, `both`.
        :param str exempt: If action is set to exempt, select the security profile operations that exempt URLs skip. Separate multiple options with a space.
        :param int id: Id.
        :param str referrer_host: Referrer host name.
        :param str status: Enable/disable this URL filter. Valid values: `enable`, `disable`.
        :param str type: Filter type (simple, regex, or wildcard). Valid values: `simple`, `regex`, `wildcard`.
        :param str url: URL to be filtered.
        :param str web_proxy_profile: Web proxy profile.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if antiphish_action is not None:
            pulumi.set(__self__, "antiphish_action", antiphish_action)
        if dns_address_family is not None:
            pulumi.set(__self__, "dns_address_family", dns_address_family)
        if exempt is not None:
            pulumi.set(__self__, "exempt", exempt)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if referrer_host is not None:
            pulumi.set(__self__, "referrer_host", referrer_host)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if web_proxy_profile is not None:
            pulumi.set(__self__, "web_proxy_profile", web_proxy_profile)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Action to take for URL filter matches. Valid values: `exempt`, `block`, `allow`, `monitor`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter(name="antiphishAction")
    def antiphish_action(self) -> Optional[str]:
        """
        Action to take for AntiPhishing matches. Valid values: `block`, `log`.
        """
        return pulumi.get(self, "antiphish_action")

    @property
    @pulumi.getter(name="dnsAddressFamily")
    def dns_address_family(self) -> Optional[str]:
        """
        Resolve IPv4 address, IPv6 address, or both from DNS server. Valid values: `ipv4`, `ipv6`, `both`.
        """
        return pulumi.get(self, "dns_address_family")

    @property
    @pulumi.getter
    def exempt(self) -> Optional[str]:
        """
        If action is set to exempt, select the security profile operations that exempt URLs skip. Separate multiple options with a space.
        """
        return pulumi.get(self, "exempt")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="referrerHost")
    def referrer_host(self) -> Optional[str]:
        """
        Referrer host name.
        """
        return pulumi.get(self, "referrer_host")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable this URL filter. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Filter type (simple, regex, or wildcard). Valid values: `simple`, `regex`, `wildcard`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def url(self) -> Optional[str]:
        """
        URL to be filtered.
        """
        return pulumi.get(self, "url")

    @property
    @pulumi.getter(name="webProxyProfile")
    def web_proxy_profile(self) -> Optional[str]:
        """
        Web proxy profile.
        """
        return pulumi.get(self, "web_proxy_profile")


