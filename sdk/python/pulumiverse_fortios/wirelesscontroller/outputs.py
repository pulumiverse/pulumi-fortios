# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'AccesscontrollistLayer3Ipv4Rule',
    'AccesscontrollistLayer3Ipv6Rule',
    'AddrgrpAddress',
    'ApcfgprofileCommandList',
    'ArrpprofileDarrpOptimizeSchedule',
    'BonjourprofilePolicyList',
    'IntercontrollerInterControllerPeer',
    'MpskprofileMpskGroup',
    'MpskprofileMpskGroupMpskKey',
    'MpskprofileMpskGroupMpskKeyMpskSchedule',
    'QosprofileDscpWmmBe',
    'QosprofileDscpWmmBk',
    'QosprofileDscpWmmVi',
    'QosprofileDscpWmmVo',
    'SettingDarrpOptimizeSchedule',
    'SettingOffendingSsid',
    'SnmpCommunity',
    'SnmpCommunityHost',
    'SnmpUser',
    'TimersDarrpTime',
    'VapMacFilterList',
    'VapMpskKey',
    'VapMpskKeyMpskSchedule',
    'VapPortalMessageOverrides',
    'VapRadiusMacAuthUsergroup',
    'VapSelectedUsergroup',
    'VapUsergroup',
    'VapVlanName',
    'VapVlanPool',
    'VapgroupVap',
    'WidsprofileApBgscanDisableSchedule',
    'WidsprofileApScanChannelList2g5g',
    'WidsprofileApScanChannelList6g',
    'WtpLan',
    'WtpRadio1',
    'WtpRadio1Channel',
    'WtpRadio1Vap',
    'WtpRadio2',
    'WtpRadio2Channel',
    'WtpRadio2Vap',
    'WtpRadio3',
    'WtpRadio3Channel',
    'WtpRadio3Vap',
    'WtpRadio4',
    'WtpRadio4Channel',
    'WtpRadio4Vap',
    'WtpSplitTunnelingAcl',
    'WtpgroupWtp',
    'WtpprofileDenyMacList',
    'WtpprofileEslSesDongle',
    'WtpprofileLan',
    'WtpprofileLbs',
    'WtpprofileLedSchedule',
    'WtpprofilePlatform',
    'WtpprofileRadio1',
    'WtpprofileRadio1Channel',
    'WtpprofileRadio1Vap',
    'WtpprofileRadio2',
    'WtpprofileRadio2Channel',
    'WtpprofileRadio2Vap',
    'WtpprofileRadio3',
    'WtpprofileRadio3Channel',
    'WtpprofileRadio3Vap',
    'WtpprofileRadio4',
    'WtpprofileRadio4Channel',
    'WtpprofileRadio4Vap',
    'WtpprofileSplitTunnelingAcl',
]

@pulumi.output_type
class AccesscontrollistLayer3Ipv4Rule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleId":
            suggest = "rule_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccesscontrollistLayer3Ipv4Rule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccesscontrollistLayer3Ipv4Rule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccesscontrollistLayer3Ipv4Rule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 comment: Optional[str] = None,
                 dstaddr: Optional[str] = None,
                 dstport: Optional[int] = None,
                 protocol: Optional[int] = None,
                 rule_id: Optional[int] = None,
                 srcaddr: Optional[str] = None,
                 srcport: Optional[int] = None):
        """
        :param str action: Policy action (allow | deny). Valid values: `allow`, `deny`.
        :param str comment: Description.
        :param str dstaddr: Destination IPv6 address (any | local-LAN | IPv6 address[/prefix length]), default = any.
        :param int dstport: Destination port (0 - 65535, default = 0, meaning any).
        :param int protocol: Protocol type as defined by IANA (0 - 255, default = 255, meaning any).
        :param int rule_id: Rule ID (1 - 65535).
        :param str srcaddr: Source IPv6 address (any | local-LAN | IPv6 address[/prefix length]), default = any.
        :param int srcport: Source port (0 - 65535, default = 0, meaning any).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dstaddr is not None:
            pulumi.set(__self__, "dstaddr", dstaddr)
        if dstport is not None:
            pulumi.set(__self__, "dstport", dstport)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if srcaddr is not None:
            pulumi.set(__self__, "srcaddr", srcaddr)
        if srcport is not None:
            pulumi.set(__self__, "srcport", srcport)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Policy action (allow | deny). Valid values: `allow`, `deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Description.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def dstaddr(self) -> Optional[str]:
        """
        Destination IPv6 address (any | local-LAN | IPv6 address[/prefix length]), default = any.
        """
        return pulumi.get(self, "dstaddr")

    @property
    @pulumi.getter
    def dstport(self) -> Optional[int]:
        """
        Destination port (0 - 65535, default = 0, meaning any).
        """
        return pulumi.get(self, "dstport")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[int]:
        """
        Protocol type as defined by IANA (0 - 255, default = 255, meaning any).
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[int]:
        """
        Rule ID (1 - 65535).
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter
    def srcaddr(self) -> Optional[str]:
        """
        Source IPv6 address (any | local-LAN | IPv6 address[/prefix length]), default = any.
        """
        return pulumi.get(self, "srcaddr")

    @property
    @pulumi.getter
    def srcport(self) -> Optional[int]:
        """
        Source port (0 - 65535, default = 0, meaning any).
        """
        return pulumi.get(self, "srcport")


@pulumi.output_type
class AccesscontrollistLayer3Ipv6Rule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ruleId":
            suggest = "rule_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AccesscontrollistLayer3Ipv6Rule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AccesscontrollistLayer3Ipv6Rule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AccesscontrollistLayer3Ipv6Rule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 comment: Optional[str] = None,
                 dstaddr: Optional[str] = None,
                 dstport: Optional[int] = None,
                 protocol: Optional[int] = None,
                 rule_id: Optional[int] = None,
                 srcaddr: Optional[str] = None,
                 srcport: Optional[int] = None):
        """
        :param str action: Policy action (allow | deny). Valid values: `allow`, `deny`.
        :param str comment: Description.
        :param str dstaddr: Destination IPv6 address (any | local-LAN | IPv6 address[/prefix length]), default = any.
        :param int dstport: Destination port (0 - 65535, default = 0, meaning any).
        :param int protocol: Protocol type as defined by IANA (0 - 255, default = 255, meaning any).
        :param int rule_id: Rule ID (1 - 65535).
        :param str srcaddr: Source IPv6 address (any | local-LAN | IPv6 address[/prefix length]), default = any.
        :param int srcport: Source port (0 - 65535, default = 0, meaning any).
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if dstaddr is not None:
            pulumi.set(__self__, "dstaddr", dstaddr)
        if dstport is not None:
            pulumi.set(__self__, "dstport", dstport)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)
        if srcaddr is not None:
            pulumi.set(__self__, "srcaddr", srcaddr)
        if srcport is not None:
            pulumi.set(__self__, "srcport", srcport)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Policy action (allow | deny). Valid values: `allow`, `deny`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Description.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter
    def dstaddr(self) -> Optional[str]:
        """
        Destination IPv6 address (any | local-LAN | IPv6 address[/prefix length]), default = any.
        """
        return pulumi.get(self, "dstaddr")

    @property
    @pulumi.getter
    def dstport(self) -> Optional[int]:
        """
        Destination port (0 - 65535, default = 0, meaning any).
        """
        return pulumi.get(self, "dstport")

    @property
    @pulumi.getter
    def protocol(self) -> Optional[int]:
        """
        Protocol type as defined by IANA (0 - 255, default = 255, meaning any).
        """
        return pulumi.get(self, "protocol")

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[int]:
        """
        Rule ID (1 - 65535).
        """
        return pulumi.get(self, "rule_id")

    @property
    @pulumi.getter
    def srcaddr(self) -> Optional[str]:
        """
        Source IPv6 address (any | local-LAN | IPv6 address[/prefix length]), default = any.
        """
        return pulumi.get(self, "srcaddr")

    @property
    @pulumi.getter
    def srcport(self) -> Optional[int]:
        """
        Source port (0 - 65535, default = 0, meaning any).
        """
        return pulumi.get(self, "srcport")


@pulumi.output_type
class AddrgrpAddress(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None):
        """
        :param str id: Address ID.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Address ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ApcfgprofileCommandList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "passwdValue":
            suggest = "passwd_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ApcfgprofileCommandList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ApcfgprofileCommandList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ApcfgprofileCommandList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[int] = None,
                 name: Optional[str] = None,
                 passwd_value: Optional[str] = None,
                 type: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param int id: Command ID.
        :param str name: AP local configuration command name.
        :param str passwd_value: AP local configuration command password value.
        :param str type: The command type (default = non-password). Valid values: `non-password`, `password`.
        :param str value: AP local configuration command value.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if passwd_value is not None:
            pulumi.set(__self__, "passwd_value", passwd_value)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Command ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        AP local configuration command name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="passwdValue")
    def passwd_value(self) -> Optional[str]:
        """
        AP local configuration command password value.
        """
        return pulumi.get(self, "passwd_value")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        The command type (default = non-password). Valid values: `non-password`, `password`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        AP local configuration command value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ArrpprofileDarrpOptimizeSchedule(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Schedule name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Schedule name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class BonjourprofilePolicyList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fromVlan":
            suggest = "from_vlan"
        elif key == "policyId":
            suggest = "policy_id"
        elif key == "toVlan":
            suggest = "to_vlan"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BonjourprofilePolicyList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BonjourprofilePolicyList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BonjourprofilePolicyList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 from_vlan: Optional[str] = None,
                 policy_id: Optional[int] = None,
                 services: Optional[str] = None,
                 to_vlan: Optional[str] = None):
        """
        :param str description: Description.
        :param str from_vlan: VLAN ID from which the Bonjour service is advertised (0 - 4094, default = 0).
        :param int policy_id: Policy ID.
        :param str services: Bonjour services for the VLAN connecting to the Bonjour network.
        :param str to_vlan: VLAN ID to which the Bonjour service is made available (0 - 4094, default = all).
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if from_vlan is not None:
            pulumi.set(__self__, "from_vlan", from_vlan)
        if policy_id is not None:
            pulumi.set(__self__, "policy_id", policy_id)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if to_vlan is not None:
            pulumi.set(__self__, "to_vlan", to_vlan)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="fromVlan")
    def from_vlan(self) -> Optional[str]:
        """
        VLAN ID from which the Bonjour service is advertised (0 - 4094, default = 0).
        """
        return pulumi.get(self, "from_vlan")

    @property
    @pulumi.getter(name="policyId")
    def policy_id(self) -> Optional[int]:
        """
        Policy ID.
        """
        return pulumi.get(self, "policy_id")

    @property
    @pulumi.getter
    def services(self) -> Optional[str]:
        """
        Bonjour services for the VLAN connecting to the Bonjour network.
        """
        return pulumi.get(self, "services")

    @property
    @pulumi.getter(name="toVlan")
    def to_vlan(self) -> Optional[str]:
        """
        VLAN ID to which the Bonjour service is made available (0 - 4094, default = all).
        """
        return pulumi.get(self, "to_vlan")


@pulumi.output_type
class IntercontrollerInterControllerPeer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "peerIp":
            suggest = "peer_ip"
        elif key == "peerPort":
            suggest = "peer_port"
        elif key == "peerPriority":
            suggest = "peer_priority"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in IntercontrollerInterControllerPeer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        IntercontrollerInterControllerPeer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        IntercontrollerInterControllerPeer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[int] = None,
                 peer_ip: Optional[str] = None,
                 peer_port: Optional[int] = None,
                 peer_priority: Optional[str] = None):
        """
        :param int id: ID.
        :param str peer_ip: Peer wireless controller's IP address.
        :param int peer_port: Port used by the wireless controller's for inter-controller communications (1024 - 49150, default = 5246).
        :param str peer_priority: Peer wireless controller's priority (primary or secondary, default = primary). Valid values: `primary`, `secondary`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if peer_ip is not None:
            pulumi.set(__self__, "peer_ip", peer_ip)
        if peer_port is not None:
            pulumi.set(__self__, "peer_port", peer_port)
        if peer_priority is not None:
            pulumi.set(__self__, "peer_priority", peer_priority)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="peerIp")
    def peer_ip(self) -> Optional[str]:
        """
        Peer wireless controller's IP address.
        """
        return pulumi.get(self, "peer_ip")

    @property
    @pulumi.getter(name="peerPort")
    def peer_port(self) -> Optional[int]:
        """
        Port used by the wireless controller's for inter-controller communications (1024 - 49150, default = 5246).
        """
        return pulumi.get(self, "peer_port")

    @property
    @pulumi.getter(name="peerPriority")
    def peer_priority(self) -> Optional[str]:
        """
        Peer wireless controller's priority (primary or secondary, default = primary). Valid values: `primary`, `secondary`.
        """
        return pulumi.get(self, "peer_priority")


@pulumi.output_type
class MpskprofileMpskGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mpskKeys":
            suggest = "mpsk_keys"
        elif key == "vlanId":
            suggest = "vlan_id"
        elif key == "vlanType":
            suggest = "vlan_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MpskprofileMpskGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MpskprofileMpskGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MpskprofileMpskGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mpsk_keys: Optional[Sequence['outputs.MpskprofileMpskGroupMpskKey']] = None,
                 name: Optional[str] = None,
                 vlan_id: Optional[int] = None,
                 vlan_type: Optional[str] = None):
        """
        :param Sequence['MpskprofileMpskGroupMpskKeyArgs'] mpsk_keys: List of multiple PSK entries. The structure of `mpsk_key` block is documented below.
        :param str name: MPSK group name.
        :param int vlan_id: Optional VLAN ID.
        :param str vlan_type: MPSK group VLAN options. Valid values: `no-vlan`, `fixed-vlan`.
        """
        if mpsk_keys is not None:
            pulumi.set(__self__, "mpsk_keys", mpsk_keys)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)
        if vlan_type is not None:
            pulumi.set(__self__, "vlan_type", vlan_type)

    @property
    @pulumi.getter(name="mpskKeys")
    def mpsk_keys(self) -> Optional[Sequence['outputs.MpskprofileMpskGroupMpskKey']]:
        """
        List of multiple PSK entries. The structure of `mpsk_key` block is documented below.
        """
        return pulumi.get(self, "mpsk_keys")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        MPSK group name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[int]:
        """
        Optional VLAN ID.
        """
        return pulumi.get(self, "vlan_id")

    @property
    @pulumi.getter(name="vlanType")
    def vlan_type(self) -> Optional[str]:
        """
        MPSK group VLAN options. Valid values: `no-vlan`, `fixed-vlan`.
        """
        return pulumi.get(self, "vlan_type")


@pulumi.output_type
class MpskprofileMpskGroupMpskKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "concurrentClientLimitType":
            suggest = "concurrent_client_limit_type"
        elif key == "concurrentClients":
            suggest = "concurrent_clients"
        elif key == "mpskSchedules":
            suggest = "mpsk_schedules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MpskprofileMpskGroupMpskKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MpskprofileMpskGroupMpskKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MpskprofileMpskGroupMpskKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[str] = None,
                 concurrent_client_limit_type: Optional[str] = None,
                 concurrent_clients: Optional[int] = None,
                 mac: Optional[str] = None,
                 mpsk_schedules: Optional[Sequence['outputs.MpskprofileMpskGroupMpskKeyMpskSchedule']] = None,
                 name: Optional[str] = None,
                 passphrase: Optional[str] = None):
        """
        :param str comment: Comment.
        :param str concurrent_client_limit_type: MPSK client limit type options. Valid values: `default`, `unlimited`, `specified`.
        :param int concurrent_clients: Number of clients that can connect using this pre-shared key (1 - 65535, default is 256).
        :param str mac: MAC address.
        :param Sequence['MpskprofileMpskGroupMpskKeyMpskScheduleArgs'] mpsk_schedules: Firewall schedule for MPSK passphrase. The passphrase will be effective only when at least one schedule is valid. The structure of `mpsk_schedules` block is documented below.
        :param str name: Pre-shared key name.
        :param str passphrase: WPA Pre-shared key.
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if concurrent_client_limit_type is not None:
            pulumi.set(__self__, "concurrent_client_limit_type", concurrent_client_limit_type)
        if concurrent_clients is not None:
            pulumi.set(__self__, "concurrent_clients", concurrent_clients)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if mpsk_schedules is not None:
            pulumi.set(__self__, "mpsk_schedules", mpsk_schedules)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Comment.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="concurrentClientLimitType")
    def concurrent_client_limit_type(self) -> Optional[str]:
        """
        MPSK client limit type options. Valid values: `default`, `unlimited`, `specified`.
        """
        return pulumi.get(self, "concurrent_client_limit_type")

    @property
    @pulumi.getter(name="concurrentClients")
    def concurrent_clients(self) -> Optional[int]:
        """
        Number of clients that can connect using this pre-shared key (1 - 65535, default is 256).
        """
        return pulumi.get(self, "concurrent_clients")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        """
        MAC address.
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter(name="mpskSchedules")
    def mpsk_schedules(self) -> Optional[Sequence['outputs.MpskprofileMpskGroupMpskKeyMpskSchedule']]:
        """
        Firewall schedule for MPSK passphrase. The passphrase will be effective only when at least one schedule is valid. The structure of `mpsk_schedules` block is documented below.
        """
        return pulumi.get(self, "mpsk_schedules")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Pre-shared key name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def passphrase(self) -> Optional[str]:
        """
        WPA Pre-shared key.
        """
        return pulumi.get(self, "passphrase")


@pulumi.output_type
class MpskprofileMpskGroupMpskKeyMpskSchedule(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Schedule name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Schedule name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class QosprofileDscpWmmBe(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: DSCP WMM mapping numbers (0 - 63).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        DSCP WMM mapping numbers (0 - 63).
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class QosprofileDscpWmmBk(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: DSCP WMM mapping numbers (0 - 63).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        DSCP WMM mapping numbers (0 - 63).
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class QosprofileDscpWmmVi(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: DSCP WMM mapping numbers (0 - 63).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        DSCP WMM mapping numbers (0 - 63).
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class QosprofileDscpWmmVo(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: DSCP WMM mapping numbers (0 - 63).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        DSCP WMM mapping numbers (0 - 63).
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class SettingDarrpOptimizeSchedule(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Schedule name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Schedule name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class SettingOffendingSsid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ssidPattern":
            suggest = "ssid_pattern"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingOffendingSsid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingOffendingSsid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingOffendingSsid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action: Optional[str] = None,
                 id: Optional[int] = None,
                 ssid_pattern: Optional[str] = None):
        """
        :param str action: Actions taken for detected offending SSID. Valid values: `log`, `suppress`.
        :param int id: ID.
        :param str ssid_pattern: Define offending SSID pattern (case insensitive), eg: word, word*, *word, wo*rd.
        """
        if action is not None:
            pulumi.set(__self__, "action", action)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ssid_pattern is not None:
            pulumi.set(__self__, "ssid_pattern", ssid_pattern)

    @property
    @pulumi.getter
    def action(self) -> Optional[str]:
        """
        Actions taken for detected offending SSID. Valid values: `log`, `suppress`.
        """
        return pulumi.get(self, "action")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="ssidPattern")
    def ssid_pattern(self) -> Optional[str]:
        """
        Define offending SSID pattern (case insensitive), eg: word, word*, *word, wo*rd.
        """
        return pulumi.get(self, "ssid_pattern")


@pulumi.output_type
class SnmpCommunity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryV1Status":
            suggest = "query_v1_status"
        elif key == "queryV2cStatus":
            suggest = "query_v2c_status"
        elif key == "trapV1Status":
            suggest = "trap_v1_status"
        elif key == "trapV2cStatus":
            suggest = "trap_v2c_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnmpCommunity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnmpCommunity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnmpCommunity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hosts: Optional[Sequence['outputs.SnmpCommunityHost']] = None,
                 id: Optional[int] = None,
                 name: Optional[str] = None,
                 query_v1_status: Optional[str] = None,
                 query_v2c_status: Optional[str] = None,
                 status: Optional[str] = None,
                 trap_v1_status: Optional[str] = None,
                 trap_v2c_status: Optional[str] = None):
        """
        :param Sequence['SnmpCommunityHostArgs'] hosts: Configure IPv4 SNMP managers (hosts). The structure of `hosts` block is documented below.
        :param int id: Community ID.
        :param str name: Community name.
        :param str query_v1_status: Enable/disable SNMP v1 queries. Valid values: `enable`, `disable`.
        :param str query_v2c_status: Enable/disable SNMP v2c queries. Valid values: `enable`, `disable`.
        :param str status: Enable/disable this SNMP community. Valid values: `enable`, `disable`.
        :param str trap_v1_status: Enable/disable SNMP v1 traps. Valid values: `enable`, `disable`.
        :param str trap_v2c_status: Enable/disable SNMP v2c traps. Valid values: `enable`, `disable`.
        """
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if query_v1_status is not None:
            pulumi.set(__self__, "query_v1_status", query_v1_status)
        if query_v2c_status is not None:
            pulumi.set(__self__, "query_v2c_status", query_v2c_status)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if trap_v1_status is not None:
            pulumi.set(__self__, "trap_v1_status", trap_v1_status)
        if trap_v2c_status is not None:
            pulumi.set(__self__, "trap_v2c_status", trap_v2c_status)

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.SnmpCommunityHost']]:
        """
        Configure IPv4 SNMP managers (hosts). The structure of `hosts` block is documented below.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Community ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Community name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="queryV1Status")
    def query_v1_status(self) -> Optional[str]:
        """
        Enable/disable SNMP v1 queries. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "query_v1_status")

    @property
    @pulumi.getter(name="queryV2cStatus")
    def query_v2c_status(self) -> Optional[str]:
        """
        Enable/disable SNMP v2c queries. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "query_v2c_status")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable this SNMP community. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="trapV1Status")
    def trap_v1_status(self) -> Optional[str]:
        """
        Enable/disable SNMP v1 traps. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "trap_v1_status")

    @property
    @pulumi.getter(name="trapV2cStatus")
    def trap_v2c_status(self) -> Optional[str]:
        """
        Enable/disable SNMP v2c traps. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "trap_v2c_status")


@pulumi.output_type
class SnmpCommunityHost(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None,
                 ip: Optional[str] = None):
        """
        :param int id: Host entry ID.
        :param str ip: IPv4 address of the SNMP manager (host).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Host entry ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address of the SNMP manager (host).
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class SnmpUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authProto":
            suggest = "auth_proto"
        elif key == "authPwd":
            suggest = "auth_pwd"
        elif key == "notifyHosts":
            suggest = "notify_hosts"
        elif key == "privProto":
            suggest = "priv_proto"
        elif key == "privPwd":
            suggest = "priv_pwd"
        elif key == "securityLevel":
            suggest = "security_level"
        elif key == "trapStatus":
            suggest = "trap_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SnmpUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SnmpUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SnmpUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_proto: Optional[str] = None,
                 auth_pwd: Optional[str] = None,
                 name: Optional[str] = None,
                 notify_hosts: Optional[str] = None,
                 priv_proto: Optional[str] = None,
                 priv_pwd: Optional[str] = None,
                 queries: Optional[str] = None,
                 security_level: Optional[str] = None,
                 status: Optional[str] = None,
                 trap_status: Optional[str] = None):
        """
        :param str auth_proto: Authentication protocol. Valid values: `md5`, `sha`.
        :param str auth_pwd: Password for authentication protocol.
        :param str name: SNMP User Name
        :param str notify_hosts: Configure SNMP User Notify Hosts.
        :param str priv_proto: Privacy (encryption) protocol. Valid values: `aes`, `des`, `aes256`, `aes256cisco`.
        :param str priv_pwd: Password for privacy (encryption) protocol.
        :param str queries: Enable/disable SNMP queries for this user. Valid values: `enable`, `disable`.
        :param str security_level: Security level for message authentication and encryption. Valid values: `no-auth-no-priv`, `auth-no-priv`, `auth-priv`.
        :param str status: SNMP User Enable Valid values: `enable`, `disable`.
        :param str trap_status: Enable/disable traps for this SNMP user. Valid values: `enable`, `disable`.
        """
        if auth_proto is not None:
            pulumi.set(__self__, "auth_proto", auth_proto)
        if auth_pwd is not None:
            pulumi.set(__self__, "auth_pwd", auth_pwd)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if notify_hosts is not None:
            pulumi.set(__self__, "notify_hosts", notify_hosts)
        if priv_proto is not None:
            pulumi.set(__self__, "priv_proto", priv_proto)
        if priv_pwd is not None:
            pulumi.set(__self__, "priv_pwd", priv_pwd)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if trap_status is not None:
            pulumi.set(__self__, "trap_status", trap_status)

    @property
    @pulumi.getter(name="authProto")
    def auth_proto(self) -> Optional[str]:
        """
        Authentication protocol. Valid values: `md5`, `sha`.
        """
        return pulumi.get(self, "auth_proto")

    @property
    @pulumi.getter(name="authPwd")
    def auth_pwd(self) -> Optional[str]:
        """
        Password for authentication protocol.
        """
        return pulumi.get(self, "auth_pwd")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        SNMP User Name
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="notifyHosts")
    def notify_hosts(self) -> Optional[str]:
        """
        Configure SNMP User Notify Hosts.
        """
        return pulumi.get(self, "notify_hosts")

    @property
    @pulumi.getter(name="privProto")
    def priv_proto(self) -> Optional[str]:
        """
        Privacy (encryption) protocol. Valid values: `aes`, `des`, `aes256`, `aes256cisco`.
        """
        return pulumi.get(self, "priv_proto")

    @property
    @pulumi.getter(name="privPwd")
    def priv_pwd(self) -> Optional[str]:
        """
        Password for privacy (encryption) protocol.
        """
        return pulumi.get(self, "priv_pwd")

    @property
    @pulumi.getter
    def queries(self) -> Optional[str]:
        """
        Enable/disable SNMP queries for this user. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        """
        Security level for message authentication and encryption. Valid values: `no-auth-no-priv`, `auth-no-priv`, `auth-priv`.
        """
        return pulumi.get(self, "security_level")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        SNMP User Enable Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="trapStatus")
    def trap_status(self) -> Optional[str]:
        """
        Enable/disable traps for this SNMP user. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "trap_status")


@pulumi.output_type
class TimersDarrpTime(dict):
    def __init__(__self__, *,
                 time: Optional[str] = None):
        """
        :param str time: Time.
        """
        if time is not None:
            pulumi.set(__self__, "time", time)

    @property
    @pulumi.getter
    def time(self) -> Optional[str]:
        """
        Time.
        """
        return pulumi.get(self, "time")


@pulumi.output_type
class VapMacFilterList(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "macFilterPolicy":
            suggest = "mac_filter_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VapMacFilterList. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VapMacFilterList.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VapMacFilterList.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[int] = None,
                 mac: Optional[str] = None,
                 mac_filter_policy: Optional[str] = None):
        """
        :param int id: ID.
        :param str mac: MAC address.
        :param str mac_filter_policy: Deny or allow the client with this MAC address. Valid values: `allow`, `deny`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if mac_filter_policy is not None:
            pulumi.set(__self__, "mac_filter_policy", mac_filter_policy)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        """
        MAC address.
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter(name="macFilterPolicy")
    def mac_filter_policy(self) -> Optional[str]:
        """
        Deny or allow the client with this MAC address. Valid values: `allow`, `deny`.
        """
        return pulumi.get(self, "mac_filter_policy")


@pulumi.output_type
class VapMpskKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "concurrentClients":
            suggest = "concurrent_clients"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "mpskSchedules":
            suggest = "mpsk_schedules"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VapMpskKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VapMpskKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VapMpskKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 comment: Optional[str] = None,
                 concurrent_clients: Optional[str] = None,
                 key_name: Optional[str] = None,
                 mpsk_schedules: Optional[Sequence['outputs.VapMpskKeyMpskSchedule']] = None,
                 passphrase: Optional[str] = None):
        """
        :param str comment: Comment.
        :param str concurrent_clients: Number of clients that can connect using this pre-shared key.
        :param str key_name: Pre-shared key name.
        :param Sequence['VapMpskKeyMpskScheduleArgs'] mpsk_schedules: Firewall schedule for MPSK passphrase. The passphrase will be effective only when at least one schedule is valid. The structure of `mpsk_schedules` block is documented below.
        :param str passphrase: WPA Pre-shared key.
        """
        if comment is not None:
            pulumi.set(__self__, "comment", comment)
        if concurrent_clients is not None:
            pulumi.set(__self__, "concurrent_clients", concurrent_clients)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if mpsk_schedules is not None:
            pulumi.set(__self__, "mpsk_schedules", mpsk_schedules)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)

    @property
    @pulumi.getter
    def comment(self) -> Optional[str]:
        """
        Comment.
        """
        return pulumi.get(self, "comment")

    @property
    @pulumi.getter(name="concurrentClients")
    def concurrent_clients(self) -> Optional[str]:
        """
        Number of clients that can connect using this pre-shared key.
        """
        return pulumi.get(self, "concurrent_clients")

    @property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[str]:
        """
        Pre-shared key name.
        """
        return pulumi.get(self, "key_name")

    @property
    @pulumi.getter(name="mpskSchedules")
    def mpsk_schedules(self) -> Optional[Sequence['outputs.VapMpskKeyMpskSchedule']]:
        """
        Firewall schedule for MPSK passphrase. The passphrase will be effective only when at least one schedule is valid. The structure of `mpsk_schedules` block is documented below.
        """
        return pulumi.get(self, "mpsk_schedules")

    @property
    @pulumi.getter
    def passphrase(self) -> Optional[str]:
        """
        WPA Pre-shared key.
        """
        return pulumi.get(self, "passphrase")


@pulumi.output_type
class VapMpskKeyMpskSchedule(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Schedule name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Schedule name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VapPortalMessageOverrides(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDisclaimerPage":
            suggest = "auth_disclaimer_page"
        elif key == "authLoginFailedPage":
            suggest = "auth_login_failed_page"
        elif key == "authLoginPage":
            suggest = "auth_login_page"
        elif key == "authRejectPage":
            suggest = "auth_reject_page"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VapPortalMessageOverrides. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VapPortalMessageOverrides.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VapPortalMessageOverrides.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_disclaimer_page: Optional[str] = None,
                 auth_login_failed_page: Optional[str] = None,
                 auth_login_page: Optional[str] = None,
                 auth_reject_page: Optional[str] = None):
        """
        :param str auth_disclaimer_page: Override auth-disclaimer-page message with message from portal-message-overrides group.
        :param str auth_login_failed_page: Override auth-login-failed-page message with message from portal-message-overrides group.
        :param str auth_login_page: Override auth-login-page message with message from portal-message-overrides group.
        :param str auth_reject_page: Override auth-reject-page message with message from portal-message-overrides group.
        """
        if auth_disclaimer_page is not None:
            pulumi.set(__self__, "auth_disclaimer_page", auth_disclaimer_page)
        if auth_login_failed_page is not None:
            pulumi.set(__self__, "auth_login_failed_page", auth_login_failed_page)
        if auth_login_page is not None:
            pulumi.set(__self__, "auth_login_page", auth_login_page)
        if auth_reject_page is not None:
            pulumi.set(__self__, "auth_reject_page", auth_reject_page)

    @property
    @pulumi.getter(name="authDisclaimerPage")
    def auth_disclaimer_page(self) -> Optional[str]:
        """
        Override auth-disclaimer-page message with message from portal-message-overrides group.
        """
        return pulumi.get(self, "auth_disclaimer_page")

    @property
    @pulumi.getter(name="authLoginFailedPage")
    def auth_login_failed_page(self) -> Optional[str]:
        """
        Override auth-login-failed-page message with message from portal-message-overrides group.
        """
        return pulumi.get(self, "auth_login_failed_page")

    @property
    @pulumi.getter(name="authLoginPage")
    def auth_login_page(self) -> Optional[str]:
        """
        Override auth-login-page message with message from portal-message-overrides group.
        """
        return pulumi.get(self, "auth_login_page")

    @property
    @pulumi.getter(name="authRejectPage")
    def auth_reject_page(self) -> Optional[str]:
        """
        Override auth-reject-page message with message from portal-message-overrides group.
        """
        return pulumi.get(self, "auth_reject_page")


@pulumi.output_type
class VapRadiusMacAuthUsergroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: User group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        User group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VapSelectedUsergroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: User group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        User group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VapUsergroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: User group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        User group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VapVlanName(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanId":
            suggest = "vlan_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VapVlanName. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VapVlanName.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VapVlanName.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 vlan_id: Optional[int] = None):
        """
        :param str name: VLAN name.
        :param int vlan_id: VLAN ID.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if vlan_id is not None:
            pulumi.set(__self__, "vlan_id", vlan_id)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        VLAN name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="vlanId")
    def vlan_id(self) -> Optional[int]:
        """
        VLAN ID.
        """
        return pulumi.get(self, "vlan_id")


@pulumi.output_type
class VapVlanPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wtpGroup":
            suggest = "wtp_group"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VapVlanPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VapVlanPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VapVlanPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: Optional[int] = None,
                 wtp_group: Optional[str] = None):
        """
        :param int id: ID.
        :param str wtp_group: WTP group name.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if wtp_group is not None:
            pulumi.set(__self__, "wtp_group", wtp_group)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="wtpGroup")
    def wtp_group(self) -> Optional[str]:
        """
        WTP group name.
        """
        return pulumi.get(self, "wtp_group")


@pulumi.output_type
class VapgroupVap(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: vap name
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        vap name
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WidsprofileApBgscanDisableSchedule(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Schedule name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Schedule name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WidsprofileApScanChannelList2g5g(dict):
    def __init__(__self__, *,
                 chan: Optional[str] = None):
        """
        :param str chan: Channel 6g number.
        """
        if chan is not None:
            pulumi.set(__self__, "chan", chan)

    @property
    @pulumi.getter
    def chan(self) -> Optional[str]:
        """
        Channel 6g number.
        """
        return pulumi.get(self, "chan")


@pulumi.output_type
class WidsprofileApScanChannelList6g(dict):
    def __init__(__self__, *,
                 chan: Optional[str] = None):
        """
        :param str chan: Channel 6g number.
        """
        if chan is not None:
            pulumi.set(__self__, "chan", chan)

    @property
    @pulumi.getter
    def chan(self) -> Optional[str]:
        """
        Channel 6g number.
        """
        return pulumi.get(self, "chan")


@pulumi.output_type
class WtpLan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "port1Mode":
            suggest = "port1_mode"
        elif key == "port1Ssid":
            suggest = "port1_ssid"
        elif key == "port2Mode":
            suggest = "port2_mode"
        elif key == "port2Ssid":
            suggest = "port2_ssid"
        elif key == "port3Mode":
            suggest = "port3_mode"
        elif key == "port3Ssid":
            suggest = "port3_ssid"
        elif key == "port4Mode":
            suggest = "port4_mode"
        elif key == "port4Ssid":
            suggest = "port4_ssid"
        elif key == "port5Mode":
            suggest = "port5_mode"
        elif key == "port5Ssid":
            suggest = "port5_ssid"
        elif key == "port6Mode":
            suggest = "port6_mode"
        elif key == "port6Ssid":
            suggest = "port6_ssid"
        elif key == "port7Mode":
            suggest = "port7_mode"
        elif key == "port7Ssid":
            suggest = "port7_ssid"
        elif key == "port8Mode":
            suggest = "port8_mode"
        elif key == "port8Ssid":
            suggest = "port8_ssid"
        elif key == "portEslMode":
            suggest = "port_esl_mode"
        elif key == "portEslSsid":
            suggest = "port_esl_ssid"
        elif key == "portMode":
            suggest = "port_mode"
        elif key == "portSsid":
            suggest = "port_ssid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpLan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpLan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpLan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port1_mode: Optional[str] = None,
                 port1_ssid: Optional[str] = None,
                 port2_mode: Optional[str] = None,
                 port2_ssid: Optional[str] = None,
                 port3_mode: Optional[str] = None,
                 port3_ssid: Optional[str] = None,
                 port4_mode: Optional[str] = None,
                 port4_ssid: Optional[str] = None,
                 port5_mode: Optional[str] = None,
                 port5_ssid: Optional[str] = None,
                 port6_mode: Optional[str] = None,
                 port6_ssid: Optional[str] = None,
                 port7_mode: Optional[str] = None,
                 port7_ssid: Optional[str] = None,
                 port8_mode: Optional[str] = None,
                 port8_ssid: Optional[str] = None,
                 port_esl_mode: Optional[str] = None,
                 port_esl_ssid: Optional[str] = None,
                 port_mode: Optional[str] = None,
                 port_ssid: Optional[str] = None):
        """
        :param str port1_mode: LAN port 1 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port1_ssid: Bridge LAN port 1 to SSID.
        :param str port2_mode: LAN port 2 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port2_ssid: Bridge LAN port 2 to SSID.
        :param str port3_mode: LAN port 3 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port3_ssid: Bridge LAN port 3 to SSID.
        :param str port4_mode: LAN port 4 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port4_ssid: Bridge LAN port 4 to SSID.
        :param str port5_mode: LAN port 5 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port5_ssid: Bridge LAN port 5 to SSID.
        :param str port6_mode: LAN port 6 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port6_ssid: Bridge LAN port 6 to SSID.
        :param str port7_mode: LAN port 7 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port7_ssid: Bridge LAN port 7 to SSID.
        :param str port8_mode: LAN port 8 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port8_ssid: Bridge LAN port 8 to SSID.
        :param str port_esl_mode: ESL port mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port_esl_ssid: Bridge ESL port to SSID.
               
               The `radio_1` block supports:
        :param str port_mode: LAN port mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port_ssid: Bridge LAN port to SSID.
        """
        if port1_mode is not None:
            pulumi.set(__self__, "port1_mode", port1_mode)
        if port1_ssid is not None:
            pulumi.set(__self__, "port1_ssid", port1_ssid)
        if port2_mode is not None:
            pulumi.set(__self__, "port2_mode", port2_mode)
        if port2_ssid is not None:
            pulumi.set(__self__, "port2_ssid", port2_ssid)
        if port3_mode is not None:
            pulumi.set(__self__, "port3_mode", port3_mode)
        if port3_ssid is not None:
            pulumi.set(__self__, "port3_ssid", port3_ssid)
        if port4_mode is not None:
            pulumi.set(__self__, "port4_mode", port4_mode)
        if port4_ssid is not None:
            pulumi.set(__self__, "port4_ssid", port4_ssid)
        if port5_mode is not None:
            pulumi.set(__self__, "port5_mode", port5_mode)
        if port5_ssid is not None:
            pulumi.set(__self__, "port5_ssid", port5_ssid)
        if port6_mode is not None:
            pulumi.set(__self__, "port6_mode", port6_mode)
        if port6_ssid is not None:
            pulumi.set(__self__, "port6_ssid", port6_ssid)
        if port7_mode is not None:
            pulumi.set(__self__, "port7_mode", port7_mode)
        if port7_ssid is not None:
            pulumi.set(__self__, "port7_ssid", port7_ssid)
        if port8_mode is not None:
            pulumi.set(__self__, "port8_mode", port8_mode)
        if port8_ssid is not None:
            pulumi.set(__self__, "port8_ssid", port8_ssid)
        if port_esl_mode is not None:
            pulumi.set(__self__, "port_esl_mode", port_esl_mode)
        if port_esl_ssid is not None:
            pulumi.set(__self__, "port_esl_ssid", port_esl_ssid)
        if port_mode is not None:
            pulumi.set(__self__, "port_mode", port_mode)
        if port_ssid is not None:
            pulumi.set(__self__, "port_ssid", port_ssid)

    @property
    @pulumi.getter(name="port1Mode")
    def port1_mode(self) -> Optional[str]:
        """
        LAN port 1 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port1_mode")

    @property
    @pulumi.getter(name="port1Ssid")
    def port1_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 1 to SSID.
        """
        return pulumi.get(self, "port1_ssid")

    @property
    @pulumi.getter(name="port2Mode")
    def port2_mode(self) -> Optional[str]:
        """
        LAN port 2 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port2_mode")

    @property
    @pulumi.getter(name="port2Ssid")
    def port2_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 2 to SSID.
        """
        return pulumi.get(self, "port2_ssid")

    @property
    @pulumi.getter(name="port3Mode")
    def port3_mode(self) -> Optional[str]:
        """
        LAN port 3 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port3_mode")

    @property
    @pulumi.getter(name="port3Ssid")
    def port3_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 3 to SSID.
        """
        return pulumi.get(self, "port3_ssid")

    @property
    @pulumi.getter(name="port4Mode")
    def port4_mode(self) -> Optional[str]:
        """
        LAN port 4 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port4_mode")

    @property
    @pulumi.getter(name="port4Ssid")
    def port4_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 4 to SSID.
        """
        return pulumi.get(self, "port4_ssid")

    @property
    @pulumi.getter(name="port5Mode")
    def port5_mode(self) -> Optional[str]:
        """
        LAN port 5 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port5_mode")

    @property
    @pulumi.getter(name="port5Ssid")
    def port5_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 5 to SSID.
        """
        return pulumi.get(self, "port5_ssid")

    @property
    @pulumi.getter(name="port6Mode")
    def port6_mode(self) -> Optional[str]:
        """
        LAN port 6 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port6_mode")

    @property
    @pulumi.getter(name="port6Ssid")
    def port6_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 6 to SSID.
        """
        return pulumi.get(self, "port6_ssid")

    @property
    @pulumi.getter(name="port7Mode")
    def port7_mode(self) -> Optional[str]:
        """
        LAN port 7 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port7_mode")

    @property
    @pulumi.getter(name="port7Ssid")
    def port7_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 7 to SSID.
        """
        return pulumi.get(self, "port7_ssid")

    @property
    @pulumi.getter(name="port8Mode")
    def port8_mode(self) -> Optional[str]:
        """
        LAN port 8 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port8_mode")

    @property
    @pulumi.getter(name="port8Ssid")
    def port8_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 8 to SSID.
        """
        return pulumi.get(self, "port8_ssid")

    @property
    @pulumi.getter(name="portEslMode")
    def port_esl_mode(self) -> Optional[str]:
        """
        ESL port mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port_esl_mode")

    @property
    @pulumi.getter(name="portEslSsid")
    def port_esl_ssid(self) -> Optional[str]:
        """
        Bridge ESL port to SSID.

        The `radio_1` block supports:
        """
        return pulumi.get(self, "port_esl_ssid")

    @property
    @pulumi.getter(name="portMode")
    def port_mode(self) -> Optional[str]:
        """
        LAN port mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port_mode")

    @property
    @pulumi.getter(name="portSsid")
    def port_ssid(self) -> Optional[str]:
        """
        Bridge LAN port to SSID.
        """
        return pulumi.get(self, "port_ssid")


@pulumi.output_type
class WtpRadio1(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoPowerHigh":
            suggest = "auto_power_high"
        elif key == "autoPowerLevel":
            suggest = "auto_power_level"
        elif key == "autoPowerLow":
            suggest = "auto_power_low"
        elif key == "autoPowerTarget":
            suggest = "auto_power_target"
        elif key == "drmaManualMode":
            suggest = "drma_manual_mode"
        elif key == "overrideAnalysis":
            suggest = "override_analysis"
        elif key == "overrideBand":
            suggest = "override_band"
        elif key == "overrideChannel":
            suggest = "override_channel"
        elif key == "overrideTxpower":
            suggest = "override_txpower"
        elif key == "overrideVaps":
            suggest = "override_vaps"
        elif key == "powerLevel":
            suggest = "power_level"
        elif key == "powerMode":
            suggest = "power_mode"
        elif key == "powerValue":
            suggest = "power_value"
        elif key == "radioId":
            suggest = "radio_id"
        elif key == "spectrumAnalysis":
            suggest = "spectrum_analysis"
        elif key == "vapAll":
            suggest = "vap_all"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpRadio1. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpRadio1.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpRadio1.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_power_high: Optional[int] = None,
                 auto_power_level: Optional[str] = None,
                 auto_power_low: Optional[int] = None,
                 auto_power_target: Optional[str] = None,
                 band: Optional[str] = None,
                 channels: Optional[Sequence['outputs.WtpRadio1Channel']] = None,
                 drma_manual_mode: Optional[str] = None,
                 override_analysis: Optional[str] = None,
                 override_band: Optional[str] = None,
                 override_channel: Optional[str] = None,
                 override_txpower: Optional[str] = None,
                 override_vaps: Optional[str] = None,
                 power_level: Optional[int] = None,
                 power_mode: Optional[str] = None,
                 power_value: Optional[int] = None,
                 radio_id: Optional[int] = None,
                 spectrum_analysis: Optional[str] = None,
                 vap_all: Optional[str] = None,
                 vaps: Optional[Sequence['outputs.WtpRadio1Vap']] = None):
        """
        :param int auto_power_high: The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_level: Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        :param int auto_power_low: The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_target: The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        :param str band: WiFi band that Radio 4 operates on.
        :param Sequence['WtpRadio1ChannelArgs'] channels: Selected list of wireless radio channels. The structure of `channel` block is documented below.
        :param str drma_manual_mode: Radio mode to be used for DRMA manual mode (default = ncf). Valid values: `ap`, `monitor`, `ncf`, `ncf-peek`.
        :param str override_analysis: Enable to override the WTP profile spectrum analysis configuration. Valid values: `enable`, `disable`.
        :param str override_band: Enable to override the WTP profile band setting. Valid values: `enable`, `disable`.
        :param str override_channel: Enable to override WTP profile channel settings. Valid values: `enable`, `disable`.
        :param str override_txpower: Enable to override the WTP profile power level configuration. Valid values: `enable`, `disable`.
        :param str override_vaps: Enable to override WTP profile Virtual Access Point (VAP) settings. Valid values: `enable`, `disable`.
        :param int power_level: Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        :param str power_mode: Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        :param int power_value: Radio EIRP power in dBm (1 - 33, default = 27).
        :param int radio_id: radio-id
        :param str spectrum_analysis: Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        :param str vap_all: Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        :param Sequence['WtpRadio1VapArgs'] vaps: Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        """
        if auto_power_high is not None:
            pulumi.set(__self__, "auto_power_high", auto_power_high)
        if auto_power_level is not None:
            pulumi.set(__self__, "auto_power_level", auto_power_level)
        if auto_power_low is not None:
            pulumi.set(__self__, "auto_power_low", auto_power_low)
        if auto_power_target is not None:
            pulumi.set(__self__, "auto_power_target", auto_power_target)
        if band is not None:
            pulumi.set(__self__, "band", band)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if drma_manual_mode is not None:
            pulumi.set(__self__, "drma_manual_mode", drma_manual_mode)
        if override_analysis is not None:
            pulumi.set(__self__, "override_analysis", override_analysis)
        if override_band is not None:
            pulumi.set(__self__, "override_band", override_band)
        if override_channel is not None:
            pulumi.set(__self__, "override_channel", override_channel)
        if override_txpower is not None:
            pulumi.set(__self__, "override_txpower", override_txpower)
        if override_vaps is not None:
            pulumi.set(__self__, "override_vaps", override_vaps)
        if power_level is not None:
            pulumi.set(__self__, "power_level", power_level)
        if power_mode is not None:
            pulumi.set(__self__, "power_mode", power_mode)
        if power_value is not None:
            pulumi.set(__self__, "power_value", power_value)
        if radio_id is not None:
            pulumi.set(__self__, "radio_id", radio_id)
        if spectrum_analysis is not None:
            pulumi.set(__self__, "spectrum_analysis", spectrum_analysis)
        if vap_all is not None:
            pulumi.set(__self__, "vap_all", vap_all)
        if vaps is not None:
            pulumi.set(__self__, "vaps", vaps)

    @property
    @pulumi.getter(name="autoPowerHigh")
    def auto_power_high(self) -> Optional[int]:
        """
        The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_high")

    @property
    @pulumi.getter(name="autoPowerLevel")
    def auto_power_level(self) -> Optional[str]:
        """
        Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "auto_power_level")

    @property
    @pulumi.getter(name="autoPowerLow")
    def auto_power_low(self) -> Optional[int]:
        """
        The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_low")

    @property
    @pulumi.getter(name="autoPowerTarget")
    def auto_power_target(self) -> Optional[str]:
        """
        The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        """
        return pulumi.get(self, "auto_power_target")

    @property
    @pulumi.getter
    def band(self) -> Optional[str]:
        """
        WiFi band that Radio 4 operates on.
        """
        return pulumi.get(self, "band")

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.WtpRadio1Channel']]:
        """
        Selected list of wireless radio channels. The structure of `channel` block is documented below.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter(name="drmaManualMode")
    def drma_manual_mode(self) -> Optional[str]:
        """
        Radio mode to be used for DRMA manual mode (default = ncf). Valid values: `ap`, `monitor`, `ncf`, `ncf-peek`.
        """
        return pulumi.get(self, "drma_manual_mode")

    @property
    @pulumi.getter(name="overrideAnalysis")
    def override_analysis(self) -> Optional[str]:
        """
        Enable to override the WTP profile spectrum analysis configuration. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_analysis")

    @property
    @pulumi.getter(name="overrideBand")
    def override_band(self) -> Optional[str]:
        """
        Enable to override the WTP profile band setting. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_band")

    @property
    @pulumi.getter(name="overrideChannel")
    def override_channel(self) -> Optional[str]:
        """
        Enable to override WTP profile channel settings. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_channel")

    @property
    @pulumi.getter(name="overrideTxpower")
    def override_txpower(self) -> Optional[str]:
        """
        Enable to override the WTP profile power level configuration. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_txpower")

    @property
    @pulumi.getter(name="overrideVaps")
    def override_vaps(self) -> Optional[str]:
        """
        Enable to override WTP profile Virtual Access Point (VAP) settings. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_vaps")

    @property
    @pulumi.getter(name="powerLevel")
    def power_level(self) -> Optional[int]:
        """
        Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        """
        return pulumi.get(self, "power_level")

    @property
    @pulumi.getter(name="powerMode")
    def power_mode(self) -> Optional[str]:
        """
        Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        """
        return pulumi.get(self, "power_mode")

    @property
    @pulumi.getter(name="powerValue")
    def power_value(self) -> Optional[int]:
        """
        Radio EIRP power in dBm (1 - 33, default = 27).
        """
        return pulumi.get(self, "power_value")

    @property
    @pulumi.getter(name="radioId")
    def radio_id(self) -> Optional[int]:
        """
        radio-id
        """
        return pulumi.get(self, "radio_id")

    @property
    @pulumi.getter(name="spectrumAnalysis")
    def spectrum_analysis(self) -> Optional[str]:
        """
        Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        """
        return pulumi.get(self, "spectrum_analysis")

    @property
    @pulumi.getter(name="vapAll")
    def vap_all(self) -> Optional[str]:
        """
        Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        """
        return pulumi.get(self, "vap_all")

    @property
    @pulumi.getter
    def vaps(self) -> Optional[Sequence['outputs.WtpRadio1Vap']]:
        """
        Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        """
        return pulumi.get(self, "vaps")


@pulumi.output_type
class WtpRadio1Channel(dict):
    def __init__(__self__, *,
                 chan: Optional[str] = None):
        """
        :param str chan: Channel number.
        """
        if chan is not None:
            pulumi.set(__self__, "chan", chan)

    @property
    @pulumi.getter
    def chan(self) -> Optional[str]:
        """
        Channel number.
        """
        return pulumi.get(self, "chan")


@pulumi.output_type
class WtpRadio1Vap(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Virtual Access Point (VAP) name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Virtual Access Point (VAP) name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WtpRadio2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoPowerHigh":
            suggest = "auto_power_high"
        elif key == "autoPowerLevel":
            suggest = "auto_power_level"
        elif key == "autoPowerLow":
            suggest = "auto_power_low"
        elif key == "autoPowerTarget":
            suggest = "auto_power_target"
        elif key == "drmaManualMode":
            suggest = "drma_manual_mode"
        elif key == "overrideAnalysis":
            suggest = "override_analysis"
        elif key == "overrideBand":
            suggest = "override_band"
        elif key == "overrideChannel":
            suggest = "override_channel"
        elif key == "overrideTxpower":
            suggest = "override_txpower"
        elif key == "overrideVaps":
            suggest = "override_vaps"
        elif key == "powerLevel":
            suggest = "power_level"
        elif key == "powerMode":
            suggest = "power_mode"
        elif key == "powerValue":
            suggest = "power_value"
        elif key == "radioId":
            suggest = "radio_id"
        elif key == "spectrumAnalysis":
            suggest = "spectrum_analysis"
        elif key == "vapAll":
            suggest = "vap_all"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpRadio2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpRadio2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpRadio2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_power_high: Optional[int] = None,
                 auto_power_level: Optional[str] = None,
                 auto_power_low: Optional[int] = None,
                 auto_power_target: Optional[str] = None,
                 band: Optional[str] = None,
                 channels: Optional[Sequence['outputs.WtpRadio2Channel']] = None,
                 drma_manual_mode: Optional[str] = None,
                 override_analysis: Optional[str] = None,
                 override_band: Optional[str] = None,
                 override_channel: Optional[str] = None,
                 override_txpower: Optional[str] = None,
                 override_vaps: Optional[str] = None,
                 power_level: Optional[int] = None,
                 power_mode: Optional[str] = None,
                 power_value: Optional[int] = None,
                 radio_id: Optional[int] = None,
                 spectrum_analysis: Optional[str] = None,
                 vap_all: Optional[str] = None,
                 vaps: Optional[Sequence['outputs.WtpRadio2Vap']] = None):
        """
        :param int auto_power_high: The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_level: Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        :param int auto_power_low: The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_target: The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        :param str band: WiFi band that Radio 4 operates on.
        :param Sequence['WtpRadio2ChannelArgs'] channels: Selected list of wireless radio channels. The structure of `channel` block is documented below.
        :param str drma_manual_mode: Radio mode to be used for DRMA manual mode (default = ncf). Valid values: `ap`, `monitor`, `ncf`, `ncf-peek`.
        :param str override_analysis: Enable to override the WTP profile spectrum analysis configuration. Valid values: `enable`, `disable`.
        :param str override_band: Enable to override the WTP profile band setting. Valid values: `enable`, `disable`.
        :param str override_channel: Enable to override WTP profile channel settings. Valid values: `enable`, `disable`.
        :param str override_txpower: Enable to override the WTP profile power level configuration. Valid values: `enable`, `disable`.
        :param str override_vaps: Enable to override WTP profile Virtual Access Point (VAP) settings. Valid values: `enable`, `disable`.
        :param int power_level: Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        :param str power_mode: Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        :param int power_value: Radio EIRP power in dBm (1 - 33, default = 27).
        :param int radio_id: radio-id
        :param str spectrum_analysis: Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        :param str vap_all: Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        :param Sequence['WtpRadio2VapArgs'] vaps: Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        """
        if auto_power_high is not None:
            pulumi.set(__self__, "auto_power_high", auto_power_high)
        if auto_power_level is not None:
            pulumi.set(__self__, "auto_power_level", auto_power_level)
        if auto_power_low is not None:
            pulumi.set(__self__, "auto_power_low", auto_power_low)
        if auto_power_target is not None:
            pulumi.set(__self__, "auto_power_target", auto_power_target)
        if band is not None:
            pulumi.set(__self__, "band", band)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if drma_manual_mode is not None:
            pulumi.set(__self__, "drma_manual_mode", drma_manual_mode)
        if override_analysis is not None:
            pulumi.set(__self__, "override_analysis", override_analysis)
        if override_band is not None:
            pulumi.set(__self__, "override_band", override_band)
        if override_channel is not None:
            pulumi.set(__self__, "override_channel", override_channel)
        if override_txpower is not None:
            pulumi.set(__self__, "override_txpower", override_txpower)
        if override_vaps is not None:
            pulumi.set(__self__, "override_vaps", override_vaps)
        if power_level is not None:
            pulumi.set(__self__, "power_level", power_level)
        if power_mode is not None:
            pulumi.set(__self__, "power_mode", power_mode)
        if power_value is not None:
            pulumi.set(__self__, "power_value", power_value)
        if radio_id is not None:
            pulumi.set(__self__, "radio_id", radio_id)
        if spectrum_analysis is not None:
            pulumi.set(__self__, "spectrum_analysis", spectrum_analysis)
        if vap_all is not None:
            pulumi.set(__self__, "vap_all", vap_all)
        if vaps is not None:
            pulumi.set(__self__, "vaps", vaps)

    @property
    @pulumi.getter(name="autoPowerHigh")
    def auto_power_high(self) -> Optional[int]:
        """
        The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_high")

    @property
    @pulumi.getter(name="autoPowerLevel")
    def auto_power_level(self) -> Optional[str]:
        """
        Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "auto_power_level")

    @property
    @pulumi.getter(name="autoPowerLow")
    def auto_power_low(self) -> Optional[int]:
        """
        The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_low")

    @property
    @pulumi.getter(name="autoPowerTarget")
    def auto_power_target(self) -> Optional[str]:
        """
        The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        """
        return pulumi.get(self, "auto_power_target")

    @property
    @pulumi.getter
    def band(self) -> Optional[str]:
        """
        WiFi band that Radio 4 operates on.
        """
        return pulumi.get(self, "band")

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.WtpRadio2Channel']]:
        """
        Selected list of wireless radio channels. The structure of `channel` block is documented below.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter(name="drmaManualMode")
    def drma_manual_mode(self) -> Optional[str]:
        """
        Radio mode to be used for DRMA manual mode (default = ncf). Valid values: `ap`, `monitor`, `ncf`, `ncf-peek`.
        """
        return pulumi.get(self, "drma_manual_mode")

    @property
    @pulumi.getter(name="overrideAnalysis")
    def override_analysis(self) -> Optional[str]:
        """
        Enable to override the WTP profile spectrum analysis configuration. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_analysis")

    @property
    @pulumi.getter(name="overrideBand")
    def override_band(self) -> Optional[str]:
        """
        Enable to override the WTP profile band setting. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_band")

    @property
    @pulumi.getter(name="overrideChannel")
    def override_channel(self) -> Optional[str]:
        """
        Enable to override WTP profile channel settings. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_channel")

    @property
    @pulumi.getter(name="overrideTxpower")
    def override_txpower(self) -> Optional[str]:
        """
        Enable to override the WTP profile power level configuration. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_txpower")

    @property
    @pulumi.getter(name="overrideVaps")
    def override_vaps(self) -> Optional[str]:
        """
        Enable to override WTP profile Virtual Access Point (VAP) settings. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_vaps")

    @property
    @pulumi.getter(name="powerLevel")
    def power_level(self) -> Optional[int]:
        """
        Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        """
        return pulumi.get(self, "power_level")

    @property
    @pulumi.getter(name="powerMode")
    def power_mode(self) -> Optional[str]:
        """
        Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        """
        return pulumi.get(self, "power_mode")

    @property
    @pulumi.getter(name="powerValue")
    def power_value(self) -> Optional[int]:
        """
        Radio EIRP power in dBm (1 - 33, default = 27).
        """
        return pulumi.get(self, "power_value")

    @property
    @pulumi.getter(name="radioId")
    def radio_id(self) -> Optional[int]:
        """
        radio-id
        """
        return pulumi.get(self, "radio_id")

    @property
    @pulumi.getter(name="spectrumAnalysis")
    def spectrum_analysis(self) -> Optional[str]:
        """
        Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        """
        return pulumi.get(self, "spectrum_analysis")

    @property
    @pulumi.getter(name="vapAll")
    def vap_all(self) -> Optional[str]:
        """
        Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        """
        return pulumi.get(self, "vap_all")

    @property
    @pulumi.getter
    def vaps(self) -> Optional[Sequence['outputs.WtpRadio2Vap']]:
        """
        Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        """
        return pulumi.get(self, "vaps")


@pulumi.output_type
class WtpRadio2Channel(dict):
    def __init__(__self__, *,
                 chan: Optional[str] = None):
        """
        :param str chan: Channel number.
        """
        if chan is not None:
            pulumi.set(__self__, "chan", chan)

    @property
    @pulumi.getter
    def chan(self) -> Optional[str]:
        """
        Channel number.
        """
        return pulumi.get(self, "chan")


@pulumi.output_type
class WtpRadio2Vap(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Virtual Access Point (VAP) name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Virtual Access Point (VAP) name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WtpRadio3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoPowerHigh":
            suggest = "auto_power_high"
        elif key == "autoPowerLevel":
            suggest = "auto_power_level"
        elif key == "autoPowerLow":
            suggest = "auto_power_low"
        elif key == "autoPowerTarget":
            suggest = "auto_power_target"
        elif key == "drmaManualMode":
            suggest = "drma_manual_mode"
        elif key == "overrideAnalysis":
            suggest = "override_analysis"
        elif key == "overrideBand":
            suggest = "override_band"
        elif key == "overrideChannel":
            suggest = "override_channel"
        elif key == "overrideTxpower":
            suggest = "override_txpower"
        elif key == "overrideVaps":
            suggest = "override_vaps"
        elif key == "powerLevel":
            suggest = "power_level"
        elif key == "powerMode":
            suggest = "power_mode"
        elif key == "powerValue":
            suggest = "power_value"
        elif key == "spectrumAnalysis":
            suggest = "spectrum_analysis"
        elif key == "vapAll":
            suggest = "vap_all"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpRadio3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpRadio3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpRadio3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_power_high: Optional[int] = None,
                 auto_power_level: Optional[str] = None,
                 auto_power_low: Optional[int] = None,
                 auto_power_target: Optional[str] = None,
                 band: Optional[str] = None,
                 channels: Optional[Sequence['outputs.WtpRadio3Channel']] = None,
                 drma_manual_mode: Optional[str] = None,
                 override_analysis: Optional[str] = None,
                 override_band: Optional[str] = None,
                 override_channel: Optional[str] = None,
                 override_txpower: Optional[str] = None,
                 override_vaps: Optional[str] = None,
                 power_level: Optional[int] = None,
                 power_mode: Optional[str] = None,
                 power_value: Optional[int] = None,
                 spectrum_analysis: Optional[str] = None,
                 vap_all: Optional[str] = None,
                 vaps: Optional[Sequence['outputs.WtpRadio3Vap']] = None):
        """
        :param int auto_power_high: The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_level: Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        :param int auto_power_low: The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_target: The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        :param str band: WiFi band that Radio 4 operates on.
        :param Sequence['WtpRadio3ChannelArgs'] channels: Selected list of wireless radio channels. The structure of `channel` block is documented below.
        :param str drma_manual_mode: Radio mode to be used for DRMA manual mode (default = ncf). Valid values: `ap`, `monitor`, `ncf`, `ncf-peek`.
        :param str override_analysis: Enable to override the WTP profile spectrum analysis configuration. Valid values: `enable`, `disable`.
        :param str override_band: Enable to override the WTP profile band setting. Valid values: `enable`, `disable`.
        :param str override_channel: Enable to override WTP profile channel settings. Valid values: `enable`, `disable`.
        :param str override_txpower: Enable to override the WTP profile power level configuration. Valid values: `enable`, `disable`.
        :param str override_vaps: Enable to override WTP profile Virtual Access Point (VAP) settings. Valid values: `enable`, `disable`.
        :param int power_level: Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        :param str power_mode: Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        :param int power_value: Radio EIRP power in dBm (1 - 33, default = 27).
        :param str spectrum_analysis: Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        :param str vap_all: Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        :param Sequence['WtpRadio3VapArgs'] vaps: Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        """
        if auto_power_high is not None:
            pulumi.set(__self__, "auto_power_high", auto_power_high)
        if auto_power_level is not None:
            pulumi.set(__self__, "auto_power_level", auto_power_level)
        if auto_power_low is not None:
            pulumi.set(__self__, "auto_power_low", auto_power_low)
        if auto_power_target is not None:
            pulumi.set(__self__, "auto_power_target", auto_power_target)
        if band is not None:
            pulumi.set(__self__, "band", band)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if drma_manual_mode is not None:
            pulumi.set(__self__, "drma_manual_mode", drma_manual_mode)
        if override_analysis is not None:
            pulumi.set(__self__, "override_analysis", override_analysis)
        if override_band is not None:
            pulumi.set(__self__, "override_band", override_band)
        if override_channel is not None:
            pulumi.set(__self__, "override_channel", override_channel)
        if override_txpower is not None:
            pulumi.set(__self__, "override_txpower", override_txpower)
        if override_vaps is not None:
            pulumi.set(__self__, "override_vaps", override_vaps)
        if power_level is not None:
            pulumi.set(__self__, "power_level", power_level)
        if power_mode is not None:
            pulumi.set(__self__, "power_mode", power_mode)
        if power_value is not None:
            pulumi.set(__self__, "power_value", power_value)
        if spectrum_analysis is not None:
            pulumi.set(__self__, "spectrum_analysis", spectrum_analysis)
        if vap_all is not None:
            pulumi.set(__self__, "vap_all", vap_all)
        if vaps is not None:
            pulumi.set(__self__, "vaps", vaps)

    @property
    @pulumi.getter(name="autoPowerHigh")
    def auto_power_high(self) -> Optional[int]:
        """
        The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_high")

    @property
    @pulumi.getter(name="autoPowerLevel")
    def auto_power_level(self) -> Optional[str]:
        """
        Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "auto_power_level")

    @property
    @pulumi.getter(name="autoPowerLow")
    def auto_power_low(self) -> Optional[int]:
        """
        The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_low")

    @property
    @pulumi.getter(name="autoPowerTarget")
    def auto_power_target(self) -> Optional[str]:
        """
        The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        """
        return pulumi.get(self, "auto_power_target")

    @property
    @pulumi.getter
    def band(self) -> Optional[str]:
        """
        WiFi band that Radio 4 operates on.
        """
        return pulumi.get(self, "band")

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.WtpRadio3Channel']]:
        """
        Selected list of wireless radio channels. The structure of `channel` block is documented below.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter(name="drmaManualMode")
    def drma_manual_mode(self) -> Optional[str]:
        """
        Radio mode to be used for DRMA manual mode (default = ncf). Valid values: `ap`, `monitor`, `ncf`, `ncf-peek`.
        """
        return pulumi.get(self, "drma_manual_mode")

    @property
    @pulumi.getter(name="overrideAnalysis")
    def override_analysis(self) -> Optional[str]:
        """
        Enable to override the WTP profile spectrum analysis configuration. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_analysis")

    @property
    @pulumi.getter(name="overrideBand")
    def override_band(self) -> Optional[str]:
        """
        Enable to override the WTP profile band setting. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_band")

    @property
    @pulumi.getter(name="overrideChannel")
    def override_channel(self) -> Optional[str]:
        """
        Enable to override WTP profile channel settings. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_channel")

    @property
    @pulumi.getter(name="overrideTxpower")
    def override_txpower(self) -> Optional[str]:
        """
        Enable to override the WTP profile power level configuration. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_txpower")

    @property
    @pulumi.getter(name="overrideVaps")
    def override_vaps(self) -> Optional[str]:
        """
        Enable to override WTP profile Virtual Access Point (VAP) settings. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_vaps")

    @property
    @pulumi.getter(name="powerLevel")
    def power_level(self) -> Optional[int]:
        """
        Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        """
        return pulumi.get(self, "power_level")

    @property
    @pulumi.getter(name="powerMode")
    def power_mode(self) -> Optional[str]:
        """
        Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        """
        return pulumi.get(self, "power_mode")

    @property
    @pulumi.getter(name="powerValue")
    def power_value(self) -> Optional[int]:
        """
        Radio EIRP power in dBm (1 - 33, default = 27).
        """
        return pulumi.get(self, "power_value")

    @property
    @pulumi.getter(name="spectrumAnalysis")
    def spectrum_analysis(self) -> Optional[str]:
        """
        Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        """
        return pulumi.get(self, "spectrum_analysis")

    @property
    @pulumi.getter(name="vapAll")
    def vap_all(self) -> Optional[str]:
        """
        Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        """
        return pulumi.get(self, "vap_all")

    @property
    @pulumi.getter
    def vaps(self) -> Optional[Sequence['outputs.WtpRadio3Vap']]:
        """
        Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        """
        return pulumi.get(self, "vaps")


@pulumi.output_type
class WtpRadio3Channel(dict):
    def __init__(__self__, *,
                 chan: Optional[str] = None):
        """
        :param str chan: Channel number.
        """
        if chan is not None:
            pulumi.set(__self__, "chan", chan)

    @property
    @pulumi.getter
    def chan(self) -> Optional[str]:
        """
        Channel number.
        """
        return pulumi.get(self, "chan")


@pulumi.output_type
class WtpRadio3Vap(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Virtual Access Point (VAP) name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Virtual Access Point (VAP) name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WtpRadio4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoPowerHigh":
            suggest = "auto_power_high"
        elif key == "autoPowerLevel":
            suggest = "auto_power_level"
        elif key == "autoPowerLow":
            suggest = "auto_power_low"
        elif key == "autoPowerTarget":
            suggest = "auto_power_target"
        elif key == "drmaManualMode":
            suggest = "drma_manual_mode"
        elif key == "overrideAnalysis":
            suggest = "override_analysis"
        elif key == "overrideBand":
            suggest = "override_band"
        elif key == "overrideChannel":
            suggest = "override_channel"
        elif key == "overrideTxpower":
            suggest = "override_txpower"
        elif key == "overrideVaps":
            suggest = "override_vaps"
        elif key == "powerLevel":
            suggest = "power_level"
        elif key == "powerMode":
            suggest = "power_mode"
        elif key == "powerValue":
            suggest = "power_value"
        elif key == "spectrumAnalysis":
            suggest = "spectrum_analysis"
        elif key == "vapAll":
            suggest = "vap_all"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpRadio4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpRadio4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpRadio4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_power_high: Optional[int] = None,
                 auto_power_level: Optional[str] = None,
                 auto_power_low: Optional[int] = None,
                 auto_power_target: Optional[str] = None,
                 band: Optional[str] = None,
                 channels: Optional[Sequence['outputs.WtpRadio4Channel']] = None,
                 drma_manual_mode: Optional[str] = None,
                 override_analysis: Optional[str] = None,
                 override_band: Optional[str] = None,
                 override_channel: Optional[str] = None,
                 override_txpower: Optional[str] = None,
                 override_vaps: Optional[str] = None,
                 power_level: Optional[int] = None,
                 power_mode: Optional[str] = None,
                 power_value: Optional[int] = None,
                 spectrum_analysis: Optional[str] = None,
                 vap_all: Optional[str] = None,
                 vaps: Optional[Sequence['outputs.WtpRadio4Vap']] = None):
        """
        :param int auto_power_high: The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_level: Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        :param int auto_power_low: The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_target: The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        :param str band: WiFi band that Radio 4 operates on.
        :param Sequence['WtpRadio4ChannelArgs'] channels: Selected list of wireless radio channels. The structure of `channel` block is documented below.
        :param str drma_manual_mode: Radio mode to be used for DRMA manual mode (default = ncf). Valid values: `ap`, `monitor`, `ncf`, `ncf-peek`.
        :param str override_analysis: Enable to override the WTP profile spectrum analysis configuration. Valid values: `enable`, `disable`.
        :param str override_band: Enable to override the WTP profile band setting. Valid values: `enable`, `disable`.
        :param str override_channel: Enable to override WTP profile channel settings. Valid values: `enable`, `disable`.
        :param str override_txpower: Enable to override the WTP profile power level configuration. Valid values: `enable`, `disable`.
        :param str override_vaps: Enable to override WTP profile Virtual Access Point (VAP) settings. Valid values: `enable`, `disable`.
        :param int power_level: Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        :param str power_mode: Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        :param int power_value: Radio EIRP power in dBm (1 - 33, default = 27).
        :param str spectrum_analysis: Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        :param str vap_all: Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        :param Sequence['WtpRadio4VapArgs'] vaps: Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        """
        if auto_power_high is not None:
            pulumi.set(__self__, "auto_power_high", auto_power_high)
        if auto_power_level is not None:
            pulumi.set(__self__, "auto_power_level", auto_power_level)
        if auto_power_low is not None:
            pulumi.set(__self__, "auto_power_low", auto_power_low)
        if auto_power_target is not None:
            pulumi.set(__self__, "auto_power_target", auto_power_target)
        if band is not None:
            pulumi.set(__self__, "band", band)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if drma_manual_mode is not None:
            pulumi.set(__self__, "drma_manual_mode", drma_manual_mode)
        if override_analysis is not None:
            pulumi.set(__self__, "override_analysis", override_analysis)
        if override_band is not None:
            pulumi.set(__self__, "override_band", override_band)
        if override_channel is not None:
            pulumi.set(__self__, "override_channel", override_channel)
        if override_txpower is not None:
            pulumi.set(__self__, "override_txpower", override_txpower)
        if override_vaps is not None:
            pulumi.set(__self__, "override_vaps", override_vaps)
        if power_level is not None:
            pulumi.set(__self__, "power_level", power_level)
        if power_mode is not None:
            pulumi.set(__self__, "power_mode", power_mode)
        if power_value is not None:
            pulumi.set(__self__, "power_value", power_value)
        if spectrum_analysis is not None:
            pulumi.set(__self__, "spectrum_analysis", spectrum_analysis)
        if vap_all is not None:
            pulumi.set(__self__, "vap_all", vap_all)
        if vaps is not None:
            pulumi.set(__self__, "vaps", vaps)

    @property
    @pulumi.getter(name="autoPowerHigh")
    def auto_power_high(self) -> Optional[int]:
        """
        The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_high")

    @property
    @pulumi.getter(name="autoPowerLevel")
    def auto_power_level(self) -> Optional[str]:
        """
        Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "auto_power_level")

    @property
    @pulumi.getter(name="autoPowerLow")
    def auto_power_low(self) -> Optional[int]:
        """
        The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_low")

    @property
    @pulumi.getter(name="autoPowerTarget")
    def auto_power_target(self) -> Optional[str]:
        """
        The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        """
        return pulumi.get(self, "auto_power_target")

    @property
    @pulumi.getter
    def band(self) -> Optional[str]:
        """
        WiFi band that Radio 4 operates on.
        """
        return pulumi.get(self, "band")

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.WtpRadio4Channel']]:
        """
        Selected list of wireless radio channels. The structure of `channel` block is documented below.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter(name="drmaManualMode")
    def drma_manual_mode(self) -> Optional[str]:
        """
        Radio mode to be used for DRMA manual mode (default = ncf). Valid values: `ap`, `monitor`, `ncf`, `ncf-peek`.
        """
        return pulumi.get(self, "drma_manual_mode")

    @property
    @pulumi.getter(name="overrideAnalysis")
    def override_analysis(self) -> Optional[str]:
        """
        Enable to override the WTP profile spectrum analysis configuration. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_analysis")

    @property
    @pulumi.getter(name="overrideBand")
    def override_band(self) -> Optional[str]:
        """
        Enable to override the WTP profile band setting. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_band")

    @property
    @pulumi.getter(name="overrideChannel")
    def override_channel(self) -> Optional[str]:
        """
        Enable to override WTP profile channel settings. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_channel")

    @property
    @pulumi.getter(name="overrideTxpower")
    def override_txpower(self) -> Optional[str]:
        """
        Enable to override the WTP profile power level configuration. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_txpower")

    @property
    @pulumi.getter(name="overrideVaps")
    def override_vaps(self) -> Optional[str]:
        """
        Enable to override WTP profile Virtual Access Point (VAP) settings. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "override_vaps")

    @property
    @pulumi.getter(name="powerLevel")
    def power_level(self) -> Optional[int]:
        """
        Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        """
        return pulumi.get(self, "power_level")

    @property
    @pulumi.getter(name="powerMode")
    def power_mode(self) -> Optional[str]:
        """
        Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        """
        return pulumi.get(self, "power_mode")

    @property
    @pulumi.getter(name="powerValue")
    def power_value(self) -> Optional[int]:
        """
        Radio EIRP power in dBm (1 - 33, default = 27).
        """
        return pulumi.get(self, "power_value")

    @property
    @pulumi.getter(name="spectrumAnalysis")
    def spectrum_analysis(self) -> Optional[str]:
        """
        Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        """
        return pulumi.get(self, "spectrum_analysis")

    @property
    @pulumi.getter(name="vapAll")
    def vap_all(self) -> Optional[str]:
        """
        Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        """
        return pulumi.get(self, "vap_all")

    @property
    @pulumi.getter
    def vaps(self) -> Optional[Sequence['outputs.WtpRadio4Vap']]:
        """
        Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        """
        return pulumi.get(self, "vaps")


@pulumi.output_type
class WtpRadio4Channel(dict):
    def __init__(__self__, *,
                 chan: Optional[str] = None):
        """
        :param str chan: Channel number.
        """
        if chan is not None:
            pulumi.set(__self__, "chan", chan)

    @property
    @pulumi.getter
    def chan(self) -> Optional[str]:
        """
        Channel number.
        """
        return pulumi.get(self, "chan")


@pulumi.output_type
class WtpRadio4Vap(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Virtual Access Point (VAP) name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Virtual Access Point (VAP) name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WtpSplitTunnelingAcl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destIp":
            suggest = "dest_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpSplitTunnelingAcl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpSplitTunnelingAcl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpSplitTunnelingAcl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dest_ip: Optional[str] = None,
                 id: Optional[int] = None):
        """
        :param str dest_ip: Destination IP and mask for the split-tunneling subnet.
        :param int id: ID.
        """
        if dest_ip is not None:
            pulumi.set(__self__, "dest_ip", dest_ip)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="destIp")
    def dest_ip(self) -> Optional[str]:
        """
        Destination IP and mask for the split-tunneling subnet.
        """
        return pulumi.get(self, "dest_ip")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        ID.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class WtpgroupWtp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "wtpId":
            suggest = "wtp_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpgroupWtp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpgroupWtp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpgroupWtp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 wtp_id: Optional[str] = None):
        """
        :param str wtp_id: WTP ID.
        """
        if wtp_id is not None:
            pulumi.set(__self__, "wtp_id", wtp_id)

    @property
    @pulumi.getter(name="wtpId")
    def wtp_id(self) -> Optional[str]:
        """
        WTP ID.
        """
        return pulumi.get(self, "wtp_id")


@pulumi.output_type
class WtpprofileDenyMacList(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None,
                 mac: Optional[str] = None):
        """
        :param int id: ID.
        :param str mac: A WiFi device with this MAC address is denied access to this WTP, FortiAP or AP.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        """
        A WiFi device with this MAC address is denied access to this WTP, FortiAP or AP.
        """
        return pulumi.get(self, "mac")


@pulumi.output_type
class WtpprofileEslSesDongle(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apcAddrType":
            suggest = "apc_addr_type"
        elif key == "apcFqdn":
            suggest = "apc_fqdn"
        elif key == "apcIp":
            suggest = "apc_ip"
        elif key == "apcPort":
            suggest = "apc_port"
        elif key == "coexLevel":
            suggest = "coex_level"
        elif key == "complianceLevel":
            suggest = "compliance_level"
        elif key == "eslChannel":
            suggest = "esl_channel"
        elif key == "outputPower":
            suggest = "output_power"
        elif key == "scdEnable":
            suggest = "scd_enable"
        elif key == "tlsCertVerification":
            suggest = "tls_cert_verification"
        elif key == "tlsFqdnVerification":
            suggest = "tls_fqdn_verification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpprofileEslSesDongle. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpprofileEslSesDongle.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpprofileEslSesDongle.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 apc_addr_type: Optional[str] = None,
                 apc_fqdn: Optional[str] = None,
                 apc_ip: Optional[str] = None,
                 apc_port: Optional[int] = None,
                 coex_level: Optional[str] = None,
                 compliance_level: Optional[str] = None,
                 esl_channel: Optional[str] = None,
                 output_power: Optional[str] = None,
                 scd_enable: Optional[str] = None,
                 tls_cert_verification: Optional[str] = None,
                 tls_fqdn_verification: Optional[str] = None):
        """
        :param str apc_addr_type: ESL SES-imagotag APC address type (default = fqdn). Valid values: `fqdn`, `ip`.
        :param str apc_fqdn: FQDN of ESL SES-imagotag Access Point Controller (APC).
        :param str apc_ip: IP address of ESL SES-imagotag Access Point Controller (APC).
        :param int apc_port: Port of ESL SES-imagotag Access Point Controller (APC).
        :param str coex_level: ESL SES-imagotag dongle coexistence level (default = none). Valid values: `none`.
        :param str compliance_level: Compliance levels for the ESL solution integration (default = compliance-level-2). Valid values: `compliance-level-2`.
        :param str esl_channel: ESL SES-imagotag dongle channel (default = 127). Valid values: `-1`, `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `127`.
        :param str output_power: ESL SES-imagotag dongle output power (default = A). Valid values: `a`, `b`, `c`, `d`, `e`, `f`, `g`, `h`.
        :param str scd_enable: Enable/disable ESL SES-imagotag Serial Communication Daemon (SCD) (default = disable). Valid values: `enable`, `disable`.
        :param str tls_cert_verification: Enable/disable TLS Certificate verification. (default = enable). Valid values: `enable`, `disable`.
        :param str tls_fqdn_verification: Enable/disable TLS Certificate verification. (default = disable). Valid values: `enable`, `disable`.
        """
        if apc_addr_type is not None:
            pulumi.set(__self__, "apc_addr_type", apc_addr_type)
        if apc_fqdn is not None:
            pulumi.set(__self__, "apc_fqdn", apc_fqdn)
        if apc_ip is not None:
            pulumi.set(__self__, "apc_ip", apc_ip)
        if apc_port is not None:
            pulumi.set(__self__, "apc_port", apc_port)
        if coex_level is not None:
            pulumi.set(__self__, "coex_level", coex_level)
        if compliance_level is not None:
            pulumi.set(__self__, "compliance_level", compliance_level)
        if esl_channel is not None:
            pulumi.set(__self__, "esl_channel", esl_channel)
        if output_power is not None:
            pulumi.set(__self__, "output_power", output_power)
        if scd_enable is not None:
            pulumi.set(__self__, "scd_enable", scd_enable)
        if tls_cert_verification is not None:
            pulumi.set(__self__, "tls_cert_verification", tls_cert_verification)
        if tls_fqdn_verification is not None:
            pulumi.set(__self__, "tls_fqdn_verification", tls_fqdn_verification)

    @property
    @pulumi.getter(name="apcAddrType")
    def apc_addr_type(self) -> Optional[str]:
        """
        ESL SES-imagotag APC address type (default = fqdn). Valid values: `fqdn`, `ip`.
        """
        return pulumi.get(self, "apc_addr_type")

    @property
    @pulumi.getter(name="apcFqdn")
    def apc_fqdn(self) -> Optional[str]:
        """
        FQDN of ESL SES-imagotag Access Point Controller (APC).
        """
        return pulumi.get(self, "apc_fqdn")

    @property
    @pulumi.getter(name="apcIp")
    def apc_ip(self) -> Optional[str]:
        """
        IP address of ESL SES-imagotag Access Point Controller (APC).
        """
        return pulumi.get(self, "apc_ip")

    @property
    @pulumi.getter(name="apcPort")
    def apc_port(self) -> Optional[int]:
        """
        Port of ESL SES-imagotag Access Point Controller (APC).
        """
        return pulumi.get(self, "apc_port")

    @property
    @pulumi.getter(name="coexLevel")
    def coex_level(self) -> Optional[str]:
        """
        ESL SES-imagotag dongle coexistence level (default = none). Valid values: `none`.
        """
        return pulumi.get(self, "coex_level")

    @property
    @pulumi.getter(name="complianceLevel")
    def compliance_level(self) -> Optional[str]:
        """
        Compliance levels for the ESL solution integration (default = compliance-level-2). Valid values: `compliance-level-2`.
        """
        return pulumi.get(self, "compliance_level")

    @property
    @pulumi.getter(name="eslChannel")
    def esl_channel(self) -> Optional[str]:
        """
        ESL SES-imagotag dongle channel (default = 127). Valid values: `-1`, `0`, `1`, `2`, `3`, `4`, `5`, `6`, `7`, `8`, `9`, `10`, `127`.
        """
        return pulumi.get(self, "esl_channel")

    @property
    @pulumi.getter(name="outputPower")
    def output_power(self) -> Optional[str]:
        """
        ESL SES-imagotag dongle output power (default = A). Valid values: `a`, `b`, `c`, `d`, `e`, `f`, `g`, `h`.
        """
        return pulumi.get(self, "output_power")

    @property
    @pulumi.getter(name="scdEnable")
    def scd_enable(self) -> Optional[str]:
        """
        Enable/disable ESL SES-imagotag Serial Communication Daemon (SCD) (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "scd_enable")

    @property
    @pulumi.getter(name="tlsCertVerification")
    def tls_cert_verification(self) -> Optional[str]:
        """
        Enable/disable TLS Certificate verification. (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "tls_cert_verification")

    @property
    @pulumi.getter(name="tlsFqdnVerification")
    def tls_fqdn_verification(self) -> Optional[str]:
        """
        Enable/disable TLS Certificate verification. (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "tls_fqdn_verification")


@pulumi.output_type
class WtpprofileLan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "port1Mode":
            suggest = "port1_mode"
        elif key == "port1Ssid":
            suggest = "port1_ssid"
        elif key == "port2Mode":
            suggest = "port2_mode"
        elif key == "port2Ssid":
            suggest = "port2_ssid"
        elif key == "port3Mode":
            suggest = "port3_mode"
        elif key == "port3Ssid":
            suggest = "port3_ssid"
        elif key == "port4Mode":
            suggest = "port4_mode"
        elif key == "port4Ssid":
            suggest = "port4_ssid"
        elif key == "port5Mode":
            suggest = "port5_mode"
        elif key == "port5Ssid":
            suggest = "port5_ssid"
        elif key == "port6Mode":
            suggest = "port6_mode"
        elif key == "port6Ssid":
            suggest = "port6_ssid"
        elif key == "port7Mode":
            suggest = "port7_mode"
        elif key == "port7Ssid":
            suggest = "port7_ssid"
        elif key == "port8Mode":
            suggest = "port8_mode"
        elif key == "port8Ssid":
            suggest = "port8_ssid"
        elif key == "portEslMode":
            suggest = "port_esl_mode"
        elif key == "portEslSsid":
            suggest = "port_esl_ssid"
        elif key == "portMode":
            suggest = "port_mode"
        elif key == "portSsid":
            suggest = "port_ssid"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpprofileLan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpprofileLan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpprofileLan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port1_mode: Optional[str] = None,
                 port1_ssid: Optional[str] = None,
                 port2_mode: Optional[str] = None,
                 port2_ssid: Optional[str] = None,
                 port3_mode: Optional[str] = None,
                 port3_ssid: Optional[str] = None,
                 port4_mode: Optional[str] = None,
                 port4_ssid: Optional[str] = None,
                 port5_mode: Optional[str] = None,
                 port5_ssid: Optional[str] = None,
                 port6_mode: Optional[str] = None,
                 port6_ssid: Optional[str] = None,
                 port7_mode: Optional[str] = None,
                 port7_ssid: Optional[str] = None,
                 port8_mode: Optional[str] = None,
                 port8_ssid: Optional[str] = None,
                 port_esl_mode: Optional[str] = None,
                 port_esl_ssid: Optional[str] = None,
                 port_mode: Optional[str] = None,
                 port_ssid: Optional[str] = None):
        """
        :param str port1_mode: LAN port 1 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port1_ssid: Bridge LAN port 1 to SSID.
        :param str port2_mode: LAN port 2 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port2_ssid: Bridge LAN port 2 to SSID.
        :param str port3_mode: LAN port 3 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port3_ssid: Bridge LAN port 3 to SSID.
        :param str port4_mode: LAN port 4 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port4_ssid: Bridge LAN port 4 to SSID.
        :param str port5_mode: LAN port 5 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port5_ssid: Bridge LAN port 5 to SSID.
        :param str port6_mode: LAN port 6 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port6_ssid: Bridge LAN port 6 to SSID.
        :param str port7_mode: LAN port 7 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port7_ssid: Bridge LAN port 7 to SSID.
        :param str port8_mode: LAN port 8 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port8_ssid: Bridge LAN port 8 to SSID.
        :param str port_esl_mode: ESL port mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port_esl_ssid: Bridge ESL port to SSID.
        :param str port_mode: LAN port mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        :param str port_ssid: Bridge LAN port to SSID.
        """
        if port1_mode is not None:
            pulumi.set(__self__, "port1_mode", port1_mode)
        if port1_ssid is not None:
            pulumi.set(__self__, "port1_ssid", port1_ssid)
        if port2_mode is not None:
            pulumi.set(__self__, "port2_mode", port2_mode)
        if port2_ssid is not None:
            pulumi.set(__self__, "port2_ssid", port2_ssid)
        if port3_mode is not None:
            pulumi.set(__self__, "port3_mode", port3_mode)
        if port3_ssid is not None:
            pulumi.set(__self__, "port3_ssid", port3_ssid)
        if port4_mode is not None:
            pulumi.set(__self__, "port4_mode", port4_mode)
        if port4_ssid is not None:
            pulumi.set(__self__, "port4_ssid", port4_ssid)
        if port5_mode is not None:
            pulumi.set(__self__, "port5_mode", port5_mode)
        if port5_ssid is not None:
            pulumi.set(__self__, "port5_ssid", port5_ssid)
        if port6_mode is not None:
            pulumi.set(__self__, "port6_mode", port6_mode)
        if port6_ssid is not None:
            pulumi.set(__self__, "port6_ssid", port6_ssid)
        if port7_mode is not None:
            pulumi.set(__self__, "port7_mode", port7_mode)
        if port7_ssid is not None:
            pulumi.set(__self__, "port7_ssid", port7_ssid)
        if port8_mode is not None:
            pulumi.set(__self__, "port8_mode", port8_mode)
        if port8_ssid is not None:
            pulumi.set(__self__, "port8_ssid", port8_ssid)
        if port_esl_mode is not None:
            pulumi.set(__self__, "port_esl_mode", port_esl_mode)
        if port_esl_ssid is not None:
            pulumi.set(__self__, "port_esl_ssid", port_esl_ssid)
        if port_mode is not None:
            pulumi.set(__self__, "port_mode", port_mode)
        if port_ssid is not None:
            pulumi.set(__self__, "port_ssid", port_ssid)

    @property
    @pulumi.getter(name="port1Mode")
    def port1_mode(self) -> Optional[str]:
        """
        LAN port 1 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port1_mode")

    @property
    @pulumi.getter(name="port1Ssid")
    def port1_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 1 to SSID.
        """
        return pulumi.get(self, "port1_ssid")

    @property
    @pulumi.getter(name="port2Mode")
    def port2_mode(self) -> Optional[str]:
        """
        LAN port 2 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port2_mode")

    @property
    @pulumi.getter(name="port2Ssid")
    def port2_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 2 to SSID.
        """
        return pulumi.get(self, "port2_ssid")

    @property
    @pulumi.getter(name="port3Mode")
    def port3_mode(self) -> Optional[str]:
        """
        LAN port 3 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port3_mode")

    @property
    @pulumi.getter(name="port3Ssid")
    def port3_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 3 to SSID.
        """
        return pulumi.get(self, "port3_ssid")

    @property
    @pulumi.getter(name="port4Mode")
    def port4_mode(self) -> Optional[str]:
        """
        LAN port 4 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port4_mode")

    @property
    @pulumi.getter(name="port4Ssid")
    def port4_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 4 to SSID.
        """
        return pulumi.get(self, "port4_ssid")

    @property
    @pulumi.getter(name="port5Mode")
    def port5_mode(self) -> Optional[str]:
        """
        LAN port 5 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port5_mode")

    @property
    @pulumi.getter(name="port5Ssid")
    def port5_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 5 to SSID.
        """
        return pulumi.get(self, "port5_ssid")

    @property
    @pulumi.getter(name="port6Mode")
    def port6_mode(self) -> Optional[str]:
        """
        LAN port 6 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port6_mode")

    @property
    @pulumi.getter(name="port6Ssid")
    def port6_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 6 to SSID.
        """
        return pulumi.get(self, "port6_ssid")

    @property
    @pulumi.getter(name="port7Mode")
    def port7_mode(self) -> Optional[str]:
        """
        LAN port 7 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port7_mode")

    @property
    @pulumi.getter(name="port7Ssid")
    def port7_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 7 to SSID.
        """
        return pulumi.get(self, "port7_ssid")

    @property
    @pulumi.getter(name="port8Mode")
    def port8_mode(self) -> Optional[str]:
        """
        LAN port 8 mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port8_mode")

    @property
    @pulumi.getter(name="port8Ssid")
    def port8_ssid(self) -> Optional[str]:
        """
        Bridge LAN port 8 to SSID.
        """
        return pulumi.get(self, "port8_ssid")

    @property
    @pulumi.getter(name="portEslMode")
    def port_esl_mode(self) -> Optional[str]:
        """
        ESL port mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port_esl_mode")

    @property
    @pulumi.getter(name="portEslSsid")
    def port_esl_ssid(self) -> Optional[str]:
        """
        Bridge ESL port to SSID.
        """
        return pulumi.get(self, "port_esl_ssid")

    @property
    @pulumi.getter(name="portMode")
    def port_mode(self) -> Optional[str]:
        """
        LAN port mode. Valid values: `offline`, `nat-to-wan`, `bridge-to-wan`, `bridge-to-ssid`.
        """
        return pulumi.get(self, "port_mode")

    @property
    @pulumi.getter(name="portSsid")
    def port_ssid(self) -> Optional[str]:
        """
        Bridge LAN port to SSID.
        """
        return pulumi.get(self, "port_ssid")


@pulumi.output_type
class WtpprofileLbs(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aeroscoutApMac":
            suggest = "aeroscout_ap_mac"
        elif key == "aeroscoutMmuReport":
            suggest = "aeroscout_mmu_report"
        elif key == "aeroscoutMu":
            suggest = "aeroscout_mu"
        elif key == "aeroscoutMuFactor":
            suggest = "aeroscout_mu_factor"
        elif key == "aeroscoutMuTimeout":
            suggest = "aeroscout_mu_timeout"
        elif key == "aeroscoutServerIp":
            suggest = "aeroscout_server_ip"
        elif key == "aeroscoutServerPort":
            suggest = "aeroscout_server_port"
        elif key == "ekahauBlinkMode":
            suggest = "ekahau_blink_mode"
        elif key == "ekahauTag":
            suggest = "ekahau_tag"
        elif key == "ercServerIp":
            suggest = "erc_server_ip"
        elif key == "ercServerPort":
            suggest = "erc_server_port"
        elif key == "fortipresenceBle":
            suggest = "fortipresence_ble"
        elif key == "fortipresenceFrequency":
            suggest = "fortipresence_frequency"
        elif key == "fortipresencePort":
            suggest = "fortipresence_port"
        elif key == "fortipresenceProject":
            suggest = "fortipresence_project"
        elif key == "fortipresenceRogue":
            suggest = "fortipresence_rogue"
        elif key == "fortipresenceSecret":
            suggest = "fortipresence_secret"
        elif key == "fortipresenceServer":
            suggest = "fortipresence_server"
        elif key == "fortipresenceServerAddrType":
            suggest = "fortipresence_server_addr_type"
        elif key == "fortipresenceServerFqdn":
            suggest = "fortipresence_server_fqdn"
        elif key == "fortipresenceUnassoc":
            suggest = "fortipresence_unassoc"
        elif key == "polestarAccumulationInterval":
            suggest = "polestar_accumulation_interval"
        elif key == "polestarAssetAddrgrpList":
            suggest = "polestar_asset_addrgrp_list"
        elif key == "polestarAssetUuidList1":
            suggest = "polestar_asset_uuid_list1"
        elif key == "polestarAssetUuidList2":
            suggest = "polestar_asset_uuid_list2"
        elif key == "polestarAssetUuidList3":
            suggest = "polestar_asset_uuid_list3"
        elif key == "polestarAssetUuidList4":
            suggest = "polestar_asset_uuid_list4"
        elif key == "polestarProtocol":
            suggest = "polestar_protocol"
        elif key == "polestarReportingInterval":
            suggest = "polestar_reporting_interval"
        elif key == "polestarServerFqdn":
            suggest = "polestar_server_fqdn"
        elif key == "polestarServerPath":
            suggest = "polestar_server_path"
        elif key == "polestarServerPort":
            suggest = "polestar_server_port"
        elif key == "polestarServerToken":
            suggest = "polestar_server_token"
        elif key == "stationLocate":
            suggest = "station_locate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpprofileLbs. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpprofileLbs.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpprofileLbs.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aeroscout: Optional[str] = None,
                 aeroscout_ap_mac: Optional[str] = None,
                 aeroscout_mmu_report: Optional[str] = None,
                 aeroscout_mu: Optional[str] = None,
                 aeroscout_mu_factor: Optional[int] = None,
                 aeroscout_mu_timeout: Optional[int] = None,
                 aeroscout_server_ip: Optional[str] = None,
                 aeroscout_server_port: Optional[int] = None,
                 ekahau_blink_mode: Optional[str] = None,
                 ekahau_tag: Optional[str] = None,
                 erc_server_ip: Optional[str] = None,
                 erc_server_port: Optional[int] = None,
                 fortipresence: Optional[str] = None,
                 fortipresence_ble: Optional[str] = None,
                 fortipresence_frequency: Optional[int] = None,
                 fortipresence_port: Optional[int] = None,
                 fortipresence_project: Optional[str] = None,
                 fortipresence_rogue: Optional[str] = None,
                 fortipresence_secret: Optional[str] = None,
                 fortipresence_server: Optional[str] = None,
                 fortipresence_server_addr_type: Optional[str] = None,
                 fortipresence_server_fqdn: Optional[str] = None,
                 fortipresence_unassoc: Optional[str] = None,
                 polestar: Optional[str] = None,
                 polestar_accumulation_interval: Optional[int] = None,
                 polestar_asset_addrgrp_list: Optional[str] = None,
                 polestar_asset_uuid_list1: Optional[str] = None,
                 polestar_asset_uuid_list2: Optional[str] = None,
                 polestar_asset_uuid_list3: Optional[str] = None,
                 polestar_asset_uuid_list4: Optional[str] = None,
                 polestar_protocol: Optional[str] = None,
                 polestar_reporting_interval: Optional[int] = None,
                 polestar_server_fqdn: Optional[str] = None,
                 polestar_server_path: Optional[str] = None,
                 polestar_server_port: Optional[int] = None,
                 polestar_server_token: Optional[str] = None,
                 station_locate: Optional[str] = None):
        """
        :param str aeroscout: Enable/disable AeroScout Real Time Location Service (RTLS) support. Valid values: `enable`, `disable`.
        :param str aeroscout_ap_mac: Use BSSID or board MAC address as AP MAC address in the Aeroscout AP message. Valid values: `bssid`, `board-mac`.
        :param str aeroscout_mmu_report: Enable/disable MU compounded report. Valid values: `enable`, `disable`.
        :param str aeroscout_mu: Enable/disable AeroScout support. Valid values: `enable`, `disable`.
        :param int aeroscout_mu_factor: AeroScout Mobile Unit (MU) mode dilution factor (default = 20).
        :param int aeroscout_mu_timeout: AeroScout MU mode timeout (0 - 65535 sec, default = 5).
        :param str aeroscout_server_ip: IP address of AeroScout server.
        :param int aeroscout_server_port: AeroScout server UDP listening port.
        :param str ekahau_blink_mode: Enable/disable Ekahua blink mode (also called AiRISTA Flow Blink Mode) to find the location of devices connected to a wireless LAN (default = disable). Valid values: `enable`, `disable`.
        :param str ekahau_tag: WiFi frame MAC address or WiFi Tag.
        :param str erc_server_ip: IP address of Ekahua RTLS Controller (ERC).
        :param int erc_server_port: Ekahua RTLS Controller (ERC) UDP listening port.
        :param str fortipresence: Enable/disable FortiPresence to monitor the location and activity of WiFi clients even if they don't connect to this WiFi network (default = disable). Valid values: `foreign`, `both`, `disable`.
        :param str fortipresence_ble: Enable/disable FortiPresence finding and reporting BLE devices. Valid values: `enable`, `disable`.
        :param int fortipresence_frequency: FortiPresence report transmit frequency (5 - 65535 sec, default = 30).
        :param int fortipresence_port: FortiPresence server UDP listening port (default = 3000).
        :param str fortipresence_project: FortiPresence project name (max. 16 characters, default = fortipresence).
        :param str fortipresence_rogue: Enable/disable FortiPresence finding and reporting rogue APs. Valid values: `enable`, `disable`.
        :param str fortipresence_secret: FortiPresence secret password (max. 16 characters).
        :param str fortipresence_server: FortiPresence server IP address.
        :param str fortipresence_server_addr_type: FortiPresence server address type (default = ipv4). Valid values: `ipv4`, `fqdn`.
        :param str fortipresence_server_fqdn: FQDN of FortiPresence server.
        :param str fortipresence_unassoc: Enable/disable FortiPresence finding and reporting unassociated stations. Valid values: `enable`, `disable`.
        :param str polestar: Enable/disable PoleStar BLE NAO Track Real Time Location Service (RTLS) support (default = disable). Valid values: `enable`, `disable`.
        :param int polestar_accumulation_interval: Time that measurements should be accumulated in seconds (default = 2).
        :param str polestar_asset_addrgrp_list: Tags and asset addrgrp list to be reported.
        :param str polestar_asset_uuid_list1: Tags and asset UUID list 1 to be reported (string in the format of 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX').
        :param str polestar_asset_uuid_list2: Tags and asset UUID list 2 to be reported (string in the format of 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX').
        :param str polestar_asset_uuid_list3: Tags and asset UUID list 3 to be reported (string in the format of 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX').
        :param str polestar_asset_uuid_list4: Tags and asset UUID list 4 to be reported (string in the format of 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX').
        :param str polestar_protocol: Select the protocol to report Measurements, Advertising Data, or Location Data to NAO Cloud. (default = WSS). Valid values: `WSS`.
        :param int polestar_reporting_interval: Time between reporting accumulated measurements in seconds (default = 2).
        :param str polestar_server_fqdn: FQDN of PoleStar Nao Track Server (default = ws.nao-cloud.com).
        :param str polestar_server_path: Path of PoleStar Nao Track Server (default = /v1/token/<access_token>/pst-v2).
        :param int polestar_server_port: Port of PoleStar Nao Track Server (default = 443).
        :param str polestar_server_token: Access Token of PoleStar Nao Track Server.
        :param str station_locate: Enable/disable client station locating services for all clients, whether associated or not (default = disable). Valid values: `enable`, `disable`.
        """
        if aeroscout is not None:
            pulumi.set(__self__, "aeroscout", aeroscout)
        if aeroscout_ap_mac is not None:
            pulumi.set(__self__, "aeroscout_ap_mac", aeroscout_ap_mac)
        if aeroscout_mmu_report is not None:
            pulumi.set(__self__, "aeroscout_mmu_report", aeroscout_mmu_report)
        if aeroscout_mu is not None:
            pulumi.set(__self__, "aeroscout_mu", aeroscout_mu)
        if aeroscout_mu_factor is not None:
            pulumi.set(__self__, "aeroscout_mu_factor", aeroscout_mu_factor)
        if aeroscout_mu_timeout is not None:
            pulumi.set(__self__, "aeroscout_mu_timeout", aeroscout_mu_timeout)
        if aeroscout_server_ip is not None:
            pulumi.set(__self__, "aeroscout_server_ip", aeroscout_server_ip)
        if aeroscout_server_port is not None:
            pulumi.set(__self__, "aeroscout_server_port", aeroscout_server_port)
        if ekahau_blink_mode is not None:
            pulumi.set(__self__, "ekahau_blink_mode", ekahau_blink_mode)
        if ekahau_tag is not None:
            pulumi.set(__self__, "ekahau_tag", ekahau_tag)
        if erc_server_ip is not None:
            pulumi.set(__self__, "erc_server_ip", erc_server_ip)
        if erc_server_port is not None:
            pulumi.set(__self__, "erc_server_port", erc_server_port)
        if fortipresence is not None:
            pulumi.set(__self__, "fortipresence", fortipresence)
        if fortipresence_ble is not None:
            pulumi.set(__self__, "fortipresence_ble", fortipresence_ble)
        if fortipresence_frequency is not None:
            pulumi.set(__self__, "fortipresence_frequency", fortipresence_frequency)
        if fortipresence_port is not None:
            pulumi.set(__self__, "fortipresence_port", fortipresence_port)
        if fortipresence_project is not None:
            pulumi.set(__self__, "fortipresence_project", fortipresence_project)
        if fortipresence_rogue is not None:
            pulumi.set(__self__, "fortipresence_rogue", fortipresence_rogue)
        if fortipresence_secret is not None:
            pulumi.set(__self__, "fortipresence_secret", fortipresence_secret)
        if fortipresence_server is not None:
            pulumi.set(__self__, "fortipresence_server", fortipresence_server)
        if fortipresence_server_addr_type is not None:
            pulumi.set(__self__, "fortipresence_server_addr_type", fortipresence_server_addr_type)
        if fortipresence_server_fqdn is not None:
            pulumi.set(__self__, "fortipresence_server_fqdn", fortipresence_server_fqdn)
        if fortipresence_unassoc is not None:
            pulumi.set(__self__, "fortipresence_unassoc", fortipresence_unassoc)
        if polestar is not None:
            pulumi.set(__self__, "polestar", polestar)
        if polestar_accumulation_interval is not None:
            pulumi.set(__self__, "polestar_accumulation_interval", polestar_accumulation_interval)
        if polestar_asset_addrgrp_list is not None:
            pulumi.set(__self__, "polestar_asset_addrgrp_list", polestar_asset_addrgrp_list)
        if polestar_asset_uuid_list1 is not None:
            pulumi.set(__self__, "polestar_asset_uuid_list1", polestar_asset_uuid_list1)
        if polestar_asset_uuid_list2 is not None:
            pulumi.set(__self__, "polestar_asset_uuid_list2", polestar_asset_uuid_list2)
        if polestar_asset_uuid_list3 is not None:
            pulumi.set(__self__, "polestar_asset_uuid_list3", polestar_asset_uuid_list3)
        if polestar_asset_uuid_list4 is not None:
            pulumi.set(__self__, "polestar_asset_uuid_list4", polestar_asset_uuid_list4)
        if polestar_protocol is not None:
            pulumi.set(__self__, "polestar_protocol", polestar_protocol)
        if polestar_reporting_interval is not None:
            pulumi.set(__self__, "polestar_reporting_interval", polestar_reporting_interval)
        if polestar_server_fqdn is not None:
            pulumi.set(__self__, "polestar_server_fqdn", polestar_server_fqdn)
        if polestar_server_path is not None:
            pulumi.set(__self__, "polestar_server_path", polestar_server_path)
        if polestar_server_port is not None:
            pulumi.set(__self__, "polestar_server_port", polestar_server_port)
        if polestar_server_token is not None:
            pulumi.set(__self__, "polestar_server_token", polestar_server_token)
        if station_locate is not None:
            pulumi.set(__self__, "station_locate", station_locate)

    @property
    @pulumi.getter
    def aeroscout(self) -> Optional[str]:
        """
        Enable/disable AeroScout Real Time Location Service (RTLS) support. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "aeroscout")

    @property
    @pulumi.getter(name="aeroscoutApMac")
    def aeroscout_ap_mac(self) -> Optional[str]:
        """
        Use BSSID or board MAC address as AP MAC address in the Aeroscout AP message. Valid values: `bssid`, `board-mac`.
        """
        return pulumi.get(self, "aeroscout_ap_mac")

    @property
    @pulumi.getter(name="aeroscoutMmuReport")
    def aeroscout_mmu_report(self) -> Optional[str]:
        """
        Enable/disable MU compounded report. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "aeroscout_mmu_report")

    @property
    @pulumi.getter(name="aeroscoutMu")
    def aeroscout_mu(self) -> Optional[str]:
        """
        Enable/disable AeroScout support. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "aeroscout_mu")

    @property
    @pulumi.getter(name="aeroscoutMuFactor")
    def aeroscout_mu_factor(self) -> Optional[int]:
        """
        AeroScout Mobile Unit (MU) mode dilution factor (default = 20).
        """
        return pulumi.get(self, "aeroscout_mu_factor")

    @property
    @pulumi.getter(name="aeroscoutMuTimeout")
    def aeroscout_mu_timeout(self) -> Optional[int]:
        """
        AeroScout MU mode timeout (0 - 65535 sec, default = 5).
        """
        return pulumi.get(self, "aeroscout_mu_timeout")

    @property
    @pulumi.getter(name="aeroscoutServerIp")
    def aeroscout_server_ip(self) -> Optional[str]:
        """
        IP address of AeroScout server.
        """
        return pulumi.get(self, "aeroscout_server_ip")

    @property
    @pulumi.getter(name="aeroscoutServerPort")
    def aeroscout_server_port(self) -> Optional[int]:
        """
        AeroScout server UDP listening port.
        """
        return pulumi.get(self, "aeroscout_server_port")

    @property
    @pulumi.getter(name="ekahauBlinkMode")
    def ekahau_blink_mode(self) -> Optional[str]:
        """
        Enable/disable Ekahua blink mode (also called AiRISTA Flow Blink Mode) to find the location of devices connected to a wireless LAN (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ekahau_blink_mode")

    @property
    @pulumi.getter(name="ekahauTag")
    def ekahau_tag(self) -> Optional[str]:
        """
        WiFi frame MAC address or WiFi Tag.
        """
        return pulumi.get(self, "ekahau_tag")

    @property
    @pulumi.getter(name="ercServerIp")
    def erc_server_ip(self) -> Optional[str]:
        """
        IP address of Ekahua RTLS Controller (ERC).
        """
        return pulumi.get(self, "erc_server_ip")

    @property
    @pulumi.getter(name="ercServerPort")
    def erc_server_port(self) -> Optional[int]:
        """
        Ekahua RTLS Controller (ERC) UDP listening port.
        """
        return pulumi.get(self, "erc_server_port")

    @property
    @pulumi.getter
    def fortipresence(self) -> Optional[str]:
        """
        Enable/disable FortiPresence to monitor the location and activity of WiFi clients even if they don't connect to this WiFi network (default = disable). Valid values: `foreign`, `both`, `disable`.
        """
        return pulumi.get(self, "fortipresence")

    @property
    @pulumi.getter(name="fortipresenceBle")
    def fortipresence_ble(self) -> Optional[str]:
        """
        Enable/disable FortiPresence finding and reporting BLE devices. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "fortipresence_ble")

    @property
    @pulumi.getter(name="fortipresenceFrequency")
    def fortipresence_frequency(self) -> Optional[int]:
        """
        FortiPresence report transmit frequency (5 - 65535 sec, default = 30).
        """
        return pulumi.get(self, "fortipresence_frequency")

    @property
    @pulumi.getter(name="fortipresencePort")
    def fortipresence_port(self) -> Optional[int]:
        """
        FortiPresence server UDP listening port (default = 3000).
        """
        return pulumi.get(self, "fortipresence_port")

    @property
    @pulumi.getter(name="fortipresenceProject")
    def fortipresence_project(self) -> Optional[str]:
        """
        FortiPresence project name (max. 16 characters, default = fortipresence).
        """
        return pulumi.get(self, "fortipresence_project")

    @property
    @pulumi.getter(name="fortipresenceRogue")
    def fortipresence_rogue(self) -> Optional[str]:
        """
        Enable/disable FortiPresence finding and reporting rogue APs. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "fortipresence_rogue")

    @property
    @pulumi.getter(name="fortipresenceSecret")
    def fortipresence_secret(self) -> Optional[str]:
        """
        FortiPresence secret password (max. 16 characters).
        """
        return pulumi.get(self, "fortipresence_secret")

    @property
    @pulumi.getter(name="fortipresenceServer")
    def fortipresence_server(self) -> Optional[str]:
        """
        FortiPresence server IP address.
        """
        return pulumi.get(self, "fortipresence_server")

    @property
    @pulumi.getter(name="fortipresenceServerAddrType")
    def fortipresence_server_addr_type(self) -> Optional[str]:
        """
        FortiPresence server address type (default = ipv4). Valid values: `ipv4`, `fqdn`.
        """
        return pulumi.get(self, "fortipresence_server_addr_type")

    @property
    @pulumi.getter(name="fortipresenceServerFqdn")
    def fortipresence_server_fqdn(self) -> Optional[str]:
        """
        FQDN of FortiPresence server.
        """
        return pulumi.get(self, "fortipresence_server_fqdn")

    @property
    @pulumi.getter(name="fortipresenceUnassoc")
    def fortipresence_unassoc(self) -> Optional[str]:
        """
        Enable/disable FortiPresence finding and reporting unassociated stations. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "fortipresence_unassoc")

    @property
    @pulumi.getter
    def polestar(self) -> Optional[str]:
        """
        Enable/disable PoleStar BLE NAO Track Real Time Location Service (RTLS) support (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "polestar")

    @property
    @pulumi.getter(name="polestarAccumulationInterval")
    def polestar_accumulation_interval(self) -> Optional[int]:
        """
        Time that measurements should be accumulated in seconds (default = 2).
        """
        return pulumi.get(self, "polestar_accumulation_interval")

    @property
    @pulumi.getter(name="polestarAssetAddrgrpList")
    def polestar_asset_addrgrp_list(self) -> Optional[str]:
        """
        Tags and asset addrgrp list to be reported.
        """
        return pulumi.get(self, "polestar_asset_addrgrp_list")

    @property
    @pulumi.getter(name="polestarAssetUuidList1")
    def polestar_asset_uuid_list1(self) -> Optional[str]:
        """
        Tags and asset UUID list 1 to be reported (string in the format of 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX').
        """
        return pulumi.get(self, "polestar_asset_uuid_list1")

    @property
    @pulumi.getter(name="polestarAssetUuidList2")
    def polestar_asset_uuid_list2(self) -> Optional[str]:
        """
        Tags and asset UUID list 2 to be reported (string in the format of 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX').
        """
        return pulumi.get(self, "polestar_asset_uuid_list2")

    @property
    @pulumi.getter(name="polestarAssetUuidList3")
    def polestar_asset_uuid_list3(self) -> Optional[str]:
        """
        Tags and asset UUID list 3 to be reported (string in the format of 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX').
        """
        return pulumi.get(self, "polestar_asset_uuid_list3")

    @property
    @pulumi.getter(name="polestarAssetUuidList4")
    def polestar_asset_uuid_list4(self) -> Optional[str]:
        """
        Tags and asset UUID list 4 to be reported (string in the format of 'XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX').
        """
        return pulumi.get(self, "polestar_asset_uuid_list4")

    @property
    @pulumi.getter(name="polestarProtocol")
    def polestar_protocol(self) -> Optional[str]:
        """
        Select the protocol to report Measurements, Advertising Data, or Location Data to NAO Cloud. (default = WSS). Valid values: `WSS`.
        """
        return pulumi.get(self, "polestar_protocol")

    @property
    @pulumi.getter(name="polestarReportingInterval")
    def polestar_reporting_interval(self) -> Optional[int]:
        """
        Time between reporting accumulated measurements in seconds (default = 2).
        """
        return pulumi.get(self, "polestar_reporting_interval")

    @property
    @pulumi.getter(name="polestarServerFqdn")
    def polestar_server_fqdn(self) -> Optional[str]:
        """
        FQDN of PoleStar Nao Track Server (default = ws.nao-cloud.com).
        """
        return pulumi.get(self, "polestar_server_fqdn")

    @property
    @pulumi.getter(name="polestarServerPath")
    def polestar_server_path(self) -> Optional[str]:
        """
        Path of PoleStar Nao Track Server (default = /v1/token/<access_token>/pst-v2).
        """
        return pulumi.get(self, "polestar_server_path")

    @property
    @pulumi.getter(name="polestarServerPort")
    def polestar_server_port(self) -> Optional[int]:
        """
        Port of PoleStar Nao Track Server (default = 443).
        """
        return pulumi.get(self, "polestar_server_port")

    @property
    @pulumi.getter(name="polestarServerToken")
    def polestar_server_token(self) -> Optional[str]:
        """
        Access Token of PoleStar Nao Track Server.
        """
        return pulumi.get(self, "polestar_server_token")

    @property
    @pulumi.getter(name="stationLocate")
    def station_locate(self) -> Optional[str]:
        """
        Enable/disable client station locating services for all clients, whether associated or not (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "station_locate")


@pulumi.output_type
class WtpprofileLedSchedule(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: LED schedule name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        LED schedule name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WtpprofilePlatform(dict):
    def __init__(__self__, *,
                 ddscan: Optional[str] = None,
                 mode: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str ddscan: Enable/disable use of one radio for dedicated dual-band scanning to detect RF characterization and wireless threat management. Valid values: `enable`, `disable`.
        :param str mode: Configure operation mode of 5G radios (default = single-5G). Valid values: `single-5G`, `dual-5G`.
        :param str type: WTP, FortiAP or AP platform type. There are built-in WTP profiles for all supported FortiAP models. You can select a built-in profile and customize it or create a new profile.
        """
        if ddscan is not None:
            pulumi.set(__self__, "ddscan", ddscan)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def ddscan(self) -> Optional[str]:
        """
        Enable/disable use of one radio for dedicated dual-band scanning to detect RF characterization and wireless threat management. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ddscan")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Configure operation mode of 5G radios (default = single-5G). Valid values: `single-5G`, `dual-5G`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        WTP, FortiAP or AP platform type. There are built-in WTP profiles for all supported FortiAP models. You can select a built-in profile and customize it or create a new profile.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class WtpprofileRadio1(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "airtimeFairness":
            suggest = "airtime_fairness"
        elif key == "apHandoff":
            suggest = "ap_handoff"
        elif key == "apSnifferAddr":
            suggest = "ap_sniffer_addr"
        elif key == "apSnifferBufsize":
            suggest = "ap_sniffer_bufsize"
        elif key == "apSnifferChan":
            suggest = "ap_sniffer_chan"
        elif key == "apSnifferCtl":
            suggest = "ap_sniffer_ctl"
        elif key == "apSnifferData":
            suggest = "ap_sniffer_data"
        elif key == "apSnifferMgmtBeacon":
            suggest = "ap_sniffer_mgmt_beacon"
        elif key == "apSnifferMgmtOther":
            suggest = "ap_sniffer_mgmt_other"
        elif key == "apSnifferMgmtProbe":
            suggest = "ap_sniffer_mgmt_probe"
        elif key == "arrpProfile":
            suggest = "arrp_profile"
        elif key == "autoPowerHigh":
            suggest = "auto_power_high"
        elif key == "autoPowerLevel":
            suggest = "auto_power_level"
        elif key == "autoPowerLow":
            suggest = "auto_power_low"
        elif key == "autoPowerTarget":
            suggest = "auto_power_target"
        elif key == "band5gType":
            suggest = "band5g_type"
        elif key == "bandwidthAdmissionControl":
            suggest = "bandwidth_admission_control"
        elif key == "bandwidthCapacity":
            suggest = "bandwidth_capacity"
        elif key == "beaconInterval":
            suggest = "beacon_interval"
        elif key == "bssColor":
            suggest = "bss_color"
        elif key == "bssColorMode":
            suggest = "bss_color_mode"
        elif key == "callAdmissionControl":
            suggest = "call_admission_control"
        elif key == "callCapacity":
            suggest = "call_capacity"
        elif key == "channelBonding":
            suggest = "channel_bonding"
        elif key == "channelUtilization":
            suggest = "channel_utilization"
        elif key == "drmaSensitivity":
            suggest = "drma_sensitivity"
        elif key == "fragThreshold":
            suggest = "frag_threshold"
        elif key == "frequencyHandoff":
            suggest = "frequency_handoff"
        elif key == "iperfProtocol":
            suggest = "iperf_protocol"
        elif key == "iperfServerPort":
            suggest = "iperf_server_port"
        elif key == "maxClients":
            suggest = "max_clients"
        elif key == "maxDistance":
            suggest = "max_distance"
        elif key == "mimoMode":
            suggest = "mimo_mode"
        elif key == "optionalAntenna":
            suggest = "optional_antenna"
        elif key == "optionalAntennaGain":
            suggest = "optional_antenna_gain"
        elif key == "powerLevel":
            suggest = "power_level"
        elif key == "powerMode":
            suggest = "power_mode"
        elif key == "powerValue":
            suggest = "power_value"
        elif key == "powersaveOptimize":
            suggest = "powersave_optimize"
        elif key == "protectionMode":
            suggest = "protection_mode"
        elif key == "radioId":
            suggest = "radio_id"
        elif key == "rtsThreshold":
            suggest = "rts_threshold"
        elif key == "samBssid":
            suggest = "sam_bssid"
        elif key == "samCaCertificate":
            suggest = "sam_ca_certificate"
        elif key == "samCaptivePortal":
            suggest = "sam_captive_portal"
        elif key == "samClientCertificate":
            suggest = "sam_client_certificate"
        elif key == "samCwpFailureString":
            suggest = "sam_cwp_failure_string"
        elif key == "samCwpMatchString":
            suggest = "sam_cwp_match_string"
        elif key == "samCwpPassword":
            suggest = "sam_cwp_password"
        elif key == "samCwpSuccessString":
            suggest = "sam_cwp_success_string"
        elif key == "samCwpTestUrl":
            suggest = "sam_cwp_test_url"
        elif key == "samCwpUsername":
            suggest = "sam_cwp_username"
        elif key == "samEapMethod":
            suggest = "sam_eap_method"
        elif key == "samPassword":
            suggest = "sam_password"
        elif key == "samPrivateKey":
            suggest = "sam_private_key"
        elif key == "samPrivateKeyPassword":
            suggest = "sam_private_key_password"
        elif key == "samReportIntv":
            suggest = "sam_report_intv"
        elif key == "samSecurityType":
            suggest = "sam_security_type"
        elif key == "samServerFqdn":
            suggest = "sam_server_fqdn"
        elif key == "samServerIp":
            suggest = "sam_server_ip"
        elif key == "samServerType":
            suggest = "sam_server_type"
        elif key == "samSsid":
            suggest = "sam_ssid"
        elif key == "samTest":
            suggest = "sam_test"
        elif key == "samUsername":
            suggest = "sam_username"
        elif key == "shortGuardInterval":
            suggest = "short_guard_interval"
        elif key == "spectrumAnalysis":
            suggest = "spectrum_analysis"
        elif key == "transmitOptimize":
            suggest = "transmit_optimize"
        elif key == "vapAll":
            suggest = "vap_all"
        elif key == "widsProfile":
            suggest = "wids_profile"
        elif key == "zeroWaitDfs":
            suggest = "zero_wait_dfs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpprofileRadio1. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpprofileRadio1.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpprofileRadio1.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 airtime_fairness: Optional[str] = None,
                 amsdu: Optional[str] = None,
                 ap_handoff: Optional[str] = None,
                 ap_sniffer_addr: Optional[str] = None,
                 ap_sniffer_bufsize: Optional[int] = None,
                 ap_sniffer_chan: Optional[int] = None,
                 ap_sniffer_ctl: Optional[str] = None,
                 ap_sniffer_data: Optional[str] = None,
                 ap_sniffer_mgmt_beacon: Optional[str] = None,
                 ap_sniffer_mgmt_other: Optional[str] = None,
                 ap_sniffer_mgmt_probe: Optional[str] = None,
                 arrp_profile: Optional[str] = None,
                 auto_power_high: Optional[int] = None,
                 auto_power_level: Optional[str] = None,
                 auto_power_low: Optional[int] = None,
                 auto_power_target: Optional[str] = None,
                 band: Optional[str] = None,
                 band5g_type: Optional[str] = None,
                 bandwidth_admission_control: Optional[str] = None,
                 bandwidth_capacity: Optional[int] = None,
                 beacon_interval: Optional[int] = None,
                 bss_color: Optional[int] = None,
                 bss_color_mode: Optional[str] = None,
                 call_admission_control: Optional[str] = None,
                 call_capacity: Optional[int] = None,
                 channel_bonding: Optional[str] = None,
                 channel_utilization: Optional[str] = None,
                 channels: Optional[Sequence['outputs.WtpprofileRadio1Channel']] = None,
                 coexistence: Optional[str] = None,
                 darrp: Optional[str] = None,
                 drma: Optional[str] = None,
                 drma_sensitivity: Optional[str] = None,
                 dtim: Optional[int] = None,
                 frag_threshold: Optional[int] = None,
                 frequency_handoff: Optional[str] = None,
                 iperf_protocol: Optional[str] = None,
                 iperf_server_port: Optional[int] = None,
                 max_clients: Optional[int] = None,
                 max_distance: Optional[int] = None,
                 mimo_mode: Optional[str] = None,
                 mode: Optional[str] = None,
                 n80211d: Optional[str] = None,
                 optional_antenna: Optional[str] = None,
                 optional_antenna_gain: Optional[str] = None,
                 power_level: Optional[int] = None,
                 power_mode: Optional[str] = None,
                 power_value: Optional[int] = None,
                 powersave_optimize: Optional[str] = None,
                 protection_mode: Optional[str] = None,
                 radio_id: Optional[int] = None,
                 rts_threshold: Optional[int] = None,
                 sam_bssid: Optional[str] = None,
                 sam_ca_certificate: Optional[str] = None,
                 sam_captive_portal: Optional[str] = None,
                 sam_client_certificate: Optional[str] = None,
                 sam_cwp_failure_string: Optional[str] = None,
                 sam_cwp_match_string: Optional[str] = None,
                 sam_cwp_password: Optional[str] = None,
                 sam_cwp_success_string: Optional[str] = None,
                 sam_cwp_test_url: Optional[str] = None,
                 sam_cwp_username: Optional[str] = None,
                 sam_eap_method: Optional[str] = None,
                 sam_password: Optional[str] = None,
                 sam_private_key: Optional[str] = None,
                 sam_private_key_password: Optional[str] = None,
                 sam_report_intv: Optional[int] = None,
                 sam_security_type: Optional[str] = None,
                 sam_server_fqdn: Optional[str] = None,
                 sam_server_ip: Optional[str] = None,
                 sam_server_type: Optional[str] = None,
                 sam_ssid: Optional[str] = None,
                 sam_test: Optional[str] = None,
                 sam_username: Optional[str] = None,
                 short_guard_interval: Optional[str] = None,
                 spectrum_analysis: Optional[str] = None,
                 transmit_optimize: Optional[str] = None,
                 vap_all: Optional[str] = None,
                 vaps: Optional[Sequence['outputs.WtpprofileRadio1Vap']] = None,
                 wids_profile: Optional[str] = None,
                 zero_wait_dfs: Optional[str] = None):
        """
        :param str airtime_fairness: Enable/disable airtime fairness (default = disable). Valid values: `enable`, `disable`.
        :param str amsdu: Enable/disable 802.11n AMSDU support. AMSDU can improve performance if supported by your WiFi clients (default = enable). Valid values: `enable`, `disable`.
        :param str ap_handoff: Enable/disable AP handoff of clients to other APs (default = disable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_addr: MAC address to monitor.
        :param int ap_sniffer_bufsize: Sniffer buffer size (1 - 32 MB, default = 16).
        :param int ap_sniffer_chan: Channel on which to operate the sniffer (default = 6).
        :param str ap_sniffer_ctl: Enable/disable sniffer on WiFi control frame (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_data: Enable/disable sniffer on WiFi data frame (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_mgmt_beacon: Enable/disable sniffer on WiFi management Beacon frames (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_mgmt_other: Enable/disable sniffer on WiFi management other frames  (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_mgmt_probe: Enable/disable sniffer on WiFi management probe frames (default = enable). Valid values: `enable`, `disable`.
        :param str arrp_profile: Distributed Automatic Radio Resource Provisioning (DARRP) profile name to assign to the radio.
        :param int auto_power_high: The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_level: Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        :param int auto_power_low: The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_target: The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        :param str band: WiFi band that Radio 3 operates on.
        :param str band5g_type: WiFi 5G band type. Valid values: `5g-full`, `5g-high`, `5g-low`.
        :param str bandwidth_admission_control: Enable/disable WiFi multimedia (WMM) bandwidth admission control to optimize WiFi bandwidth use. A request to join the wireless network is only allowed if the access point has enough bandwidth to support it. Valid values: `enable`, `disable`.
        :param int bandwidth_capacity: Maximum bandwidth capacity allowed (1 - 600000 Kbps, default = 2000).
        :param int beacon_interval: Beacon interval. The time between beacon frames in msec (the actual range of beacon interval depends on the AP platform type, default = 100).
        :param int bss_color: BSS color value for this 11ax radio (0 - 63, 0 means disable. default = 0).
        :param str bss_color_mode: BSS color mode for this 11ax radio (default = auto). Valid values: `auto`, `static`.
        :param str call_admission_control: Enable/disable WiFi multimedia (WMM) call admission control to optimize WiFi bandwidth use for VoIP calls. New VoIP calls are only accepted if there is enough bandwidth available to support them. Valid values: `enable`, `disable`.
        :param int call_capacity: Maximum number of Voice over WLAN (VoWLAN) phones supported by the radio (0 - 60, default = 10).
        :param str channel_bonding: Channel bandwidth: 160,80, 40, or 20MHz. Channels may use both 20 and 40 by enabling coexistence. Valid values: `160MHz`, `80MHz`, `40MHz`, `20MHz`.
        :param str channel_utilization: Enable/disable measuring channel utilization. Valid values: `enable`, `disable`.
        :param Sequence['WtpprofileRadio1ChannelArgs'] channels: Selected list of wireless radio channels. The structure of `channel` block is documented below.
        :param str coexistence: Enable/disable allowing both HT20 and HT40 on the same radio (default = enable). Valid values: `enable`, `disable`.
        :param str darrp: Enable/disable Distributed Automatic Radio Resource Provisioning (DARRP) to make sure the radio is always using the most optimal channel (default = disable). Valid values: `enable`, `disable`.
        :param str drma: Enable/disable dynamic radio mode assignment (DRMA) (default = disable). Valid values: `disable`, `enable`.
        :param str drma_sensitivity: Network Coverage Factor (NCF) percentage required to consider a radio as redundant (default = low). Valid values: `low`, `medium`, `high`.
        :param int dtim: Delivery Traffic Indication Map (DTIM) period (1 - 255, default = 1). Set higher to save battery life of WiFi client in power-save mode.
        :param int frag_threshold: Maximum packet size that can be sent without fragmentation (800 - 2346 bytes, default = 2346).
        :param str frequency_handoff: Enable/disable frequency handoff of clients to other channels (default = disable). Valid values: `enable`, `disable`.
        :param str iperf_protocol: Iperf test protocol (default = "UDP"). Valid values: `udp`, `tcp`.
        :param int iperf_server_port: Iperf service port number.
        :param int max_clients: Maximum number of stations (STAs) supported by the WTP (default = 0, meaning no client limitation).
        :param int max_distance: Maximum expected distance between the AP and clients (0 - 54000 m, default = 0).
        :param str mimo_mode: Configure radio MIMO mode (default = default). Valid values: `default`, `1x1`, `2x2`, `3x3`, `4x4`, `8x8`.
        :param str mode: Mode of radio 3. Radio 3 can be disabled, configured as an access point, a rogue AP monitor, or a sniffer.
        :param str n80211d: Enable/disable 802.11d countryie(default = enable). Valid values: `enable`, `disable`.
        :param str optional_antenna: Optional antenna used on FAP (default = none).
        :param str optional_antenna_gain: Optional antenna gain in dBi (0 to 20, default = 0).
        :param int power_level: Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        :param str power_mode: Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        :param int power_value: Radio EIRP power in dBm (1 - 33, default = 27).
        :param str powersave_optimize: Enable client power-saving features such as TIM, AC VO, and OBSS etc. Valid values: `tim`, `ac-vo`, `no-obss-scan`, `no-11b-rate`, `client-rate-follow`.
        :param str protection_mode: Enable/disable 802.11g protection modes to support backwards compatibility with older clients (rtscts, ctsonly, disable). Valid values: `rtscts`, `ctsonly`, `disable`.
        :param int radio_id: radio-id
        :param int rts_threshold: Maximum packet size for RTS transmissions, specifying the maximum size of a data packet before RTS/CTS (256 - 2346 bytes, default = 2346).
        :param str sam_bssid: BSSID for WiFi network.
        :param str sam_ca_certificate: CA certificate for WPA2/WPA3-ENTERPRISE.
        :param str sam_captive_portal: Enable/disable Captive Portal Authentication (default = disable). Valid values: `enable`, `disable`.
        :param str sam_client_certificate: Client certificate for WPA2/WPA3-ENTERPRISE.
        :param str sam_cwp_failure_string: Failure identification on the page after an incorrect login.
        :param str sam_cwp_match_string: Identification string from the captive portal login form.
        :param str sam_cwp_password: Password for captive portal authentication.
        :param str sam_cwp_success_string: Success identification on the page after a successful login.
        :param str sam_cwp_test_url: Website the client is trying to access.
        :param str sam_cwp_username: Username for captive portal authentication.
        :param str sam_eap_method: Select WPA2/WPA3-ENTERPRISE EAP Method (default = PEAP). Valid values: `both`, `tls`, `peap`.
        :param str sam_password: Passphrase for WiFi network connection.
        :param str sam_private_key: Private key for WPA2/WPA3-ENTERPRISE.
        :param str sam_private_key_password: Password for private key file for WPA2/WPA3-ENTERPRISE.
        :param int sam_report_intv: SAM report interval (sec), 0 for a one-time report.
        :param str sam_security_type: Select WiFi network security type (default = "wpa-personal").
        :param str sam_server_fqdn: SAM test server domain name.
        :param str sam_server_ip: SAM test server IP address.
        :param str sam_server_type: Select SAM server type (default = "IP"). Valid values: `ip`, `fqdn`.
        :param str sam_ssid: SSID for WiFi network.
        :param str sam_test: Select SAM test type (default = "PING"). Valid values: `ping`, `iperf`.
        :param str sam_username: Username for WiFi network connection.
        :param str short_guard_interval: Use either the short guard interval (Short GI) of 400 ns or the long guard interval (Long GI) of 800 ns. Valid values: `enable`, `disable`.
        :param str spectrum_analysis: Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        :param str transmit_optimize: Packet transmission optimization options including power saving, aggregation limiting, retry limiting, etc. All are enabled by default. Valid values: `disable`, `power-save`, `aggr-limit`, `retry-limit`, `send-bar`.
        :param str vap_all: Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        :param Sequence['WtpprofileRadio1VapArgs'] vaps: Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        :param str wids_profile: Wireless Intrusion Detection System (WIDS) profile name to assign to the radio.
        :param str zero_wait_dfs: Enable/disable zero wait DFS on radio (default = enable). Valid values: `enable`, `disable`.
        """
        if airtime_fairness is not None:
            pulumi.set(__self__, "airtime_fairness", airtime_fairness)
        if amsdu is not None:
            pulumi.set(__self__, "amsdu", amsdu)
        if ap_handoff is not None:
            pulumi.set(__self__, "ap_handoff", ap_handoff)
        if ap_sniffer_addr is not None:
            pulumi.set(__self__, "ap_sniffer_addr", ap_sniffer_addr)
        if ap_sniffer_bufsize is not None:
            pulumi.set(__self__, "ap_sniffer_bufsize", ap_sniffer_bufsize)
        if ap_sniffer_chan is not None:
            pulumi.set(__self__, "ap_sniffer_chan", ap_sniffer_chan)
        if ap_sniffer_ctl is not None:
            pulumi.set(__self__, "ap_sniffer_ctl", ap_sniffer_ctl)
        if ap_sniffer_data is not None:
            pulumi.set(__self__, "ap_sniffer_data", ap_sniffer_data)
        if ap_sniffer_mgmt_beacon is not None:
            pulumi.set(__self__, "ap_sniffer_mgmt_beacon", ap_sniffer_mgmt_beacon)
        if ap_sniffer_mgmt_other is not None:
            pulumi.set(__self__, "ap_sniffer_mgmt_other", ap_sniffer_mgmt_other)
        if ap_sniffer_mgmt_probe is not None:
            pulumi.set(__self__, "ap_sniffer_mgmt_probe", ap_sniffer_mgmt_probe)
        if arrp_profile is not None:
            pulumi.set(__self__, "arrp_profile", arrp_profile)
        if auto_power_high is not None:
            pulumi.set(__self__, "auto_power_high", auto_power_high)
        if auto_power_level is not None:
            pulumi.set(__self__, "auto_power_level", auto_power_level)
        if auto_power_low is not None:
            pulumi.set(__self__, "auto_power_low", auto_power_low)
        if auto_power_target is not None:
            pulumi.set(__self__, "auto_power_target", auto_power_target)
        if band is not None:
            pulumi.set(__self__, "band", band)
        if band5g_type is not None:
            pulumi.set(__self__, "band5g_type", band5g_type)
        if bandwidth_admission_control is not None:
            pulumi.set(__self__, "bandwidth_admission_control", bandwidth_admission_control)
        if bandwidth_capacity is not None:
            pulumi.set(__self__, "bandwidth_capacity", bandwidth_capacity)
        if beacon_interval is not None:
            pulumi.set(__self__, "beacon_interval", beacon_interval)
        if bss_color is not None:
            pulumi.set(__self__, "bss_color", bss_color)
        if bss_color_mode is not None:
            pulumi.set(__self__, "bss_color_mode", bss_color_mode)
        if call_admission_control is not None:
            pulumi.set(__self__, "call_admission_control", call_admission_control)
        if call_capacity is not None:
            pulumi.set(__self__, "call_capacity", call_capacity)
        if channel_bonding is not None:
            pulumi.set(__self__, "channel_bonding", channel_bonding)
        if channel_utilization is not None:
            pulumi.set(__self__, "channel_utilization", channel_utilization)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if coexistence is not None:
            pulumi.set(__self__, "coexistence", coexistence)
        if darrp is not None:
            pulumi.set(__self__, "darrp", darrp)
        if drma is not None:
            pulumi.set(__self__, "drma", drma)
        if drma_sensitivity is not None:
            pulumi.set(__self__, "drma_sensitivity", drma_sensitivity)
        if dtim is not None:
            pulumi.set(__self__, "dtim", dtim)
        if frag_threshold is not None:
            pulumi.set(__self__, "frag_threshold", frag_threshold)
        if frequency_handoff is not None:
            pulumi.set(__self__, "frequency_handoff", frequency_handoff)
        if iperf_protocol is not None:
            pulumi.set(__self__, "iperf_protocol", iperf_protocol)
        if iperf_server_port is not None:
            pulumi.set(__self__, "iperf_server_port", iperf_server_port)
        if max_clients is not None:
            pulumi.set(__self__, "max_clients", max_clients)
        if max_distance is not None:
            pulumi.set(__self__, "max_distance", max_distance)
        if mimo_mode is not None:
            pulumi.set(__self__, "mimo_mode", mimo_mode)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if n80211d is not None:
            pulumi.set(__self__, "n80211d", n80211d)
        if optional_antenna is not None:
            pulumi.set(__self__, "optional_antenna", optional_antenna)
        if optional_antenna_gain is not None:
            pulumi.set(__self__, "optional_antenna_gain", optional_antenna_gain)
        if power_level is not None:
            pulumi.set(__self__, "power_level", power_level)
        if power_mode is not None:
            pulumi.set(__self__, "power_mode", power_mode)
        if power_value is not None:
            pulumi.set(__self__, "power_value", power_value)
        if powersave_optimize is not None:
            pulumi.set(__self__, "powersave_optimize", powersave_optimize)
        if protection_mode is not None:
            pulumi.set(__self__, "protection_mode", protection_mode)
        if radio_id is not None:
            pulumi.set(__self__, "radio_id", radio_id)
        if rts_threshold is not None:
            pulumi.set(__self__, "rts_threshold", rts_threshold)
        if sam_bssid is not None:
            pulumi.set(__self__, "sam_bssid", sam_bssid)
        if sam_ca_certificate is not None:
            pulumi.set(__self__, "sam_ca_certificate", sam_ca_certificate)
        if sam_captive_portal is not None:
            pulumi.set(__self__, "sam_captive_portal", sam_captive_portal)
        if sam_client_certificate is not None:
            pulumi.set(__self__, "sam_client_certificate", sam_client_certificate)
        if sam_cwp_failure_string is not None:
            pulumi.set(__self__, "sam_cwp_failure_string", sam_cwp_failure_string)
        if sam_cwp_match_string is not None:
            pulumi.set(__self__, "sam_cwp_match_string", sam_cwp_match_string)
        if sam_cwp_password is not None:
            pulumi.set(__self__, "sam_cwp_password", sam_cwp_password)
        if sam_cwp_success_string is not None:
            pulumi.set(__self__, "sam_cwp_success_string", sam_cwp_success_string)
        if sam_cwp_test_url is not None:
            pulumi.set(__self__, "sam_cwp_test_url", sam_cwp_test_url)
        if sam_cwp_username is not None:
            pulumi.set(__self__, "sam_cwp_username", sam_cwp_username)
        if sam_eap_method is not None:
            pulumi.set(__self__, "sam_eap_method", sam_eap_method)
        if sam_password is not None:
            pulumi.set(__self__, "sam_password", sam_password)
        if sam_private_key is not None:
            pulumi.set(__self__, "sam_private_key", sam_private_key)
        if sam_private_key_password is not None:
            pulumi.set(__self__, "sam_private_key_password", sam_private_key_password)
        if sam_report_intv is not None:
            pulumi.set(__self__, "sam_report_intv", sam_report_intv)
        if sam_security_type is not None:
            pulumi.set(__self__, "sam_security_type", sam_security_type)
        if sam_server_fqdn is not None:
            pulumi.set(__self__, "sam_server_fqdn", sam_server_fqdn)
        if sam_server_ip is not None:
            pulumi.set(__self__, "sam_server_ip", sam_server_ip)
        if sam_server_type is not None:
            pulumi.set(__self__, "sam_server_type", sam_server_type)
        if sam_ssid is not None:
            pulumi.set(__self__, "sam_ssid", sam_ssid)
        if sam_test is not None:
            pulumi.set(__self__, "sam_test", sam_test)
        if sam_username is not None:
            pulumi.set(__self__, "sam_username", sam_username)
        if short_guard_interval is not None:
            pulumi.set(__self__, "short_guard_interval", short_guard_interval)
        if spectrum_analysis is not None:
            pulumi.set(__self__, "spectrum_analysis", spectrum_analysis)
        if transmit_optimize is not None:
            pulumi.set(__self__, "transmit_optimize", transmit_optimize)
        if vap_all is not None:
            pulumi.set(__self__, "vap_all", vap_all)
        if vaps is not None:
            pulumi.set(__self__, "vaps", vaps)
        if wids_profile is not None:
            pulumi.set(__self__, "wids_profile", wids_profile)
        if zero_wait_dfs is not None:
            pulumi.set(__self__, "zero_wait_dfs", zero_wait_dfs)

    @property
    @pulumi.getter(name="airtimeFairness")
    def airtime_fairness(self) -> Optional[str]:
        """
        Enable/disable airtime fairness (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "airtime_fairness")

    @property
    @pulumi.getter
    def amsdu(self) -> Optional[str]:
        """
        Enable/disable 802.11n AMSDU support. AMSDU can improve performance if supported by your WiFi clients (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "amsdu")

    @property
    @pulumi.getter(name="apHandoff")
    def ap_handoff(self) -> Optional[str]:
        """
        Enable/disable AP handoff of clients to other APs (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_handoff")

    @property
    @pulumi.getter(name="apSnifferAddr")
    def ap_sniffer_addr(self) -> Optional[str]:
        """
        MAC address to monitor.
        """
        return pulumi.get(self, "ap_sniffer_addr")

    @property
    @pulumi.getter(name="apSnifferBufsize")
    def ap_sniffer_bufsize(self) -> Optional[int]:
        """
        Sniffer buffer size (1 - 32 MB, default = 16).
        """
        return pulumi.get(self, "ap_sniffer_bufsize")

    @property
    @pulumi.getter(name="apSnifferChan")
    def ap_sniffer_chan(self) -> Optional[int]:
        """
        Channel on which to operate the sniffer (default = 6).
        """
        return pulumi.get(self, "ap_sniffer_chan")

    @property
    @pulumi.getter(name="apSnifferCtl")
    def ap_sniffer_ctl(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi control frame (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_ctl")

    @property
    @pulumi.getter(name="apSnifferData")
    def ap_sniffer_data(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi data frame (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_data")

    @property
    @pulumi.getter(name="apSnifferMgmtBeacon")
    def ap_sniffer_mgmt_beacon(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi management Beacon frames (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_mgmt_beacon")

    @property
    @pulumi.getter(name="apSnifferMgmtOther")
    def ap_sniffer_mgmt_other(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi management other frames  (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_mgmt_other")

    @property
    @pulumi.getter(name="apSnifferMgmtProbe")
    def ap_sniffer_mgmt_probe(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi management probe frames (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_mgmt_probe")

    @property
    @pulumi.getter(name="arrpProfile")
    def arrp_profile(self) -> Optional[str]:
        """
        Distributed Automatic Radio Resource Provisioning (DARRP) profile name to assign to the radio.
        """
        return pulumi.get(self, "arrp_profile")

    @property
    @pulumi.getter(name="autoPowerHigh")
    def auto_power_high(self) -> Optional[int]:
        """
        The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_high")

    @property
    @pulumi.getter(name="autoPowerLevel")
    def auto_power_level(self) -> Optional[str]:
        """
        Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "auto_power_level")

    @property
    @pulumi.getter(name="autoPowerLow")
    def auto_power_low(self) -> Optional[int]:
        """
        The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_low")

    @property
    @pulumi.getter(name="autoPowerTarget")
    def auto_power_target(self) -> Optional[str]:
        """
        The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        """
        return pulumi.get(self, "auto_power_target")

    @property
    @pulumi.getter
    def band(self) -> Optional[str]:
        """
        WiFi band that Radio 3 operates on.
        """
        return pulumi.get(self, "band")

    @property
    @pulumi.getter(name="band5gType")
    def band5g_type(self) -> Optional[str]:
        """
        WiFi 5G band type. Valid values: `5g-full`, `5g-high`, `5g-low`.
        """
        return pulumi.get(self, "band5g_type")

    @property
    @pulumi.getter(name="bandwidthAdmissionControl")
    def bandwidth_admission_control(self) -> Optional[str]:
        """
        Enable/disable WiFi multimedia (WMM) bandwidth admission control to optimize WiFi bandwidth use. A request to join the wireless network is only allowed if the access point has enough bandwidth to support it. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "bandwidth_admission_control")

    @property
    @pulumi.getter(name="bandwidthCapacity")
    def bandwidth_capacity(self) -> Optional[int]:
        """
        Maximum bandwidth capacity allowed (1 - 600000 Kbps, default = 2000).
        """
        return pulumi.get(self, "bandwidth_capacity")

    @property
    @pulumi.getter(name="beaconInterval")
    def beacon_interval(self) -> Optional[int]:
        """
        Beacon interval. The time between beacon frames in msec (the actual range of beacon interval depends on the AP platform type, default = 100).
        """
        return pulumi.get(self, "beacon_interval")

    @property
    @pulumi.getter(name="bssColor")
    def bss_color(self) -> Optional[int]:
        """
        BSS color value for this 11ax radio (0 - 63, 0 means disable. default = 0).
        """
        return pulumi.get(self, "bss_color")

    @property
    @pulumi.getter(name="bssColorMode")
    def bss_color_mode(self) -> Optional[str]:
        """
        BSS color mode for this 11ax radio (default = auto). Valid values: `auto`, `static`.
        """
        return pulumi.get(self, "bss_color_mode")

    @property
    @pulumi.getter(name="callAdmissionControl")
    def call_admission_control(self) -> Optional[str]:
        """
        Enable/disable WiFi multimedia (WMM) call admission control to optimize WiFi bandwidth use for VoIP calls. New VoIP calls are only accepted if there is enough bandwidth available to support them. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "call_admission_control")

    @property
    @pulumi.getter(name="callCapacity")
    def call_capacity(self) -> Optional[int]:
        """
        Maximum number of Voice over WLAN (VoWLAN) phones supported by the radio (0 - 60, default = 10).
        """
        return pulumi.get(self, "call_capacity")

    @property
    @pulumi.getter(name="channelBonding")
    def channel_bonding(self) -> Optional[str]:
        """
        Channel bandwidth: 160,80, 40, or 20MHz. Channels may use both 20 and 40 by enabling coexistence. Valid values: `160MHz`, `80MHz`, `40MHz`, `20MHz`.
        """
        return pulumi.get(self, "channel_bonding")

    @property
    @pulumi.getter(name="channelUtilization")
    def channel_utilization(self) -> Optional[str]:
        """
        Enable/disable measuring channel utilization. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "channel_utilization")

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.WtpprofileRadio1Channel']]:
        """
        Selected list of wireless radio channels. The structure of `channel` block is documented below.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter
    def coexistence(self) -> Optional[str]:
        """
        Enable/disable allowing both HT20 and HT40 on the same radio (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "coexistence")

    @property
    @pulumi.getter
    def darrp(self) -> Optional[str]:
        """
        Enable/disable Distributed Automatic Radio Resource Provisioning (DARRP) to make sure the radio is always using the most optimal channel (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "darrp")

    @property
    @pulumi.getter
    def drma(self) -> Optional[str]:
        """
        Enable/disable dynamic radio mode assignment (DRMA) (default = disable). Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "drma")

    @property
    @pulumi.getter(name="drmaSensitivity")
    def drma_sensitivity(self) -> Optional[str]:
        """
        Network Coverage Factor (NCF) percentage required to consider a radio as redundant (default = low). Valid values: `low`, `medium`, `high`.
        """
        return pulumi.get(self, "drma_sensitivity")

    @property
    @pulumi.getter
    def dtim(self) -> Optional[int]:
        """
        Delivery Traffic Indication Map (DTIM) period (1 - 255, default = 1). Set higher to save battery life of WiFi client in power-save mode.
        """
        return pulumi.get(self, "dtim")

    @property
    @pulumi.getter(name="fragThreshold")
    def frag_threshold(self) -> Optional[int]:
        """
        Maximum packet size that can be sent without fragmentation (800 - 2346 bytes, default = 2346).
        """
        return pulumi.get(self, "frag_threshold")

    @property
    @pulumi.getter(name="frequencyHandoff")
    def frequency_handoff(self) -> Optional[str]:
        """
        Enable/disable frequency handoff of clients to other channels (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "frequency_handoff")

    @property
    @pulumi.getter(name="iperfProtocol")
    def iperf_protocol(self) -> Optional[str]:
        """
        Iperf test protocol (default = "UDP"). Valid values: `udp`, `tcp`.
        """
        return pulumi.get(self, "iperf_protocol")

    @property
    @pulumi.getter(name="iperfServerPort")
    def iperf_server_port(self) -> Optional[int]:
        """
        Iperf service port number.
        """
        return pulumi.get(self, "iperf_server_port")

    @property
    @pulumi.getter(name="maxClients")
    def max_clients(self) -> Optional[int]:
        """
        Maximum number of stations (STAs) supported by the WTP (default = 0, meaning no client limitation).
        """
        return pulumi.get(self, "max_clients")

    @property
    @pulumi.getter(name="maxDistance")
    def max_distance(self) -> Optional[int]:
        """
        Maximum expected distance between the AP and clients (0 - 54000 m, default = 0).
        """
        return pulumi.get(self, "max_distance")

    @property
    @pulumi.getter(name="mimoMode")
    def mimo_mode(self) -> Optional[str]:
        """
        Configure radio MIMO mode (default = default). Valid values: `default`, `1x1`, `2x2`, `3x3`, `4x4`, `8x8`.
        """
        return pulumi.get(self, "mimo_mode")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mode of radio 3. Radio 3 can be disabled, configured as an access point, a rogue AP monitor, or a sniffer.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def n80211d(self) -> Optional[str]:
        """
        Enable/disable 802.11d countryie(default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "n80211d")

    @property
    @pulumi.getter(name="optionalAntenna")
    def optional_antenna(self) -> Optional[str]:
        """
        Optional antenna used on FAP (default = none).
        """
        return pulumi.get(self, "optional_antenna")

    @property
    @pulumi.getter(name="optionalAntennaGain")
    def optional_antenna_gain(self) -> Optional[str]:
        """
        Optional antenna gain in dBi (0 to 20, default = 0).
        """
        return pulumi.get(self, "optional_antenna_gain")

    @property
    @pulumi.getter(name="powerLevel")
    def power_level(self) -> Optional[int]:
        """
        Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        """
        return pulumi.get(self, "power_level")

    @property
    @pulumi.getter(name="powerMode")
    def power_mode(self) -> Optional[str]:
        """
        Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        """
        return pulumi.get(self, "power_mode")

    @property
    @pulumi.getter(name="powerValue")
    def power_value(self) -> Optional[int]:
        """
        Radio EIRP power in dBm (1 - 33, default = 27).
        """
        return pulumi.get(self, "power_value")

    @property
    @pulumi.getter(name="powersaveOptimize")
    def powersave_optimize(self) -> Optional[str]:
        """
        Enable client power-saving features such as TIM, AC VO, and OBSS etc. Valid values: `tim`, `ac-vo`, `no-obss-scan`, `no-11b-rate`, `client-rate-follow`.
        """
        return pulumi.get(self, "powersave_optimize")

    @property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> Optional[str]:
        """
        Enable/disable 802.11g protection modes to support backwards compatibility with older clients (rtscts, ctsonly, disable). Valid values: `rtscts`, `ctsonly`, `disable`.
        """
        return pulumi.get(self, "protection_mode")

    @property
    @pulumi.getter(name="radioId")
    def radio_id(self) -> Optional[int]:
        """
        radio-id
        """
        return pulumi.get(self, "radio_id")

    @property
    @pulumi.getter(name="rtsThreshold")
    def rts_threshold(self) -> Optional[int]:
        """
        Maximum packet size for RTS transmissions, specifying the maximum size of a data packet before RTS/CTS (256 - 2346 bytes, default = 2346).
        """
        return pulumi.get(self, "rts_threshold")

    @property
    @pulumi.getter(name="samBssid")
    def sam_bssid(self) -> Optional[str]:
        """
        BSSID for WiFi network.
        """
        return pulumi.get(self, "sam_bssid")

    @property
    @pulumi.getter(name="samCaCertificate")
    def sam_ca_certificate(self) -> Optional[str]:
        """
        CA certificate for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_ca_certificate")

    @property
    @pulumi.getter(name="samCaptivePortal")
    def sam_captive_portal(self) -> Optional[str]:
        """
        Enable/disable Captive Portal Authentication (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "sam_captive_portal")

    @property
    @pulumi.getter(name="samClientCertificate")
    def sam_client_certificate(self) -> Optional[str]:
        """
        Client certificate for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_client_certificate")

    @property
    @pulumi.getter(name="samCwpFailureString")
    def sam_cwp_failure_string(self) -> Optional[str]:
        """
        Failure identification on the page after an incorrect login.
        """
        return pulumi.get(self, "sam_cwp_failure_string")

    @property
    @pulumi.getter(name="samCwpMatchString")
    def sam_cwp_match_string(self) -> Optional[str]:
        """
        Identification string from the captive portal login form.
        """
        return pulumi.get(self, "sam_cwp_match_string")

    @property
    @pulumi.getter(name="samCwpPassword")
    def sam_cwp_password(self) -> Optional[str]:
        """
        Password for captive portal authentication.
        """
        return pulumi.get(self, "sam_cwp_password")

    @property
    @pulumi.getter(name="samCwpSuccessString")
    def sam_cwp_success_string(self) -> Optional[str]:
        """
        Success identification on the page after a successful login.
        """
        return pulumi.get(self, "sam_cwp_success_string")

    @property
    @pulumi.getter(name="samCwpTestUrl")
    def sam_cwp_test_url(self) -> Optional[str]:
        """
        Website the client is trying to access.
        """
        return pulumi.get(self, "sam_cwp_test_url")

    @property
    @pulumi.getter(name="samCwpUsername")
    def sam_cwp_username(self) -> Optional[str]:
        """
        Username for captive portal authentication.
        """
        return pulumi.get(self, "sam_cwp_username")

    @property
    @pulumi.getter(name="samEapMethod")
    def sam_eap_method(self) -> Optional[str]:
        """
        Select WPA2/WPA3-ENTERPRISE EAP Method (default = PEAP). Valid values: `both`, `tls`, `peap`.
        """
        return pulumi.get(self, "sam_eap_method")

    @property
    @pulumi.getter(name="samPassword")
    def sam_password(self) -> Optional[str]:
        """
        Passphrase for WiFi network connection.
        """
        return pulumi.get(self, "sam_password")

    @property
    @pulumi.getter(name="samPrivateKey")
    def sam_private_key(self) -> Optional[str]:
        """
        Private key for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_private_key")

    @property
    @pulumi.getter(name="samPrivateKeyPassword")
    def sam_private_key_password(self) -> Optional[str]:
        """
        Password for private key file for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_private_key_password")

    @property
    @pulumi.getter(name="samReportIntv")
    def sam_report_intv(self) -> Optional[int]:
        """
        SAM report interval (sec), 0 for a one-time report.
        """
        return pulumi.get(self, "sam_report_intv")

    @property
    @pulumi.getter(name="samSecurityType")
    def sam_security_type(self) -> Optional[str]:
        """
        Select WiFi network security type (default = "wpa-personal").
        """
        return pulumi.get(self, "sam_security_type")

    @property
    @pulumi.getter(name="samServerFqdn")
    def sam_server_fqdn(self) -> Optional[str]:
        """
        SAM test server domain name.
        """
        return pulumi.get(self, "sam_server_fqdn")

    @property
    @pulumi.getter(name="samServerIp")
    def sam_server_ip(self) -> Optional[str]:
        """
        SAM test server IP address.
        """
        return pulumi.get(self, "sam_server_ip")

    @property
    @pulumi.getter(name="samServerType")
    def sam_server_type(self) -> Optional[str]:
        """
        Select SAM server type (default = "IP"). Valid values: `ip`, `fqdn`.
        """
        return pulumi.get(self, "sam_server_type")

    @property
    @pulumi.getter(name="samSsid")
    def sam_ssid(self) -> Optional[str]:
        """
        SSID for WiFi network.
        """
        return pulumi.get(self, "sam_ssid")

    @property
    @pulumi.getter(name="samTest")
    def sam_test(self) -> Optional[str]:
        """
        Select SAM test type (default = "PING"). Valid values: `ping`, `iperf`.
        """
        return pulumi.get(self, "sam_test")

    @property
    @pulumi.getter(name="samUsername")
    def sam_username(self) -> Optional[str]:
        """
        Username for WiFi network connection.
        """
        return pulumi.get(self, "sam_username")

    @property
    @pulumi.getter(name="shortGuardInterval")
    def short_guard_interval(self) -> Optional[str]:
        """
        Use either the short guard interval (Short GI) of 400 ns or the long guard interval (Long GI) of 800 ns. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "short_guard_interval")

    @property
    @pulumi.getter(name="spectrumAnalysis")
    def spectrum_analysis(self) -> Optional[str]:
        """
        Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        """
        return pulumi.get(self, "spectrum_analysis")

    @property
    @pulumi.getter(name="transmitOptimize")
    def transmit_optimize(self) -> Optional[str]:
        """
        Packet transmission optimization options including power saving, aggregation limiting, retry limiting, etc. All are enabled by default. Valid values: `disable`, `power-save`, `aggr-limit`, `retry-limit`, `send-bar`.
        """
        return pulumi.get(self, "transmit_optimize")

    @property
    @pulumi.getter(name="vapAll")
    def vap_all(self) -> Optional[str]:
        """
        Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        """
        return pulumi.get(self, "vap_all")

    @property
    @pulumi.getter
    def vaps(self) -> Optional[Sequence['outputs.WtpprofileRadio1Vap']]:
        """
        Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        """
        return pulumi.get(self, "vaps")

    @property
    @pulumi.getter(name="widsProfile")
    def wids_profile(self) -> Optional[str]:
        """
        Wireless Intrusion Detection System (WIDS) profile name to assign to the radio.
        """
        return pulumi.get(self, "wids_profile")

    @property
    @pulumi.getter(name="zeroWaitDfs")
    def zero_wait_dfs(self) -> Optional[str]:
        """
        Enable/disable zero wait DFS on radio (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "zero_wait_dfs")


@pulumi.output_type
class WtpprofileRadio1Channel(dict):
    def __init__(__self__, *,
                 chan: Optional[str] = None):
        """
        :param str chan: Channel number.
        """
        if chan is not None:
            pulumi.set(__self__, "chan", chan)

    @property
    @pulumi.getter
    def chan(self) -> Optional[str]:
        """
        Channel number.
        """
        return pulumi.get(self, "chan")


@pulumi.output_type
class WtpprofileRadio1Vap(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Virtual Access Point (VAP) name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Virtual Access Point (VAP) name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WtpprofileRadio2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "airtimeFairness":
            suggest = "airtime_fairness"
        elif key == "apHandoff":
            suggest = "ap_handoff"
        elif key == "apSnifferAddr":
            suggest = "ap_sniffer_addr"
        elif key == "apSnifferBufsize":
            suggest = "ap_sniffer_bufsize"
        elif key == "apSnifferChan":
            suggest = "ap_sniffer_chan"
        elif key == "apSnifferCtl":
            suggest = "ap_sniffer_ctl"
        elif key == "apSnifferData":
            suggest = "ap_sniffer_data"
        elif key == "apSnifferMgmtBeacon":
            suggest = "ap_sniffer_mgmt_beacon"
        elif key == "apSnifferMgmtOther":
            suggest = "ap_sniffer_mgmt_other"
        elif key == "apSnifferMgmtProbe":
            suggest = "ap_sniffer_mgmt_probe"
        elif key == "arrpProfile":
            suggest = "arrp_profile"
        elif key == "autoPowerHigh":
            suggest = "auto_power_high"
        elif key == "autoPowerLevel":
            suggest = "auto_power_level"
        elif key == "autoPowerLow":
            suggest = "auto_power_low"
        elif key == "autoPowerTarget":
            suggest = "auto_power_target"
        elif key == "band5gType":
            suggest = "band5g_type"
        elif key == "bandwidthAdmissionControl":
            suggest = "bandwidth_admission_control"
        elif key == "bandwidthCapacity":
            suggest = "bandwidth_capacity"
        elif key == "beaconInterval":
            suggest = "beacon_interval"
        elif key == "bssColor":
            suggest = "bss_color"
        elif key == "bssColorMode":
            suggest = "bss_color_mode"
        elif key == "callAdmissionControl":
            suggest = "call_admission_control"
        elif key == "callCapacity":
            suggest = "call_capacity"
        elif key == "channelBonding":
            suggest = "channel_bonding"
        elif key == "channelUtilization":
            suggest = "channel_utilization"
        elif key == "drmaSensitivity":
            suggest = "drma_sensitivity"
        elif key == "fragThreshold":
            suggest = "frag_threshold"
        elif key == "frequencyHandoff":
            suggest = "frequency_handoff"
        elif key == "iperfProtocol":
            suggest = "iperf_protocol"
        elif key == "iperfServerPort":
            suggest = "iperf_server_port"
        elif key == "maxClients":
            suggest = "max_clients"
        elif key == "maxDistance":
            suggest = "max_distance"
        elif key == "mimoMode":
            suggest = "mimo_mode"
        elif key == "optionalAntenna":
            suggest = "optional_antenna"
        elif key == "optionalAntennaGain":
            suggest = "optional_antenna_gain"
        elif key == "powerLevel":
            suggest = "power_level"
        elif key == "powerMode":
            suggest = "power_mode"
        elif key == "powerValue":
            suggest = "power_value"
        elif key == "powersaveOptimize":
            suggest = "powersave_optimize"
        elif key == "protectionMode":
            suggest = "protection_mode"
        elif key == "radioId":
            suggest = "radio_id"
        elif key == "rtsThreshold":
            suggest = "rts_threshold"
        elif key == "samBssid":
            suggest = "sam_bssid"
        elif key == "samCaCertificate":
            suggest = "sam_ca_certificate"
        elif key == "samCaptivePortal":
            suggest = "sam_captive_portal"
        elif key == "samClientCertificate":
            suggest = "sam_client_certificate"
        elif key == "samCwpFailureString":
            suggest = "sam_cwp_failure_string"
        elif key == "samCwpMatchString":
            suggest = "sam_cwp_match_string"
        elif key == "samCwpPassword":
            suggest = "sam_cwp_password"
        elif key == "samCwpSuccessString":
            suggest = "sam_cwp_success_string"
        elif key == "samCwpTestUrl":
            suggest = "sam_cwp_test_url"
        elif key == "samCwpUsername":
            suggest = "sam_cwp_username"
        elif key == "samEapMethod":
            suggest = "sam_eap_method"
        elif key == "samPassword":
            suggest = "sam_password"
        elif key == "samPrivateKey":
            suggest = "sam_private_key"
        elif key == "samPrivateKeyPassword":
            suggest = "sam_private_key_password"
        elif key == "samReportIntv":
            suggest = "sam_report_intv"
        elif key == "samSecurityType":
            suggest = "sam_security_type"
        elif key == "samServerFqdn":
            suggest = "sam_server_fqdn"
        elif key == "samServerIp":
            suggest = "sam_server_ip"
        elif key == "samServerType":
            suggest = "sam_server_type"
        elif key == "samSsid":
            suggest = "sam_ssid"
        elif key == "samTest":
            suggest = "sam_test"
        elif key == "samUsername":
            suggest = "sam_username"
        elif key == "shortGuardInterval":
            suggest = "short_guard_interval"
        elif key == "spectrumAnalysis":
            suggest = "spectrum_analysis"
        elif key == "transmitOptimize":
            suggest = "transmit_optimize"
        elif key == "vapAll":
            suggest = "vap_all"
        elif key == "widsProfile":
            suggest = "wids_profile"
        elif key == "zeroWaitDfs":
            suggest = "zero_wait_dfs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpprofileRadio2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpprofileRadio2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpprofileRadio2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 airtime_fairness: Optional[str] = None,
                 amsdu: Optional[str] = None,
                 ap_handoff: Optional[str] = None,
                 ap_sniffer_addr: Optional[str] = None,
                 ap_sniffer_bufsize: Optional[int] = None,
                 ap_sniffer_chan: Optional[int] = None,
                 ap_sniffer_ctl: Optional[str] = None,
                 ap_sniffer_data: Optional[str] = None,
                 ap_sniffer_mgmt_beacon: Optional[str] = None,
                 ap_sniffer_mgmt_other: Optional[str] = None,
                 ap_sniffer_mgmt_probe: Optional[str] = None,
                 arrp_profile: Optional[str] = None,
                 auto_power_high: Optional[int] = None,
                 auto_power_level: Optional[str] = None,
                 auto_power_low: Optional[int] = None,
                 auto_power_target: Optional[str] = None,
                 band: Optional[str] = None,
                 band5g_type: Optional[str] = None,
                 bandwidth_admission_control: Optional[str] = None,
                 bandwidth_capacity: Optional[int] = None,
                 beacon_interval: Optional[int] = None,
                 bss_color: Optional[int] = None,
                 bss_color_mode: Optional[str] = None,
                 call_admission_control: Optional[str] = None,
                 call_capacity: Optional[int] = None,
                 channel_bonding: Optional[str] = None,
                 channel_utilization: Optional[str] = None,
                 channels: Optional[Sequence['outputs.WtpprofileRadio2Channel']] = None,
                 coexistence: Optional[str] = None,
                 darrp: Optional[str] = None,
                 drma: Optional[str] = None,
                 drma_sensitivity: Optional[str] = None,
                 dtim: Optional[int] = None,
                 frag_threshold: Optional[int] = None,
                 frequency_handoff: Optional[str] = None,
                 iperf_protocol: Optional[str] = None,
                 iperf_server_port: Optional[int] = None,
                 max_clients: Optional[int] = None,
                 max_distance: Optional[int] = None,
                 mimo_mode: Optional[str] = None,
                 mode: Optional[str] = None,
                 n80211d: Optional[str] = None,
                 optional_antenna: Optional[str] = None,
                 optional_antenna_gain: Optional[str] = None,
                 power_level: Optional[int] = None,
                 power_mode: Optional[str] = None,
                 power_value: Optional[int] = None,
                 powersave_optimize: Optional[str] = None,
                 protection_mode: Optional[str] = None,
                 radio_id: Optional[int] = None,
                 rts_threshold: Optional[int] = None,
                 sam_bssid: Optional[str] = None,
                 sam_ca_certificate: Optional[str] = None,
                 sam_captive_portal: Optional[str] = None,
                 sam_client_certificate: Optional[str] = None,
                 sam_cwp_failure_string: Optional[str] = None,
                 sam_cwp_match_string: Optional[str] = None,
                 sam_cwp_password: Optional[str] = None,
                 sam_cwp_success_string: Optional[str] = None,
                 sam_cwp_test_url: Optional[str] = None,
                 sam_cwp_username: Optional[str] = None,
                 sam_eap_method: Optional[str] = None,
                 sam_password: Optional[str] = None,
                 sam_private_key: Optional[str] = None,
                 sam_private_key_password: Optional[str] = None,
                 sam_report_intv: Optional[int] = None,
                 sam_security_type: Optional[str] = None,
                 sam_server_fqdn: Optional[str] = None,
                 sam_server_ip: Optional[str] = None,
                 sam_server_type: Optional[str] = None,
                 sam_ssid: Optional[str] = None,
                 sam_test: Optional[str] = None,
                 sam_username: Optional[str] = None,
                 short_guard_interval: Optional[str] = None,
                 spectrum_analysis: Optional[str] = None,
                 transmit_optimize: Optional[str] = None,
                 vap_all: Optional[str] = None,
                 vaps: Optional[Sequence['outputs.WtpprofileRadio2Vap']] = None,
                 wids_profile: Optional[str] = None,
                 zero_wait_dfs: Optional[str] = None):
        """
        :param str airtime_fairness: Enable/disable airtime fairness (default = disable). Valid values: `enable`, `disable`.
        :param str amsdu: Enable/disable 802.11n AMSDU support. AMSDU can improve performance if supported by your WiFi clients (default = enable). Valid values: `enable`, `disable`.
        :param str ap_handoff: Enable/disable AP handoff of clients to other APs (default = disable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_addr: MAC address to monitor.
        :param int ap_sniffer_bufsize: Sniffer buffer size (1 - 32 MB, default = 16).
        :param int ap_sniffer_chan: Channel on which to operate the sniffer (default = 6).
        :param str ap_sniffer_ctl: Enable/disable sniffer on WiFi control frame (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_data: Enable/disable sniffer on WiFi data frame (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_mgmt_beacon: Enable/disable sniffer on WiFi management Beacon frames (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_mgmt_other: Enable/disable sniffer on WiFi management other frames  (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_mgmt_probe: Enable/disable sniffer on WiFi management probe frames (default = enable). Valid values: `enable`, `disable`.
        :param str arrp_profile: Distributed Automatic Radio Resource Provisioning (DARRP) profile name to assign to the radio.
        :param int auto_power_high: The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_level: Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        :param int auto_power_low: The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_target: The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        :param str band: WiFi band that Radio 3 operates on.
        :param str band5g_type: WiFi 5G band type. Valid values: `5g-full`, `5g-high`, `5g-low`.
        :param str bandwidth_admission_control: Enable/disable WiFi multimedia (WMM) bandwidth admission control to optimize WiFi bandwidth use. A request to join the wireless network is only allowed if the access point has enough bandwidth to support it. Valid values: `enable`, `disable`.
        :param int bandwidth_capacity: Maximum bandwidth capacity allowed (1 - 600000 Kbps, default = 2000).
        :param int beacon_interval: Beacon interval. The time between beacon frames in msec (the actual range of beacon interval depends on the AP platform type, default = 100).
        :param int bss_color: BSS color value for this 11ax radio (0 - 63, 0 means disable. default = 0).
        :param str bss_color_mode: BSS color mode for this 11ax radio (default = auto). Valid values: `auto`, `static`.
        :param str call_admission_control: Enable/disable WiFi multimedia (WMM) call admission control to optimize WiFi bandwidth use for VoIP calls. New VoIP calls are only accepted if there is enough bandwidth available to support them. Valid values: `enable`, `disable`.
        :param int call_capacity: Maximum number of Voice over WLAN (VoWLAN) phones supported by the radio (0 - 60, default = 10).
        :param str channel_bonding: Channel bandwidth: 160,80, 40, or 20MHz. Channels may use both 20 and 40 by enabling coexistence. Valid values: `160MHz`, `80MHz`, `40MHz`, `20MHz`.
        :param str channel_utilization: Enable/disable measuring channel utilization. Valid values: `enable`, `disable`.
        :param Sequence['WtpprofileRadio2ChannelArgs'] channels: Selected list of wireless radio channels. The structure of `channel` block is documented below.
        :param str coexistence: Enable/disable allowing both HT20 and HT40 on the same radio (default = enable). Valid values: `enable`, `disable`.
        :param str darrp: Enable/disable Distributed Automatic Radio Resource Provisioning (DARRP) to make sure the radio is always using the most optimal channel (default = disable). Valid values: `enable`, `disable`.
        :param str drma: Enable/disable dynamic radio mode assignment (DRMA) (default = disable). Valid values: `disable`, `enable`.
        :param str drma_sensitivity: Network Coverage Factor (NCF) percentage required to consider a radio as redundant (default = low). Valid values: `low`, `medium`, `high`.
        :param int dtim: Delivery Traffic Indication Map (DTIM) period (1 - 255, default = 1). Set higher to save battery life of WiFi client in power-save mode.
        :param int frag_threshold: Maximum packet size that can be sent without fragmentation (800 - 2346 bytes, default = 2346).
        :param str frequency_handoff: Enable/disable frequency handoff of clients to other channels (default = disable). Valid values: `enable`, `disable`.
        :param str iperf_protocol: Iperf test protocol (default = "UDP"). Valid values: `udp`, `tcp`.
        :param int iperf_server_port: Iperf service port number.
        :param int max_clients: Maximum number of stations (STAs) supported by the WTP (default = 0, meaning no client limitation).
        :param int max_distance: Maximum expected distance between the AP and clients (0 - 54000 m, default = 0).
        :param str mimo_mode: Configure radio MIMO mode (default = default). Valid values: `default`, `1x1`, `2x2`, `3x3`, `4x4`, `8x8`.
        :param str mode: Mode of radio 3. Radio 3 can be disabled, configured as an access point, a rogue AP monitor, or a sniffer.
        :param str n80211d: Enable/disable 802.11d countryie(default = enable). Valid values: `enable`, `disable`.
        :param str optional_antenna: Optional antenna used on FAP (default = none).
        :param str optional_antenna_gain: Optional antenna gain in dBi (0 to 20, default = 0).
        :param int power_level: Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        :param str power_mode: Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        :param int power_value: Radio EIRP power in dBm (1 - 33, default = 27).
        :param str powersave_optimize: Enable client power-saving features such as TIM, AC VO, and OBSS etc. Valid values: `tim`, `ac-vo`, `no-obss-scan`, `no-11b-rate`, `client-rate-follow`.
        :param str protection_mode: Enable/disable 802.11g protection modes to support backwards compatibility with older clients (rtscts, ctsonly, disable). Valid values: `rtscts`, `ctsonly`, `disable`.
        :param int radio_id: radio-id
        :param int rts_threshold: Maximum packet size for RTS transmissions, specifying the maximum size of a data packet before RTS/CTS (256 - 2346 bytes, default = 2346).
        :param str sam_bssid: BSSID for WiFi network.
        :param str sam_ca_certificate: CA certificate for WPA2/WPA3-ENTERPRISE.
        :param str sam_captive_portal: Enable/disable Captive Portal Authentication (default = disable). Valid values: `enable`, `disable`.
        :param str sam_client_certificate: Client certificate for WPA2/WPA3-ENTERPRISE.
        :param str sam_cwp_failure_string: Failure identification on the page after an incorrect login.
        :param str sam_cwp_match_string: Identification string from the captive portal login form.
        :param str sam_cwp_password: Password for captive portal authentication.
        :param str sam_cwp_success_string: Success identification on the page after a successful login.
        :param str sam_cwp_test_url: Website the client is trying to access.
        :param str sam_cwp_username: Username for captive portal authentication.
        :param str sam_eap_method: Select WPA2/WPA3-ENTERPRISE EAP Method (default = PEAP). Valid values: `both`, `tls`, `peap`.
        :param str sam_password: Passphrase for WiFi network connection.
        :param str sam_private_key: Private key for WPA2/WPA3-ENTERPRISE.
        :param str sam_private_key_password: Password for private key file for WPA2/WPA3-ENTERPRISE.
        :param int sam_report_intv: SAM report interval (sec), 0 for a one-time report.
        :param str sam_security_type: Select WiFi network security type (default = "wpa-personal").
        :param str sam_server_fqdn: SAM test server domain name.
        :param str sam_server_ip: SAM test server IP address.
        :param str sam_server_type: Select SAM server type (default = "IP"). Valid values: `ip`, `fqdn`.
        :param str sam_ssid: SSID for WiFi network.
        :param str sam_test: Select SAM test type (default = "PING"). Valid values: `ping`, `iperf`.
        :param str sam_username: Username for WiFi network connection.
        :param str short_guard_interval: Use either the short guard interval (Short GI) of 400 ns or the long guard interval (Long GI) of 800 ns. Valid values: `enable`, `disable`.
        :param str spectrum_analysis: Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        :param str transmit_optimize: Packet transmission optimization options including power saving, aggregation limiting, retry limiting, etc. All are enabled by default. Valid values: `disable`, `power-save`, `aggr-limit`, `retry-limit`, `send-bar`.
        :param str vap_all: Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        :param Sequence['WtpprofileRadio2VapArgs'] vaps: Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        :param str wids_profile: Wireless Intrusion Detection System (WIDS) profile name to assign to the radio.
        :param str zero_wait_dfs: Enable/disable zero wait DFS on radio (default = enable). Valid values: `enable`, `disable`.
        """
        if airtime_fairness is not None:
            pulumi.set(__self__, "airtime_fairness", airtime_fairness)
        if amsdu is not None:
            pulumi.set(__self__, "amsdu", amsdu)
        if ap_handoff is not None:
            pulumi.set(__self__, "ap_handoff", ap_handoff)
        if ap_sniffer_addr is not None:
            pulumi.set(__self__, "ap_sniffer_addr", ap_sniffer_addr)
        if ap_sniffer_bufsize is not None:
            pulumi.set(__self__, "ap_sniffer_bufsize", ap_sniffer_bufsize)
        if ap_sniffer_chan is not None:
            pulumi.set(__self__, "ap_sniffer_chan", ap_sniffer_chan)
        if ap_sniffer_ctl is not None:
            pulumi.set(__self__, "ap_sniffer_ctl", ap_sniffer_ctl)
        if ap_sniffer_data is not None:
            pulumi.set(__self__, "ap_sniffer_data", ap_sniffer_data)
        if ap_sniffer_mgmt_beacon is not None:
            pulumi.set(__self__, "ap_sniffer_mgmt_beacon", ap_sniffer_mgmt_beacon)
        if ap_sniffer_mgmt_other is not None:
            pulumi.set(__self__, "ap_sniffer_mgmt_other", ap_sniffer_mgmt_other)
        if ap_sniffer_mgmt_probe is not None:
            pulumi.set(__self__, "ap_sniffer_mgmt_probe", ap_sniffer_mgmt_probe)
        if arrp_profile is not None:
            pulumi.set(__self__, "arrp_profile", arrp_profile)
        if auto_power_high is not None:
            pulumi.set(__self__, "auto_power_high", auto_power_high)
        if auto_power_level is not None:
            pulumi.set(__self__, "auto_power_level", auto_power_level)
        if auto_power_low is not None:
            pulumi.set(__self__, "auto_power_low", auto_power_low)
        if auto_power_target is not None:
            pulumi.set(__self__, "auto_power_target", auto_power_target)
        if band is not None:
            pulumi.set(__self__, "band", band)
        if band5g_type is not None:
            pulumi.set(__self__, "band5g_type", band5g_type)
        if bandwidth_admission_control is not None:
            pulumi.set(__self__, "bandwidth_admission_control", bandwidth_admission_control)
        if bandwidth_capacity is not None:
            pulumi.set(__self__, "bandwidth_capacity", bandwidth_capacity)
        if beacon_interval is not None:
            pulumi.set(__self__, "beacon_interval", beacon_interval)
        if bss_color is not None:
            pulumi.set(__self__, "bss_color", bss_color)
        if bss_color_mode is not None:
            pulumi.set(__self__, "bss_color_mode", bss_color_mode)
        if call_admission_control is not None:
            pulumi.set(__self__, "call_admission_control", call_admission_control)
        if call_capacity is not None:
            pulumi.set(__self__, "call_capacity", call_capacity)
        if channel_bonding is not None:
            pulumi.set(__self__, "channel_bonding", channel_bonding)
        if channel_utilization is not None:
            pulumi.set(__self__, "channel_utilization", channel_utilization)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if coexistence is not None:
            pulumi.set(__self__, "coexistence", coexistence)
        if darrp is not None:
            pulumi.set(__self__, "darrp", darrp)
        if drma is not None:
            pulumi.set(__self__, "drma", drma)
        if drma_sensitivity is not None:
            pulumi.set(__self__, "drma_sensitivity", drma_sensitivity)
        if dtim is not None:
            pulumi.set(__self__, "dtim", dtim)
        if frag_threshold is not None:
            pulumi.set(__self__, "frag_threshold", frag_threshold)
        if frequency_handoff is not None:
            pulumi.set(__self__, "frequency_handoff", frequency_handoff)
        if iperf_protocol is not None:
            pulumi.set(__self__, "iperf_protocol", iperf_protocol)
        if iperf_server_port is not None:
            pulumi.set(__self__, "iperf_server_port", iperf_server_port)
        if max_clients is not None:
            pulumi.set(__self__, "max_clients", max_clients)
        if max_distance is not None:
            pulumi.set(__self__, "max_distance", max_distance)
        if mimo_mode is not None:
            pulumi.set(__self__, "mimo_mode", mimo_mode)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if n80211d is not None:
            pulumi.set(__self__, "n80211d", n80211d)
        if optional_antenna is not None:
            pulumi.set(__self__, "optional_antenna", optional_antenna)
        if optional_antenna_gain is not None:
            pulumi.set(__self__, "optional_antenna_gain", optional_antenna_gain)
        if power_level is not None:
            pulumi.set(__self__, "power_level", power_level)
        if power_mode is not None:
            pulumi.set(__self__, "power_mode", power_mode)
        if power_value is not None:
            pulumi.set(__self__, "power_value", power_value)
        if powersave_optimize is not None:
            pulumi.set(__self__, "powersave_optimize", powersave_optimize)
        if protection_mode is not None:
            pulumi.set(__self__, "protection_mode", protection_mode)
        if radio_id is not None:
            pulumi.set(__self__, "radio_id", radio_id)
        if rts_threshold is not None:
            pulumi.set(__self__, "rts_threshold", rts_threshold)
        if sam_bssid is not None:
            pulumi.set(__self__, "sam_bssid", sam_bssid)
        if sam_ca_certificate is not None:
            pulumi.set(__self__, "sam_ca_certificate", sam_ca_certificate)
        if sam_captive_portal is not None:
            pulumi.set(__self__, "sam_captive_portal", sam_captive_portal)
        if sam_client_certificate is not None:
            pulumi.set(__self__, "sam_client_certificate", sam_client_certificate)
        if sam_cwp_failure_string is not None:
            pulumi.set(__self__, "sam_cwp_failure_string", sam_cwp_failure_string)
        if sam_cwp_match_string is not None:
            pulumi.set(__self__, "sam_cwp_match_string", sam_cwp_match_string)
        if sam_cwp_password is not None:
            pulumi.set(__self__, "sam_cwp_password", sam_cwp_password)
        if sam_cwp_success_string is not None:
            pulumi.set(__self__, "sam_cwp_success_string", sam_cwp_success_string)
        if sam_cwp_test_url is not None:
            pulumi.set(__self__, "sam_cwp_test_url", sam_cwp_test_url)
        if sam_cwp_username is not None:
            pulumi.set(__self__, "sam_cwp_username", sam_cwp_username)
        if sam_eap_method is not None:
            pulumi.set(__self__, "sam_eap_method", sam_eap_method)
        if sam_password is not None:
            pulumi.set(__self__, "sam_password", sam_password)
        if sam_private_key is not None:
            pulumi.set(__self__, "sam_private_key", sam_private_key)
        if sam_private_key_password is not None:
            pulumi.set(__self__, "sam_private_key_password", sam_private_key_password)
        if sam_report_intv is not None:
            pulumi.set(__self__, "sam_report_intv", sam_report_intv)
        if sam_security_type is not None:
            pulumi.set(__self__, "sam_security_type", sam_security_type)
        if sam_server_fqdn is not None:
            pulumi.set(__self__, "sam_server_fqdn", sam_server_fqdn)
        if sam_server_ip is not None:
            pulumi.set(__self__, "sam_server_ip", sam_server_ip)
        if sam_server_type is not None:
            pulumi.set(__self__, "sam_server_type", sam_server_type)
        if sam_ssid is not None:
            pulumi.set(__self__, "sam_ssid", sam_ssid)
        if sam_test is not None:
            pulumi.set(__self__, "sam_test", sam_test)
        if sam_username is not None:
            pulumi.set(__self__, "sam_username", sam_username)
        if short_guard_interval is not None:
            pulumi.set(__self__, "short_guard_interval", short_guard_interval)
        if spectrum_analysis is not None:
            pulumi.set(__self__, "spectrum_analysis", spectrum_analysis)
        if transmit_optimize is not None:
            pulumi.set(__self__, "transmit_optimize", transmit_optimize)
        if vap_all is not None:
            pulumi.set(__self__, "vap_all", vap_all)
        if vaps is not None:
            pulumi.set(__self__, "vaps", vaps)
        if wids_profile is not None:
            pulumi.set(__self__, "wids_profile", wids_profile)
        if zero_wait_dfs is not None:
            pulumi.set(__self__, "zero_wait_dfs", zero_wait_dfs)

    @property
    @pulumi.getter(name="airtimeFairness")
    def airtime_fairness(self) -> Optional[str]:
        """
        Enable/disable airtime fairness (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "airtime_fairness")

    @property
    @pulumi.getter
    def amsdu(self) -> Optional[str]:
        """
        Enable/disable 802.11n AMSDU support. AMSDU can improve performance if supported by your WiFi clients (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "amsdu")

    @property
    @pulumi.getter(name="apHandoff")
    def ap_handoff(self) -> Optional[str]:
        """
        Enable/disable AP handoff of clients to other APs (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_handoff")

    @property
    @pulumi.getter(name="apSnifferAddr")
    def ap_sniffer_addr(self) -> Optional[str]:
        """
        MAC address to monitor.
        """
        return pulumi.get(self, "ap_sniffer_addr")

    @property
    @pulumi.getter(name="apSnifferBufsize")
    def ap_sniffer_bufsize(self) -> Optional[int]:
        """
        Sniffer buffer size (1 - 32 MB, default = 16).
        """
        return pulumi.get(self, "ap_sniffer_bufsize")

    @property
    @pulumi.getter(name="apSnifferChan")
    def ap_sniffer_chan(self) -> Optional[int]:
        """
        Channel on which to operate the sniffer (default = 6).
        """
        return pulumi.get(self, "ap_sniffer_chan")

    @property
    @pulumi.getter(name="apSnifferCtl")
    def ap_sniffer_ctl(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi control frame (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_ctl")

    @property
    @pulumi.getter(name="apSnifferData")
    def ap_sniffer_data(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi data frame (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_data")

    @property
    @pulumi.getter(name="apSnifferMgmtBeacon")
    def ap_sniffer_mgmt_beacon(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi management Beacon frames (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_mgmt_beacon")

    @property
    @pulumi.getter(name="apSnifferMgmtOther")
    def ap_sniffer_mgmt_other(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi management other frames  (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_mgmt_other")

    @property
    @pulumi.getter(name="apSnifferMgmtProbe")
    def ap_sniffer_mgmt_probe(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi management probe frames (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_mgmt_probe")

    @property
    @pulumi.getter(name="arrpProfile")
    def arrp_profile(self) -> Optional[str]:
        """
        Distributed Automatic Radio Resource Provisioning (DARRP) profile name to assign to the radio.
        """
        return pulumi.get(self, "arrp_profile")

    @property
    @pulumi.getter(name="autoPowerHigh")
    def auto_power_high(self) -> Optional[int]:
        """
        The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_high")

    @property
    @pulumi.getter(name="autoPowerLevel")
    def auto_power_level(self) -> Optional[str]:
        """
        Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "auto_power_level")

    @property
    @pulumi.getter(name="autoPowerLow")
    def auto_power_low(self) -> Optional[int]:
        """
        The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_low")

    @property
    @pulumi.getter(name="autoPowerTarget")
    def auto_power_target(self) -> Optional[str]:
        """
        The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        """
        return pulumi.get(self, "auto_power_target")

    @property
    @pulumi.getter
    def band(self) -> Optional[str]:
        """
        WiFi band that Radio 3 operates on.
        """
        return pulumi.get(self, "band")

    @property
    @pulumi.getter(name="band5gType")
    def band5g_type(self) -> Optional[str]:
        """
        WiFi 5G band type. Valid values: `5g-full`, `5g-high`, `5g-low`.
        """
        return pulumi.get(self, "band5g_type")

    @property
    @pulumi.getter(name="bandwidthAdmissionControl")
    def bandwidth_admission_control(self) -> Optional[str]:
        """
        Enable/disable WiFi multimedia (WMM) bandwidth admission control to optimize WiFi bandwidth use. A request to join the wireless network is only allowed if the access point has enough bandwidth to support it. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "bandwidth_admission_control")

    @property
    @pulumi.getter(name="bandwidthCapacity")
    def bandwidth_capacity(self) -> Optional[int]:
        """
        Maximum bandwidth capacity allowed (1 - 600000 Kbps, default = 2000).
        """
        return pulumi.get(self, "bandwidth_capacity")

    @property
    @pulumi.getter(name="beaconInterval")
    def beacon_interval(self) -> Optional[int]:
        """
        Beacon interval. The time between beacon frames in msec (the actual range of beacon interval depends on the AP platform type, default = 100).
        """
        return pulumi.get(self, "beacon_interval")

    @property
    @pulumi.getter(name="bssColor")
    def bss_color(self) -> Optional[int]:
        """
        BSS color value for this 11ax radio (0 - 63, 0 means disable. default = 0).
        """
        return pulumi.get(self, "bss_color")

    @property
    @pulumi.getter(name="bssColorMode")
    def bss_color_mode(self) -> Optional[str]:
        """
        BSS color mode for this 11ax radio (default = auto). Valid values: `auto`, `static`.
        """
        return pulumi.get(self, "bss_color_mode")

    @property
    @pulumi.getter(name="callAdmissionControl")
    def call_admission_control(self) -> Optional[str]:
        """
        Enable/disable WiFi multimedia (WMM) call admission control to optimize WiFi bandwidth use for VoIP calls. New VoIP calls are only accepted if there is enough bandwidth available to support them. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "call_admission_control")

    @property
    @pulumi.getter(name="callCapacity")
    def call_capacity(self) -> Optional[int]:
        """
        Maximum number of Voice over WLAN (VoWLAN) phones supported by the radio (0 - 60, default = 10).
        """
        return pulumi.get(self, "call_capacity")

    @property
    @pulumi.getter(name="channelBonding")
    def channel_bonding(self) -> Optional[str]:
        """
        Channel bandwidth: 160,80, 40, or 20MHz. Channels may use both 20 and 40 by enabling coexistence. Valid values: `160MHz`, `80MHz`, `40MHz`, `20MHz`.
        """
        return pulumi.get(self, "channel_bonding")

    @property
    @pulumi.getter(name="channelUtilization")
    def channel_utilization(self) -> Optional[str]:
        """
        Enable/disable measuring channel utilization. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "channel_utilization")

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.WtpprofileRadio2Channel']]:
        """
        Selected list of wireless radio channels. The structure of `channel` block is documented below.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter
    def coexistence(self) -> Optional[str]:
        """
        Enable/disable allowing both HT20 and HT40 on the same radio (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "coexistence")

    @property
    @pulumi.getter
    def darrp(self) -> Optional[str]:
        """
        Enable/disable Distributed Automatic Radio Resource Provisioning (DARRP) to make sure the radio is always using the most optimal channel (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "darrp")

    @property
    @pulumi.getter
    def drma(self) -> Optional[str]:
        """
        Enable/disable dynamic radio mode assignment (DRMA) (default = disable). Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "drma")

    @property
    @pulumi.getter(name="drmaSensitivity")
    def drma_sensitivity(self) -> Optional[str]:
        """
        Network Coverage Factor (NCF) percentage required to consider a radio as redundant (default = low). Valid values: `low`, `medium`, `high`.
        """
        return pulumi.get(self, "drma_sensitivity")

    @property
    @pulumi.getter
    def dtim(self) -> Optional[int]:
        """
        Delivery Traffic Indication Map (DTIM) period (1 - 255, default = 1). Set higher to save battery life of WiFi client in power-save mode.
        """
        return pulumi.get(self, "dtim")

    @property
    @pulumi.getter(name="fragThreshold")
    def frag_threshold(self) -> Optional[int]:
        """
        Maximum packet size that can be sent without fragmentation (800 - 2346 bytes, default = 2346).
        """
        return pulumi.get(self, "frag_threshold")

    @property
    @pulumi.getter(name="frequencyHandoff")
    def frequency_handoff(self) -> Optional[str]:
        """
        Enable/disable frequency handoff of clients to other channels (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "frequency_handoff")

    @property
    @pulumi.getter(name="iperfProtocol")
    def iperf_protocol(self) -> Optional[str]:
        """
        Iperf test protocol (default = "UDP"). Valid values: `udp`, `tcp`.
        """
        return pulumi.get(self, "iperf_protocol")

    @property
    @pulumi.getter(name="iperfServerPort")
    def iperf_server_port(self) -> Optional[int]:
        """
        Iperf service port number.
        """
        return pulumi.get(self, "iperf_server_port")

    @property
    @pulumi.getter(name="maxClients")
    def max_clients(self) -> Optional[int]:
        """
        Maximum number of stations (STAs) supported by the WTP (default = 0, meaning no client limitation).
        """
        return pulumi.get(self, "max_clients")

    @property
    @pulumi.getter(name="maxDistance")
    def max_distance(self) -> Optional[int]:
        """
        Maximum expected distance between the AP and clients (0 - 54000 m, default = 0).
        """
        return pulumi.get(self, "max_distance")

    @property
    @pulumi.getter(name="mimoMode")
    def mimo_mode(self) -> Optional[str]:
        """
        Configure radio MIMO mode (default = default). Valid values: `default`, `1x1`, `2x2`, `3x3`, `4x4`, `8x8`.
        """
        return pulumi.get(self, "mimo_mode")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mode of radio 3. Radio 3 can be disabled, configured as an access point, a rogue AP monitor, or a sniffer.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def n80211d(self) -> Optional[str]:
        """
        Enable/disable 802.11d countryie(default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "n80211d")

    @property
    @pulumi.getter(name="optionalAntenna")
    def optional_antenna(self) -> Optional[str]:
        """
        Optional antenna used on FAP (default = none).
        """
        return pulumi.get(self, "optional_antenna")

    @property
    @pulumi.getter(name="optionalAntennaGain")
    def optional_antenna_gain(self) -> Optional[str]:
        """
        Optional antenna gain in dBi (0 to 20, default = 0).
        """
        return pulumi.get(self, "optional_antenna_gain")

    @property
    @pulumi.getter(name="powerLevel")
    def power_level(self) -> Optional[int]:
        """
        Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        """
        return pulumi.get(self, "power_level")

    @property
    @pulumi.getter(name="powerMode")
    def power_mode(self) -> Optional[str]:
        """
        Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        """
        return pulumi.get(self, "power_mode")

    @property
    @pulumi.getter(name="powerValue")
    def power_value(self) -> Optional[int]:
        """
        Radio EIRP power in dBm (1 - 33, default = 27).
        """
        return pulumi.get(self, "power_value")

    @property
    @pulumi.getter(name="powersaveOptimize")
    def powersave_optimize(self) -> Optional[str]:
        """
        Enable client power-saving features such as TIM, AC VO, and OBSS etc. Valid values: `tim`, `ac-vo`, `no-obss-scan`, `no-11b-rate`, `client-rate-follow`.
        """
        return pulumi.get(self, "powersave_optimize")

    @property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> Optional[str]:
        """
        Enable/disable 802.11g protection modes to support backwards compatibility with older clients (rtscts, ctsonly, disable). Valid values: `rtscts`, `ctsonly`, `disable`.
        """
        return pulumi.get(self, "protection_mode")

    @property
    @pulumi.getter(name="radioId")
    def radio_id(self) -> Optional[int]:
        """
        radio-id
        """
        return pulumi.get(self, "radio_id")

    @property
    @pulumi.getter(name="rtsThreshold")
    def rts_threshold(self) -> Optional[int]:
        """
        Maximum packet size for RTS transmissions, specifying the maximum size of a data packet before RTS/CTS (256 - 2346 bytes, default = 2346).
        """
        return pulumi.get(self, "rts_threshold")

    @property
    @pulumi.getter(name="samBssid")
    def sam_bssid(self) -> Optional[str]:
        """
        BSSID for WiFi network.
        """
        return pulumi.get(self, "sam_bssid")

    @property
    @pulumi.getter(name="samCaCertificate")
    def sam_ca_certificate(self) -> Optional[str]:
        """
        CA certificate for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_ca_certificate")

    @property
    @pulumi.getter(name="samCaptivePortal")
    def sam_captive_portal(self) -> Optional[str]:
        """
        Enable/disable Captive Portal Authentication (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "sam_captive_portal")

    @property
    @pulumi.getter(name="samClientCertificate")
    def sam_client_certificate(self) -> Optional[str]:
        """
        Client certificate for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_client_certificate")

    @property
    @pulumi.getter(name="samCwpFailureString")
    def sam_cwp_failure_string(self) -> Optional[str]:
        """
        Failure identification on the page after an incorrect login.
        """
        return pulumi.get(self, "sam_cwp_failure_string")

    @property
    @pulumi.getter(name="samCwpMatchString")
    def sam_cwp_match_string(self) -> Optional[str]:
        """
        Identification string from the captive portal login form.
        """
        return pulumi.get(self, "sam_cwp_match_string")

    @property
    @pulumi.getter(name="samCwpPassword")
    def sam_cwp_password(self) -> Optional[str]:
        """
        Password for captive portal authentication.
        """
        return pulumi.get(self, "sam_cwp_password")

    @property
    @pulumi.getter(name="samCwpSuccessString")
    def sam_cwp_success_string(self) -> Optional[str]:
        """
        Success identification on the page after a successful login.
        """
        return pulumi.get(self, "sam_cwp_success_string")

    @property
    @pulumi.getter(name="samCwpTestUrl")
    def sam_cwp_test_url(self) -> Optional[str]:
        """
        Website the client is trying to access.
        """
        return pulumi.get(self, "sam_cwp_test_url")

    @property
    @pulumi.getter(name="samCwpUsername")
    def sam_cwp_username(self) -> Optional[str]:
        """
        Username for captive portal authentication.
        """
        return pulumi.get(self, "sam_cwp_username")

    @property
    @pulumi.getter(name="samEapMethod")
    def sam_eap_method(self) -> Optional[str]:
        """
        Select WPA2/WPA3-ENTERPRISE EAP Method (default = PEAP). Valid values: `both`, `tls`, `peap`.
        """
        return pulumi.get(self, "sam_eap_method")

    @property
    @pulumi.getter(name="samPassword")
    def sam_password(self) -> Optional[str]:
        """
        Passphrase for WiFi network connection.
        """
        return pulumi.get(self, "sam_password")

    @property
    @pulumi.getter(name="samPrivateKey")
    def sam_private_key(self) -> Optional[str]:
        """
        Private key for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_private_key")

    @property
    @pulumi.getter(name="samPrivateKeyPassword")
    def sam_private_key_password(self) -> Optional[str]:
        """
        Password for private key file for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_private_key_password")

    @property
    @pulumi.getter(name="samReportIntv")
    def sam_report_intv(self) -> Optional[int]:
        """
        SAM report interval (sec), 0 for a one-time report.
        """
        return pulumi.get(self, "sam_report_intv")

    @property
    @pulumi.getter(name="samSecurityType")
    def sam_security_type(self) -> Optional[str]:
        """
        Select WiFi network security type (default = "wpa-personal").
        """
        return pulumi.get(self, "sam_security_type")

    @property
    @pulumi.getter(name="samServerFqdn")
    def sam_server_fqdn(self) -> Optional[str]:
        """
        SAM test server domain name.
        """
        return pulumi.get(self, "sam_server_fqdn")

    @property
    @pulumi.getter(name="samServerIp")
    def sam_server_ip(self) -> Optional[str]:
        """
        SAM test server IP address.
        """
        return pulumi.get(self, "sam_server_ip")

    @property
    @pulumi.getter(name="samServerType")
    def sam_server_type(self) -> Optional[str]:
        """
        Select SAM server type (default = "IP"). Valid values: `ip`, `fqdn`.
        """
        return pulumi.get(self, "sam_server_type")

    @property
    @pulumi.getter(name="samSsid")
    def sam_ssid(self) -> Optional[str]:
        """
        SSID for WiFi network.
        """
        return pulumi.get(self, "sam_ssid")

    @property
    @pulumi.getter(name="samTest")
    def sam_test(self) -> Optional[str]:
        """
        Select SAM test type (default = "PING"). Valid values: `ping`, `iperf`.
        """
        return pulumi.get(self, "sam_test")

    @property
    @pulumi.getter(name="samUsername")
    def sam_username(self) -> Optional[str]:
        """
        Username for WiFi network connection.
        """
        return pulumi.get(self, "sam_username")

    @property
    @pulumi.getter(name="shortGuardInterval")
    def short_guard_interval(self) -> Optional[str]:
        """
        Use either the short guard interval (Short GI) of 400 ns or the long guard interval (Long GI) of 800 ns. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "short_guard_interval")

    @property
    @pulumi.getter(name="spectrumAnalysis")
    def spectrum_analysis(self) -> Optional[str]:
        """
        Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        """
        return pulumi.get(self, "spectrum_analysis")

    @property
    @pulumi.getter(name="transmitOptimize")
    def transmit_optimize(self) -> Optional[str]:
        """
        Packet transmission optimization options including power saving, aggregation limiting, retry limiting, etc. All are enabled by default. Valid values: `disable`, `power-save`, `aggr-limit`, `retry-limit`, `send-bar`.
        """
        return pulumi.get(self, "transmit_optimize")

    @property
    @pulumi.getter(name="vapAll")
    def vap_all(self) -> Optional[str]:
        """
        Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        """
        return pulumi.get(self, "vap_all")

    @property
    @pulumi.getter
    def vaps(self) -> Optional[Sequence['outputs.WtpprofileRadio2Vap']]:
        """
        Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        """
        return pulumi.get(self, "vaps")

    @property
    @pulumi.getter(name="widsProfile")
    def wids_profile(self) -> Optional[str]:
        """
        Wireless Intrusion Detection System (WIDS) profile name to assign to the radio.
        """
        return pulumi.get(self, "wids_profile")

    @property
    @pulumi.getter(name="zeroWaitDfs")
    def zero_wait_dfs(self) -> Optional[str]:
        """
        Enable/disable zero wait DFS on radio (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "zero_wait_dfs")


@pulumi.output_type
class WtpprofileRadio2Channel(dict):
    def __init__(__self__, *,
                 chan: Optional[str] = None):
        """
        :param str chan: Channel number.
        """
        if chan is not None:
            pulumi.set(__self__, "chan", chan)

    @property
    @pulumi.getter
    def chan(self) -> Optional[str]:
        """
        Channel number.
        """
        return pulumi.get(self, "chan")


@pulumi.output_type
class WtpprofileRadio2Vap(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Virtual Access Point (VAP) name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Virtual Access Point (VAP) name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WtpprofileRadio3(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "airtimeFairness":
            suggest = "airtime_fairness"
        elif key == "apHandoff":
            suggest = "ap_handoff"
        elif key == "apSnifferAddr":
            suggest = "ap_sniffer_addr"
        elif key == "apSnifferBufsize":
            suggest = "ap_sniffer_bufsize"
        elif key == "apSnifferChan":
            suggest = "ap_sniffer_chan"
        elif key == "apSnifferCtl":
            suggest = "ap_sniffer_ctl"
        elif key == "apSnifferData":
            suggest = "ap_sniffer_data"
        elif key == "apSnifferMgmtBeacon":
            suggest = "ap_sniffer_mgmt_beacon"
        elif key == "apSnifferMgmtOther":
            suggest = "ap_sniffer_mgmt_other"
        elif key == "apSnifferMgmtProbe":
            suggest = "ap_sniffer_mgmt_probe"
        elif key == "arrpProfile":
            suggest = "arrp_profile"
        elif key == "autoPowerHigh":
            suggest = "auto_power_high"
        elif key == "autoPowerLevel":
            suggest = "auto_power_level"
        elif key == "autoPowerLow":
            suggest = "auto_power_low"
        elif key == "autoPowerTarget":
            suggest = "auto_power_target"
        elif key == "band5gType":
            suggest = "band5g_type"
        elif key == "bandwidthAdmissionControl":
            suggest = "bandwidth_admission_control"
        elif key == "bandwidthCapacity":
            suggest = "bandwidth_capacity"
        elif key == "beaconInterval":
            suggest = "beacon_interval"
        elif key == "bssColor":
            suggest = "bss_color"
        elif key == "bssColorMode":
            suggest = "bss_color_mode"
        elif key == "callAdmissionControl":
            suggest = "call_admission_control"
        elif key == "callCapacity":
            suggest = "call_capacity"
        elif key == "channelBonding":
            suggest = "channel_bonding"
        elif key == "channelUtilization":
            suggest = "channel_utilization"
        elif key == "drmaSensitivity":
            suggest = "drma_sensitivity"
        elif key == "fragThreshold":
            suggest = "frag_threshold"
        elif key == "frequencyHandoff":
            suggest = "frequency_handoff"
        elif key == "iperfProtocol":
            suggest = "iperf_protocol"
        elif key == "iperfServerPort":
            suggest = "iperf_server_port"
        elif key == "maxClients":
            suggest = "max_clients"
        elif key == "maxDistance":
            suggest = "max_distance"
        elif key == "mimoMode":
            suggest = "mimo_mode"
        elif key == "optionalAntenna":
            suggest = "optional_antenna"
        elif key == "optionalAntennaGain":
            suggest = "optional_antenna_gain"
        elif key == "powerLevel":
            suggest = "power_level"
        elif key == "powerMode":
            suggest = "power_mode"
        elif key == "powerValue":
            suggest = "power_value"
        elif key == "powersaveOptimize":
            suggest = "powersave_optimize"
        elif key == "protectionMode":
            suggest = "protection_mode"
        elif key == "rtsThreshold":
            suggest = "rts_threshold"
        elif key == "samBssid":
            suggest = "sam_bssid"
        elif key == "samCaCertificate":
            suggest = "sam_ca_certificate"
        elif key == "samCaptivePortal":
            suggest = "sam_captive_portal"
        elif key == "samClientCertificate":
            suggest = "sam_client_certificate"
        elif key == "samCwpFailureString":
            suggest = "sam_cwp_failure_string"
        elif key == "samCwpMatchString":
            suggest = "sam_cwp_match_string"
        elif key == "samCwpPassword":
            suggest = "sam_cwp_password"
        elif key == "samCwpSuccessString":
            suggest = "sam_cwp_success_string"
        elif key == "samCwpTestUrl":
            suggest = "sam_cwp_test_url"
        elif key == "samCwpUsername":
            suggest = "sam_cwp_username"
        elif key == "samEapMethod":
            suggest = "sam_eap_method"
        elif key == "samPassword":
            suggest = "sam_password"
        elif key == "samPrivateKey":
            suggest = "sam_private_key"
        elif key == "samPrivateKeyPassword":
            suggest = "sam_private_key_password"
        elif key == "samReportIntv":
            suggest = "sam_report_intv"
        elif key == "samSecurityType":
            suggest = "sam_security_type"
        elif key == "samServerFqdn":
            suggest = "sam_server_fqdn"
        elif key == "samServerIp":
            suggest = "sam_server_ip"
        elif key == "samServerType":
            suggest = "sam_server_type"
        elif key == "samSsid":
            suggest = "sam_ssid"
        elif key == "samTest":
            suggest = "sam_test"
        elif key == "samUsername":
            suggest = "sam_username"
        elif key == "shortGuardInterval":
            suggest = "short_guard_interval"
        elif key == "spectrumAnalysis":
            suggest = "spectrum_analysis"
        elif key == "transmitOptimize":
            suggest = "transmit_optimize"
        elif key == "vapAll":
            suggest = "vap_all"
        elif key == "widsProfile":
            suggest = "wids_profile"
        elif key == "zeroWaitDfs":
            suggest = "zero_wait_dfs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpprofileRadio3. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpprofileRadio3.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpprofileRadio3.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 airtime_fairness: Optional[str] = None,
                 amsdu: Optional[str] = None,
                 ap_handoff: Optional[str] = None,
                 ap_sniffer_addr: Optional[str] = None,
                 ap_sniffer_bufsize: Optional[int] = None,
                 ap_sniffer_chan: Optional[int] = None,
                 ap_sniffer_ctl: Optional[str] = None,
                 ap_sniffer_data: Optional[str] = None,
                 ap_sniffer_mgmt_beacon: Optional[str] = None,
                 ap_sniffer_mgmt_other: Optional[str] = None,
                 ap_sniffer_mgmt_probe: Optional[str] = None,
                 arrp_profile: Optional[str] = None,
                 auto_power_high: Optional[int] = None,
                 auto_power_level: Optional[str] = None,
                 auto_power_low: Optional[int] = None,
                 auto_power_target: Optional[str] = None,
                 band: Optional[str] = None,
                 band5g_type: Optional[str] = None,
                 bandwidth_admission_control: Optional[str] = None,
                 bandwidth_capacity: Optional[int] = None,
                 beacon_interval: Optional[int] = None,
                 bss_color: Optional[int] = None,
                 bss_color_mode: Optional[str] = None,
                 call_admission_control: Optional[str] = None,
                 call_capacity: Optional[int] = None,
                 channel_bonding: Optional[str] = None,
                 channel_utilization: Optional[str] = None,
                 channels: Optional[Sequence['outputs.WtpprofileRadio3Channel']] = None,
                 coexistence: Optional[str] = None,
                 darrp: Optional[str] = None,
                 drma: Optional[str] = None,
                 drma_sensitivity: Optional[str] = None,
                 dtim: Optional[int] = None,
                 frag_threshold: Optional[int] = None,
                 frequency_handoff: Optional[str] = None,
                 iperf_protocol: Optional[str] = None,
                 iperf_server_port: Optional[int] = None,
                 max_clients: Optional[int] = None,
                 max_distance: Optional[int] = None,
                 mimo_mode: Optional[str] = None,
                 mode: Optional[str] = None,
                 n80211d: Optional[str] = None,
                 optional_antenna: Optional[str] = None,
                 optional_antenna_gain: Optional[str] = None,
                 power_level: Optional[int] = None,
                 power_mode: Optional[str] = None,
                 power_value: Optional[int] = None,
                 powersave_optimize: Optional[str] = None,
                 protection_mode: Optional[str] = None,
                 rts_threshold: Optional[int] = None,
                 sam_bssid: Optional[str] = None,
                 sam_ca_certificate: Optional[str] = None,
                 sam_captive_portal: Optional[str] = None,
                 sam_client_certificate: Optional[str] = None,
                 sam_cwp_failure_string: Optional[str] = None,
                 sam_cwp_match_string: Optional[str] = None,
                 sam_cwp_password: Optional[str] = None,
                 sam_cwp_success_string: Optional[str] = None,
                 sam_cwp_test_url: Optional[str] = None,
                 sam_cwp_username: Optional[str] = None,
                 sam_eap_method: Optional[str] = None,
                 sam_password: Optional[str] = None,
                 sam_private_key: Optional[str] = None,
                 sam_private_key_password: Optional[str] = None,
                 sam_report_intv: Optional[int] = None,
                 sam_security_type: Optional[str] = None,
                 sam_server_fqdn: Optional[str] = None,
                 sam_server_ip: Optional[str] = None,
                 sam_server_type: Optional[str] = None,
                 sam_ssid: Optional[str] = None,
                 sam_test: Optional[str] = None,
                 sam_username: Optional[str] = None,
                 short_guard_interval: Optional[str] = None,
                 spectrum_analysis: Optional[str] = None,
                 transmit_optimize: Optional[str] = None,
                 vap_all: Optional[str] = None,
                 vaps: Optional[Sequence['outputs.WtpprofileRadio3Vap']] = None,
                 wids_profile: Optional[str] = None,
                 zero_wait_dfs: Optional[str] = None):
        """
        :param str airtime_fairness: Enable/disable airtime fairness (default = disable). Valid values: `enable`, `disable`.
        :param str amsdu: Enable/disable 802.11n AMSDU support. AMSDU can improve performance if supported by your WiFi clients (default = enable). Valid values: `enable`, `disable`.
        :param str ap_handoff: Enable/disable AP handoff of clients to other APs (default = disable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_addr: MAC address to monitor.
        :param int ap_sniffer_bufsize: Sniffer buffer size (1 - 32 MB, default = 16).
        :param int ap_sniffer_chan: Channel on which to operate the sniffer (default = 6).
        :param str ap_sniffer_ctl: Enable/disable sniffer on WiFi control frame (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_data: Enable/disable sniffer on WiFi data frame (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_mgmt_beacon: Enable/disable sniffer on WiFi management Beacon frames (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_mgmt_other: Enable/disable sniffer on WiFi management other frames  (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_mgmt_probe: Enable/disable sniffer on WiFi management probe frames (default = enable). Valid values: `enable`, `disable`.
        :param str arrp_profile: Distributed Automatic Radio Resource Provisioning (DARRP) profile name to assign to the radio.
        :param int auto_power_high: The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_level: Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        :param int auto_power_low: The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_target: The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        :param str band: WiFi band that Radio 3 operates on.
        :param str band5g_type: WiFi 5G band type. Valid values: `5g-full`, `5g-high`, `5g-low`.
        :param str bandwidth_admission_control: Enable/disable WiFi multimedia (WMM) bandwidth admission control to optimize WiFi bandwidth use. A request to join the wireless network is only allowed if the access point has enough bandwidth to support it. Valid values: `enable`, `disable`.
        :param int bandwidth_capacity: Maximum bandwidth capacity allowed (1 - 600000 Kbps, default = 2000).
        :param int beacon_interval: Beacon interval. The time between beacon frames in msec (the actual range of beacon interval depends on the AP platform type, default = 100).
        :param int bss_color: BSS color value for this 11ax radio (0 - 63, 0 means disable. default = 0).
        :param str bss_color_mode: BSS color mode for this 11ax radio (default = auto). Valid values: `auto`, `static`.
        :param str call_admission_control: Enable/disable WiFi multimedia (WMM) call admission control to optimize WiFi bandwidth use for VoIP calls. New VoIP calls are only accepted if there is enough bandwidth available to support them. Valid values: `enable`, `disable`.
        :param int call_capacity: Maximum number of Voice over WLAN (VoWLAN) phones supported by the radio (0 - 60, default = 10).
        :param str channel_bonding: Channel bandwidth: 160,80, 40, or 20MHz. Channels may use both 20 and 40 by enabling coexistence. Valid values: `160MHz`, `80MHz`, `40MHz`, `20MHz`.
        :param str channel_utilization: Enable/disable measuring channel utilization. Valid values: `enable`, `disable`.
        :param Sequence['WtpprofileRadio3ChannelArgs'] channels: Selected list of wireless radio channels. The structure of `channel` block is documented below.
        :param str coexistence: Enable/disable allowing both HT20 and HT40 on the same radio (default = enable). Valid values: `enable`, `disable`.
        :param str darrp: Enable/disable Distributed Automatic Radio Resource Provisioning (DARRP) to make sure the radio is always using the most optimal channel (default = disable). Valid values: `enable`, `disable`.
        :param str drma: Enable/disable dynamic radio mode assignment (DRMA) (default = disable). Valid values: `disable`, `enable`.
        :param str drma_sensitivity: Network Coverage Factor (NCF) percentage required to consider a radio as redundant (default = low). Valid values: `low`, `medium`, `high`.
        :param int dtim: Delivery Traffic Indication Map (DTIM) period (1 - 255, default = 1). Set higher to save battery life of WiFi client in power-save mode.
        :param int frag_threshold: Maximum packet size that can be sent without fragmentation (800 - 2346 bytes, default = 2346).
        :param str frequency_handoff: Enable/disable frequency handoff of clients to other channels (default = disable). Valid values: `enable`, `disable`.
        :param str iperf_protocol: Iperf test protocol (default = "UDP"). Valid values: `udp`, `tcp`.
        :param int iperf_server_port: Iperf service port number.
        :param int max_clients: Maximum number of stations (STAs) supported by the WTP (default = 0, meaning no client limitation).
        :param int max_distance: Maximum expected distance between the AP and clients (0 - 54000 m, default = 0).
        :param str mimo_mode: Configure radio MIMO mode (default = default). Valid values: `default`, `1x1`, `2x2`, `3x3`, `4x4`, `8x8`.
        :param str mode: Mode of radio 3. Radio 3 can be disabled, configured as an access point, a rogue AP monitor, or a sniffer.
        :param str n80211d: Enable/disable 802.11d countryie(default = enable). Valid values: `enable`, `disable`.
        :param str optional_antenna: Optional antenna used on FAP (default = none).
        :param str optional_antenna_gain: Optional antenna gain in dBi (0 to 20, default = 0).
        :param int power_level: Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        :param str power_mode: Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        :param int power_value: Radio EIRP power in dBm (1 - 33, default = 27).
        :param str powersave_optimize: Enable client power-saving features such as TIM, AC VO, and OBSS etc. Valid values: `tim`, `ac-vo`, `no-obss-scan`, `no-11b-rate`, `client-rate-follow`.
        :param str protection_mode: Enable/disable 802.11g protection modes to support backwards compatibility with older clients (rtscts, ctsonly, disable). Valid values: `rtscts`, `ctsonly`, `disable`.
        :param int rts_threshold: Maximum packet size for RTS transmissions, specifying the maximum size of a data packet before RTS/CTS (256 - 2346 bytes, default = 2346).
        :param str sam_bssid: BSSID for WiFi network.
        :param str sam_ca_certificate: CA certificate for WPA2/WPA3-ENTERPRISE.
        :param str sam_captive_portal: Enable/disable Captive Portal Authentication (default = disable). Valid values: `enable`, `disable`.
        :param str sam_client_certificate: Client certificate for WPA2/WPA3-ENTERPRISE.
        :param str sam_cwp_failure_string: Failure identification on the page after an incorrect login.
        :param str sam_cwp_match_string: Identification string from the captive portal login form.
        :param str sam_cwp_password: Password for captive portal authentication.
        :param str sam_cwp_success_string: Success identification on the page after a successful login.
        :param str sam_cwp_test_url: Website the client is trying to access.
        :param str sam_cwp_username: Username for captive portal authentication.
        :param str sam_eap_method: Select WPA2/WPA3-ENTERPRISE EAP Method (default = PEAP). Valid values: `both`, `tls`, `peap`.
        :param str sam_password: Passphrase for WiFi network connection.
        :param str sam_private_key: Private key for WPA2/WPA3-ENTERPRISE.
        :param str sam_private_key_password: Password for private key file for WPA2/WPA3-ENTERPRISE.
        :param int sam_report_intv: SAM report interval (sec), 0 for a one-time report.
        :param str sam_security_type: Select WiFi network security type (default = "wpa-personal").
        :param str sam_server_fqdn: SAM test server domain name.
        :param str sam_server_ip: SAM test server IP address.
        :param str sam_server_type: Select SAM server type (default = "IP"). Valid values: `ip`, `fqdn`.
        :param str sam_ssid: SSID for WiFi network.
        :param str sam_test: Select SAM test type (default = "PING"). Valid values: `ping`, `iperf`.
        :param str sam_username: Username for WiFi network connection.
        :param str short_guard_interval: Use either the short guard interval (Short GI) of 400 ns or the long guard interval (Long GI) of 800 ns. Valid values: `enable`, `disable`.
        :param str spectrum_analysis: Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        :param str transmit_optimize: Packet transmission optimization options including power saving, aggregation limiting, retry limiting, etc. All are enabled by default. Valid values: `disable`, `power-save`, `aggr-limit`, `retry-limit`, `send-bar`.
        :param str vap_all: Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        :param Sequence['WtpprofileRadio3VapArgs'] vaps: Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        :param str wids_profile: Wireless Intrusion Detection System (WIDS) profile name to assign to the radio.
        :param str zero_wait_dfs: Enable/disable zero wait DFS on radio (default = enable). Valid values: `enable`, `disable`.
        """
        if airtime_fairness is not None:
            pulumi.set(__self__, "airtime_fairness", airtime_fairness)
        if amsdu is not None:
            pulumi.set(__self__, "amsdu", amsdu)
        if ap_handoff is not None:
            pulumi.set(__self__, "ap_handoff", ap_handoff)
        if ap_sniffer_addr is not None:
            pulumi.set(__self__, "ap_sniffer_addr", ap_sniffer_addr)
        if ap_sniffer_bufsize is not None:
            pulumi.set(__self__, "ap_sniffer_bufsize", ap_sniffer_bufsize)
        if ap_sniffer_chan is not None:
            pulumi.set(__self__, "ap_sniffer_chan", ap_sniffer_chan)
        if ap_sniffer_ctl is not None:
            pulumi.set(__self__, "ap_sniffer_ctl", ap_sniffer_ctl)
        if ap_sniffer_data is not None:
            pulumi.set(__self__, "ap_sniffer_data", ap_sniffer_data)
        if ap_sniffer_mgmt_beacon is not None:
            pulumi.set(__self__, "ap_sniffer_mgmt_beacon", ap_sniffer_mgmt_beacon)
        if ap_sniffer_mgmt_other is not None:
            pulumi.set(__self__, "ap_sniffer_mgmt_other", ap_sniffer_mgmt_other)
        if ap_sniffer_mgmt_probe is not None:
            pulumi.set(__self__, "ap_sniffer_mgmt_probe", ap_sniffer_mgmt_probe)
        if arrp_profile is not None:
            pulumi.set(__self__, "arrp_profile", arrp_profile)
        if auto_power_high is not None:
            pulumi.set(__self__, "auto_power_high", auto_power_high)
        if auto_power_level is not None:
            pulumi.set(__self__, "auto_power_level", auto_power_level)
        if auto_power_low is not None:
            pulumi.set(__self__, "auto_power_low", auto_power_low)
        if auto_power_target is not None:
            pulumi.set(__self__, "auto_power_target", auto_power_target)
        if band is not None:
            pulumi.set(__self__, "band", band)
        if band5g_type is not None:
            pulumi.set(__self__, "band5g_type", band5g_type)
        if bandwidth_admission_control is not None:
            pulumi.set(__self__, "bandwidth_admission_control", bandwidth_admission_control)
        if bandwidth_capacity is not None:
            pulumi.set(__self__, "bandwidth_capacity", bandwidth_capacity)
        if beacon_interval is not None:
            pulumi.set(__self__, "beacon_interval", beacon_interval)
        if bss_color is not None:
            pulumi.set(__self__, "bss_color", bss_color)
        if bss_color_mode is not None:
            pulumi.set(__self__, "bss_color_mode", bss_color_mode)
        if call_admission_control is not None:
            pulumi.set(__self__, "call_admission_control", call_admission_control)
        if call_capacity is not None:
            pulumi.set(__self__, "call_capacity", call_capacity)
        if channel_bonding is not None:
            pulumi.set(__self__, "channel_bonding", channel_bonding)
        if channel_utilization is not None:
            pulumi.set(__self__, "channel_utilization", channel_utilization)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if coexistence is not None:
            pulumi.set(__self__, "coexistence", coexistence)
        if darrp is not None:
            pulumi.set(__self__, "darrp", darrp)
        if drma is not None:
            pulumi.set(__self__, "drma", drma)
        if drma_sensitivity is not None:
            pulumi.set(__self__, "drma_sensitivity", drma_sensitivity)
        if dtim is not None:
            pulumi.set(__self__, "dtim", dtim)
        if frag_threshold is not None:
            pulumi.set(__self__, "frag_threshold", frag_threshold)
        if frequency_handoff is not None:
            pulumi.set(__self__, "frequency_handoff", frequency_handoff)
        if iperf_protocol is not None:
            pulumi.set(__self__, "iperf_protocol", iperf_protocol)
        if iperf_server_port is not None:
            pulumi.set(__self__, "iperf_server_port", iperf_server_port)
        if max_clients is not None:
            pulumi.set(__self__, "max_clients", max_clients)
        if max_distance is not None:
            pulumi.set(__self__, "max_distance", max_distance)
        if mimo_mode is not None:
            pulumi.set(__self__, "mimo_mode", mimo_mode)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if n80211d is not None:
            pulumi.set(__self__, "n80211d", n80211d)
        if optional_antenna is not None:
            pulumi.set(__self__, "optional_antenna", optional_antenna)
        if optional_antenna_gain is not None:
            pulumi.set(__self__, "optional_antenna_gain", optional_antenna_gain)
        if power_level is not None:
            pulumi.set(__self__, "power_level", power_level)
        if power_mode is not None:
            pulumi.set(__self__, "power_mode", power_mode)
        if power_value is not None:
            pulumi.set(__self__, "power_value", power_value)
        if powersave_optimize is not None:
            pulumi.set(__self__, "powersave_optimize", powersave_optimize)
        if protection_mode is not None:
            pulumi.set(__self__, "protection_mode", protection_mode)
        if rts_threshold is not None:
            pulumi.set(__self__, "rts_threshold", rts_threshold)
        if sam_bssid is not None:
            pulumi.set(__self__, "sam_bssid", sam_bssid)
        if sam_ca_certificate is not None:
            pulumi.set(__self__, "sam_ca_certificate", sam_ca_certificate)
        if sam_captive_portal is not None:
            pulumi.set(__self__, "sam_captive_portal", sam_captive_portal)
        if sam_client_certificate is not None:
            pulumi.set(__self__, "sam_client_certificate", sam_client_certificate)
        if sam_cwp_failure_string is not None:
            pulumi.set(__self__, "sam_cwp_failure_string", sam_cwp_failure_string)
        if sam_cwp_match_string is not None:
            pulumi.set(__self__, "sam_cwp_match_string", sam_cwp_match_string)
        if sam_cwp_password is not None:
            pulumi.set(__self__, "sam_cwp_password", sam_cwp_password)
        if sam_cwp_success_string is not None:
            pulumi.set(__self__, "sam_cwp_success_string", sam_cwp_success_string)
        if sam_cwp_test_url is not None:
            pulumi.set(__self__, "sam_cwp_test_url", sam_cwp_test_url)
        if sam_cwp_username is not None:
            pulumi.set(__self__, "sam_cwp_username", sam_cwp_username)
        if sam_eap_method is not None:
            pulumi.set(__self__, "sam_eap_method", sam_eap_method)
        if sam_password is not None:
            pulumi.set(__self__, "sam_password", sam_password)
        if sam_private_key is not None:
            pulumi.set(__self__, "sam_private_key", sam_private_key)
        if sam_private_key_password is not None:
            pulumi.set(__self__, "sam_private_key_password", sam_private_key_password)
        if sam_report_intv is not None:
            pulumi.set(__self__, "sam_report_intv", sam_report_intv)
        if sam_security_type is not None:
            pulumi.set(__self__, "sam_security_type", sam_security_type)
        if sam_server_fqdn is not None:
            pulumi.set(__self__, "sam_server_fqdn", sam_server_fqdn)
        if sam_server_ip is not None:
            pulumi.set(__self__, "sam_server_ip", sam_server_ip)
        if sam_server_type is not None:
            pulumi.set(__self__, "sam_server_type", sam_server_type)
        if sam_ssid is not None:
            pulumi.set(__self__, "sam_ssid", sam_ssid)
        if sam_test is not None:
            pulumi.set(__self__, "sam_test", sam_test)
        if sam_username is not None:
            pulumi.set(__self__, "sam_username", sam_username)
        if short_guard_interval is not None:
            pulumi.set(__self__, "short_guard_interval", short_guard_interval)
        if spectrum_analysis is not None:
            pulumi.set(__self__, "spectrum_analysis", spectrum_analysis)
        if transmit_optimize is not None:
            pulumi.set(__self__, "transmit_optimize", transmit_optimize)
        if vap_all is not None:
            pulumi.set(__self__, "vap_all", vap_all)
        if vaps is not None:
            pulumi.set(__self__, "vaps", vaps)
        if wids_profile is not None:
            pulumi.set(__self__, "wids_profile", wids_profile)
        if zero_wait_dfs is not None:
            pulumi.set(__self__, "zero_wait_dfs", zero_wait_dfs)

    @property
    @pulumi.getter(name="airtimeFairness")
    def airtime_fairness(self) -> Optional[str]:
        """
        Enable/disable airtime fairness (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "airtime_fairness")

    @property
    @pulumi.getter
    def amsdu(self) -> Optional[str]:
        """
        Enable/disable 802.11n AMSDU support. AMSDU can improve performance if supported by your WiFi clients (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "amsdu")

    @property
    @pulumi.getter(name="apHandoff")
    def ap_handoff(self) -> Optional[str]:
        """
        Enable/disable AP handoff of clients to other APs (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_handoff")

    @property
    @pulumi.getter(name="apSnifferAddr")
    def ap_sniffer_addr(self) -> Optional[str]:
        """
        MAC address to monitor.
        """
        return pulumi.get(self, "ap_sniffer_addr")

    @property
    @pulumi.getter(name="apSnifferBufsize")
    def ap_sniffer_bufsize(self) -> Optional[int]:
        """
        Sniffer buffer size (1 - 32 MB, default = 16).
        """
        return pulumi.get(self, "ap_sniffer_bufsize")

    @property
    @pulumi.getter(name="apSnifferChan")
    def ap_sniffer_chan(self) -> Optional[int]:
        """
        Channel on which to operate the sniffer (default = 6).
        """
        return pulumi.get(self, "ap_sniffer_chan")

    @property
    @pulumi.getter(name="apSnifferCtl")
    def ap_sniffer_ctl(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi control frame (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_ctl")

    @property
    @pulumi.getter(name="apSnifferData")
    def ap_sniffer_data(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi data frame (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_data")

    @property
    @pulumi.getter(name="apSnifferMgmtBeacon")
    def ap_sniffer_mgmt_beacon(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi management Beacon frames (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_mgmt_beacon")

    @property
    @pulumi.getter(name="apSnifferMgmtOther")
    def ap_sniffer_mgmt_other(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi management other frames  (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_mgmt_other")

    @property
    @pulumi.getter(name="apSnifferMgmtProbe")
    def ap_sniffer_mgmt_probe(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi management probe frames (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_mgmt_probe")

    @property
    @pulumi.getter(name="arrpProfile")
    def arrp_profile(self) -> Optional[str]:
        """
        Distributed Automatic Radio Resource Provisioning (DARRP) profile name to assign to the radio.
        """
        return pulumi.get(self, "arrp_profile")

    @property
    @pulumi.getter(name="autoPowerHigh")
    def auto_power_high(self) -> Optional[int]:
        """
        The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_high")

    @property
    @pulumi.getter(name="autoPowerLevel")
    def auto_power_level(self) -> Optional[str]:
        """
        Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "auto_power_level")

    @property
    @pulumi.getter(name="autoPowerLow")
    def auto_power_low(self) -> Optional[int]:
        """
        The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_low")

    @property
    @pulumi.getter(name="autoPowerTarget")
    def auto_power_target(self) -> Optional[str]:
        """
        The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        """
        return pulumi.get(self, "auto_power_target")

    @property
    @pulumi.getter
    def band(self) -> Optional[str]:
        """
        WiFi band that Radio 3 operates on.
        """
        return pulumi.get(self, "band")

    @property
    @pulumi.getter(name="band5gType")
    def band5g_type(self) -> Optional[str]:
        """
        WiFi 5G band type. Valid values: `5g-full`, `5g-high`, `5g-low`.
        """
        return pulumi.get(self, "band5g_type")

    @property
    @pulumi.getter(name="bandwidthAdmissionControl")
    def bandwidth_admission_control(self) -> Optional[str]:
        """
        Enable/disable WiFi multimedia (WMM) bandwidth admission control to optimize WiFi bandwidth use. A request to join the wireless network is only allowed if the access point has enough bandwidth to support it. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "bandwidth_admission_control")

    @property
    @pulumi.getter(name="bandwidthCapacity")
    def bandwidth_capacity(self) -> Optional[int]:
        """
        Maximum bandwidth capacity allowed (1 - 600000 Kbps, default = 2000).
        """
        return pulumi.get(self, "bandwidth_capacity")

    @property
    @pulumi.getter(name="beaconInterval")
    def beacon_interval(self) -> Optional[int]:
        """
        Beacon interval. The time between beacon frames in msec (the actual range of beacon interval depends on the AP platform type, default = 100).
        """
        return pulumi.get(self, "beacon_interval")

    @property
    @pulumi.getter(name="bssColor")
    def bss_color(self) -> Optional[int]:
        """
        BSS color value for this 11ax radio (0 - 63, 0 means disable. default = 0).
        """
        return pulumi.get(self, "bss_color")

    @property
    @pulumi.getter(name="bssColorMode")
    def bss_color_mode(self) -> Optional[str]:
        """
        BSS color mode for this 11ax radio (default = auto). Valid values: `auto`, `static`.
        """
        return pulumi.get(self, "bss_color_mode")

    @property
    @pulumi.getter(name="callAdmissionControl")
    def call_admission_control(self) -> Optional[str]:
        """
        Enable/disable WiFi multimedia (WMM) call admission control to optimize WiFi bandwidth use for VoIP calls. New VoIP calls are only accepted if there is enough bandwidth available to support them. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "call_admission_control")

    @property
    @pulumi.getter(name="callCapacity")
    def call_capacity(self) -> Optional[int]:
        """
        Maximum number of Voice over WLAN (VoWLAN) phones supported by the radio (0 - 60, default = 10).
        """
        return pulumi.get(self, "call_capacity")

    @property
    @pulumi.getter(name="channelBonding")
    def channel_bonding(self) -> Optional[str]:
        """
        Channel bandwidth: 160,80, 40, or 20MHz. Channels may use both 20 and 40 by enabling coexistence. Valid values: `160MHz`, `80MHz`, `40MHz`, `20MHz`.
        """
        return pulumi.get(self, "channel_bonding")

    @property
    @pulumi.getter(name="channelUtilization")
    def channel_utilization(self) -> Optional[str]:
        """
        Enable/disable measuring channel utilization. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "channel_utilization")

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.WtpprofileRadio3Channel']]:
        """
        Selected list of wireless radio channels. The structure of `channel` block is documented below.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter
    def coexistence(self) -> Optional[str]:
        """
        Enable/disable allowing both HT20 and HT40 on the same radio (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "coexistence")

    @property
    @pulumi.getter
    def darrp(self) -> Optional[str]:
        """
        Enable/disable Distributed Automatic Radio Resource Provisioning (DARRP) to make sure the radio is always using the most optimal channel (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "darrp")

    @property
    @pulumi.getter
    def drma(self) -> Optional[str]:
        """
        Enable/disable dynamic radio mode assignment (DRMA) (default = disable). Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "drma")

    @property
    @pulumi.getter(name="drmaSensitivity")
    def drma_sensitivity(self) -> Optional[str]:
        """
        Network Coverage Factor (NCF) percentage required to consider a radio as redundant (default = low). Valid values: `low`, `medium`, `high`.
        """
        return pulumi.get(self, "drma_sensitivity")

    @property
    @pulumi.getter
    def dtim(self) -> Optional[int]:
        """
        Delivery Traffic Indication Map (DTIM) period (1 - 255, default = 1). Set higher to save battery life of WiFi client in power-save mode.
        """
        return pulumi.get(self, "dtim")

    @property
    @pulumi.getter(name="fragThreshold")
    def frag_threshold(self) -> Optional[int]:
        """
        Maximum packet size that can be sent without fragmentation (800 - 2346 bytes, default = 2346).
        """
        return pulumi.get(self, "frag_threshold")

    @property
    @pulumi.getter(name="frequencyHandoff")
    def frequency_handoff(self) -> Optional[str]:
        """
        Enable/disable frequency handoff of clients to other channels (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "frequency_handoff")

    @property
    @pulumi.getter(name="iperfProtocol")
    def iperf_protocol(self) -> Optional[str]:
        """
        Iperf test protocol (default = "UDP"). Valid values: `udp`, `tcp`.
        """
        return pulumi.get(self, "iperf_protocol")

    @property
    @pulumi.getter(name="iperfServerPort")
    def iperf_server_port(self) -> Optional[int]:
        """
        Iperf service port number.
        """
        return pulumi.get(self, "iperf_server_port")

    @property
    @pulumi.getter(name="maxClients")
    def max_clients(self) -> Optional[int]:
        """
        Maximum number of stations (STAs) supported by the WTP (default = 0, meaning no client limitation).
        """
        return pulumi.get(self, "max_clients")

    @property
    @pulumi.getter(name="maxDistance")
    def max_distance(self) -> Optional[int]:
        """
        Maximum expected distance between the AP and clients (0 - 54000 m, default = 0).
        """
        return pulumi.get(self, "max_distance")

    @property
    @pulumi.getter(name="mimoMode")
    def mimo_mode(self) -> Optional[str]:
        """
        Configure radio MIMO mode (default = default). Valid values: `default`, `1x1`, `2x2`, `3x3`, `4x4`, `8x8`.
        """
        return pulumi.get(self, "mimo_mode")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mode of radio 3. Radio 3 can be disabled, configured as an access point, a rogue AP monitor, or a sniffer.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def n80211d(self) -> Optional[str]:
        """
        Enable/disable 802.11d countryie(default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "n80211d")

    @property
    @pulumi.getter(name="optionalAntenna")
    def optional_antenna(self) -> Optional[str]:
        """
        Optional antenna used on FAP (default = none).
        """
        return pulumi.get(self, "optional_antenna")

    @property
    @pulumi.getter(name="optionalAntennaGain")
    def optional_antenna_gain(self) -> Optional[str]:
        """
        Optional antenna gain in dBi (0 to 20, default = 0).
        """
        return pulumi.get(self, "optional_antenna_gain")

    @property
    @pulumi.getter(name="powerLevel")
    def power_level(self) -> Optional[int]:
        """
        Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        """
        return pulumi.get(self, "power_level")

    @property
    @pulumi.getter(name="powerMode")
    def power_mode(self) -> Optional[str]:
        """
        Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        """
        return pulumi.get(self, "power_mode")

    @property
    @pulumi.getter(name="powerValue")
    def power_value(self) -> Optional[int]:
        """
        Radio EIRP power in dBm (1 - 33, default = 27).
        """
        return pulumi.get(self, "power_value")

    @property
    @pulumi.getter(name="powersaveOptimize")
    def powersave_optimize(self) -> Optional[str]:
        """
        Enable client power-saving features such as TIM, AC VO, and OBSS etc. Valid values: `tim`, `ac-vo`, `no-obss-scan`, `no-11b-rate`, `client-rate-follow`.
        """
        return pulumi.get(self, "powersave_optimize")

    @property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> Optional[str]:
        """
        Enable/disable 802.11g protection modes to support backwards compatibility with older clients (rtscts, ctsonly, disable). Valid values: `rtscts`, `ctsonly`, `disable`.
        """
        return pulumi.get(self, "protection_mode")

    @property
    @pulumi.getter(name="rtsThreshold")
    def rts_threshold(self) -> Optional[int]:
        """
        Maximum packet size for RTS transmissions, specifying the maximum size of a data packet before RTS/CTS (256 - 2346 bytes, default = 2346).
        """
        return pulumi.get(self, "rts_threshold")

    @property
    @pulumi.getter(name="samBssid")
    def sam_bssid(self) -> Optional[str]:
        """
        BSSID for WiFi network.
        """
        return pulumi.get(self, "sam_bssid")

    @property
    @pulumi.getter(name="samCaCertificate")
    def sam_ca_certificate(self) -> Optional[str]:
        """
        CA certificate for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_ca_certificate")

    @property
    @pulumi.getter(name="samCaptivePortal")
    def sam_captive_portal(self) -> Optional[str]:
        """
        Enable/disable Captive Portal Authentication (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "sam_captive_portal")

    @property
    @pulumi.getter(name="samClientCertificate")
    def sam_client_certificate(self) -> Optional[str]:
        """
        Client certificate for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_client_certificate")

    @property
    @pulumi.getter(name="samCwpFailureString")
    def sam_cwp_failure_string(self) -> Optional[str]:
        """
        Failure identification on the page after an incorrect login.
        """
        return pulumi.get(self, "sam_cwp_failure_string")

    @property
    @pulumi.getter(name="samCwpMatchString")
    def sam_cwp_match_string(self) -> Optional[str]:
        """
        Identification string from the captive portal login form.
        """
        return pulumi.get(self, "sam_cwp_match_string")

    @property
    @pulumi.getter(name="samCwpPassword")
    def sam_cwp_password(self) -> Optional[str]:
        """
        Password for captive portal authentication.
        """
        return pulumi.get(self, "sam_cwp_password")

    @property
    @pulumi.getter(name="samCwpSuccessString")
    def sam_cwp_success_string(self) -> Optional[str]:
        """
        Success identification on the page after a successful login.
        """
        return pulumi.get(self, "sam_cwp_success_string")

    @property
    @pulumi.getter(name="samCwpTestUrl")
    def sam_cwp_test_url(self) -> Optional[str]:
        """
        Website the client is trying to access.
        """
        return pulumi.get(self, "sam_cwp_test_url")

    @property
    @pulumi.getter(name="samCwpUsername")
    def sam_cwp_username(self) -> Optional[str]:
        """
        Username for captive portal authentication.
        """
        return pulumi.get(self, "sam_cwp_username")

    @property
    @pulumi.getter(name="samEapMethod")
    def sam_eap_method(self) -> Optional[str]:
        """
        Select WPA2/WPA3-ENTERPRISE EAP Method (default = PEAP). Valid values: `both`, `tls`, `peap`.
        """
        return pulumi.get(self, "sam_eap_method")

    @property
    @pulumi.getter(name="samPassword")
    def sam_password(self) -> Optional[str]:
        """
        Passphrase for WiFi network connection.
        """
        return pulumi.get(self, "sam_password")

    @property
    @pulumi.getter(name="samPrivateKey")
    def sam_private_key(self) -> Optional[str]:
        """
        Private key for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_private_key")

    @property
    @pulumi.getter(name="samPrivateKeyPassword")
    def sam_private_key_password(self) -> Optional[str]:
        """
        Password for private key file for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_private_key_password")

    @property
    @pulumi.getter(name="samReportIntv")
    def sam_report_intv(self) -> Optional[int]:
        """
        SAM report interval (sec), 0 for a one-time report.
        """
        return pulumi.get(self, "sam_report_intv")

    @property
    @pulumi.getter(name="samSecurityType")
    def sam_security_type(self) -> Optional[str]:
        """
        Select WiFi network security type (default = "wpa-personal").
        """
        return pulumi.get(self, "sam_security_type")

    @property
    @pulumi.getter(name="samServerFqdn")
    def sam_server_fqdn(self) -> Optional[str]:
        """
        SAM test server domain name.
        """
        return pulumi.get(self, "sam_server_fqdn")

    @property
    @pulumi.getter(name="samServerIp")
    def sam_server_ip(self) -> Optional[str]:
        """
        SAM test server IP address.
        """
        return pulumi.get(self, "sam_server_ip")

    @property
    @pulumi.getter(name="samServerType")
    def sam_server_type(self) -> Optional[str]:
        """
        Select SAM server type (default = "IP"). Valid values: `ip`, `fqdn`.
        """
        return pulumi.get(self, "sam_server_type")

    @property
    @pulumi.getter(name="samSsid")
    def sam_ssid(self) -> Optional[str]:
        """
        SSID for WiFi network.
        """
        return pulumi.get(self, "sam_ssid")

    @property
    @pulumi.getter(name="samTest")
    def sam_test(self) -> Optional[str]:
        """
        Select SAM test type (default = "PING"). Valid values: `ping`, `iperf`.
        """
        return pulumi.get(self, "sam_test")

    @property
    @pulumi.getter(name="samUsername")
    def sam_username(self) -> Optional[str]:
        """
        Username for WiFi network connection.
        """
        return pulumi.get(self, "sam_username")

    @property
    @pulumi.getter(name="shortGuardInterval")
    def short_guard_interval(self) -> Optional[str]:
        """
        Use either the short guard interval (Short GI) of 400 ns or the long guard interval (Long GI) of 800 ns. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "short_guard_interval")

    @property
    @pulumi.getter(name="spectrumAnalysis")
    def spectrum_analysis(self) -> Optional[str]:
        """
        Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        """
        return pulumi.get(self, "spectrum_analysis")

    @property
    @pulumi.getter(name="transmitOptimize")
    def transmit_optimize(self) -> Optional[str]:
        """
        Packet transmission optimization options including power saving, aggregation limiting, retry limiting, etc. All are enabled by default. Valid values: `disable`, `power-save`, `aggr-limit`, `retry-limit`, `send-bar`.
        """
        return pulumi.get(self, "transmit_optimize")

    @property
    @pulumi.getter(name="vapAll")
    def vap_all(self) -> Optional[str]:
        """
        Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        """
        return pulumi.get(self, "vap_all")

    @property
    @pulumi.getter
    def vaps(self) -> Optional[Sequence['outputs.WtpprofileRadio3Vap']]:
        """
        Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        """
        return pulumi.get(self, "vaps")

    @property
    @pulumi.getter(name="widsProfile")
    def wids_profile(self) -> Optional[str]:
        """
        Wireless Intrusion Detection System (WIDS) profile name to assign to the radio.
        """
        return pulumi.get(self, "wids_profile")

    @property
    @pulumi.getter(name="zeroWaitDfs")
    def zero_wait_dfs(self) -> Optional[str]:
        """
        Enable/disable zero wait DFS on radio (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "zero_wait_dfs")


@pulumi.output_type
class WtpprofileRadio3Channel(dict):
    def __init__(__self__, *,
                 chan: Optional[str] = None):
        """
        :param str chan: Channel number.
        """
        if chan is not None:
            pulumi.set(__self__, "chan", chan)

    @property
    @pulumi.getter
    def chan(self) -> Optional[str]:
        """
        Channel number.
        """
        return pulumi.get(self, "chan")


@pulumi.output_type
class WtpprofileRadio3Vap(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Virtual Access Point (VAP) name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Virtual Access Point (VAP) name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WtpprofileRadio4(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "airtimeFairness":
            suggest = "airtime_fairness"
        elif key == "apHandoff":
            suggest = "ap_handoff"
        elif key == "apSnifferAddr":
            suggest = "ap_sniffer_addr"
        elif key == "apSnifferBufsize":
            suggest = "ap_sniffer_bufsize"
        elif key == "apSnifferChan":
            suggest = "ap_sniffer_chan"
        elif key == "apSnifferCtl":
            suggest = "ap_sniffer_ctl"
        elif key == "apSnifferData":
            suggest = "ap_sniffer_data"
        elif key == "apSnifferMgmtBeacon":
            suggest = "ap_sniffer_mgmt_beacon"
        elif key == "apSnifferMgmtOther":
            suggest = "ap_sniffer_mgmt_other"
        elif key == "apSnifferMgmtProbe":
            suggest = "ap_sniffer_mgmt_probe"
        elif key == "arrpProfile":
            suggest = "arrp_profile"
        elif key == "autoPowerHigh":
            suggest = "auto_power_high"
        elif key == "autoPowerLevel":
            suggest = "auto_power_level"
        elif key == "autoPowerLow":
            suggest = "auto_power_low"
        elif key == "autoPowerTarget":
            suggest = "auto_power_target"
        elif key == "band5gType":
            suggest = "band5g_type"
        elif key == "bandwidthAdmissionControl":
            suggest = "bandwidth_admission_control"
        elif key == "bandwidthCapacity":
            suggest = "bandwidth_capacity"
        elif key == "beaconInterval":
            suggest = "beacon_interval"
        elif key == "bssColor":
            suggest = "bss_color"
        elif key == "bssColorMode":
            suggest = "bss_color_mode"
        elif key == "callAdmissionControl":
            suggest = "call_admission_control"
        elif key == "callCapacity":
            suggest = "call_capacity"
        elif key == "channelBonding":
            suggest = "channel_bonding"
        elif key == "channelUtilization":
            suggest = "channel_utilization"
        elif key == "drmaSensitivity":
            suggest = "drma_sensitivity"
        elif key == "fragThreshold":
            suggest = "frag_threshold"
        elif key == "frequencyHandoff":
            suggest = "frequency_handoff"
        elif key == "iperfProtocol":
            suggest = "iperf_protocol"
        elif key == "iperfServerPort":
            suggest = "iperf_server_port"
        elif key == "maxClients":
            suggest = "max_clients"
        elif key == "maxDistance":
            suggest = "max_distance"
        elif key == "mimoMode":
            suggest = "mimo_mode"
        elif key == "optionalAntenna":
            suggest = "optional_antenna"
        elif key == "optionalAntennaGain":
            suggest = "optional_antenna_gain"
        elif key == "powerLevel":
            suggest = "power_level"
        elif key == "powerMode":
            suggest = "power_mode"
        elif key == "powerValue":
            suggest = "power_value"
        elif key == "powersaveOptimize":
            suggest = "powersave_optimize"
        elif key == "protectionMode":
            suggest = "protection_mode"
        elif key == "rtsThreshold":
            suggest = "rts_threshold"
        elif key == "samBssid":
            suggest = "sam_bssid"
        elif key == "samCaCertificate":
            suggest = "sam_ca_certificate"
        elif key == "samCaptivePortal":
            suggest = "sam_captive_portal"
        elif key == "samClientCertificate":
            suggest = "sam_client_certificate"
        elif key == "samCwpFailureString":
            suggest = "sam_cwp_failure_string"
        elif key == "samCwpMatchString":
            suggest = "sam_cwp_match_string"
        elif key == "samCwpPassword":
            suggest = "sam_cwp_password"
        elif key == "samCwpSuccessString":
            suggest = "sam_cwp_success_string"
        elif key == "samCwpTestUrl":
            suggest = "sam_cwp_test_url"
        elif key == "samCwpUsername":
            suggest = "sam_cwp_username"
        elif key == "samEapMethod":
            suggest = "sam_eap_method"
        elif key == "samPassword":
            suggest = "sam_password"
        elif key == "samPrivateKey":
            suggest = "sam_private_key"
        elif key == "samPrivateKeyPassword":
            suggest = "sam_private_key_password"
        elif key == "samReportIntv":
            suggest = "sam_report_intv"
        elif key == "samSecurityType":
            suggest = "sam_security_type"
        elif key == "samServerFqdn":
            suggest = "sam_server_fqdn"
        elif key == "samServerIp":
            suggest = "sam_server_ip"
        elif key == "samServerType":
            suggest = "sam_server_type"
        elif key == "samSsid":
            suggest = "sam_ssid"
        elif key == "samTest":
            suggest = "sam_test"
        elif key == "samUsername":
            suggest = "sam_username"
        elif key == "shortGuardInterval":
            suggest = "short_guard_interval"
        elif key == "spectrumAnalysis":
            suggest = "spectrum_analysis"
        elif key == "transmitOptimize":
            suggest = "transmit_optimize"
        elif key == "vapAll":
            suggest = "vap_all"
        elif key == "widsProfile":
            suggest = "wids_profile"
        elif key == "zeroWaitDfs":
            suggest = "zero_wait_dfs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpprofileRadio4. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpprofileRadio4.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpprofileRadio4.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 airtime_fairness: Optional[str] = None,
                 amsdu: Optional[str] = None,
                 ap_handoff: Optional[str] = None,
                 ap_sniffer_addr: Optional[str] = None,
                 ap_sniffer_bufsize: Optional[int] = None,
                 ap_sniffer_chan: Optional[int] = None,
                 ap_sniffer_ctl: Optional[str] = None,
                 ap_sniffer_data: Optional[str] = None,
                 ap_sniffer_mgmt_beacon: Optional[str] = None,
                 ap_sniffer_mgmt_other: Optional[str] = None,
                 ap_sniffer_mgmt_probe: Optional[str] = None,
                 arrp_profile: Optional[str] = None,
                 auto_power_high: Optional[int] = None,
                 auto_power_level: Optional[str] = None,
                 auto_power_low: Optional[int] = None,
                 auto_power_target: Optional[str] = None,
                 band: Optional[str] = None,
                 band5g_type: Optional[str] = None,
                 bandwidth_admission_control: Optional[str] = None,
                 bandwidth_capacity: Optional[int] = None,
                 beacon_interval: Optional[int] = None,
                 bss_color: Optional[int] = None,
                 bss_color_mode: Optional[str] = None,
                 call_admission_control: Optional[str] = None,
                 call_capacity: Optional[int] = None,
                 channel_bonding: Optional[str] = None,
                 channel_utilization: Optional[str] = None,
                 channels: Optional[Sequence['outputs.WtpprofileRadio4Channel']] = None,
                 coexistence: Optional[str] = None,
                 darrp: Optional[str] = None,
                 drma: Optional[str] = None,
                 drma_sensitivity: Optional[str] = None,
                 dtim: Optional[int] = None,
                 frag_threshold: Optional[int] = None,
                 frequency_handoff: Optional[str] = None,
                 iperf_protocol: Optional[str] = None,
                 iperf_server_port: Optional[int] = None,
                 max_clients: Optional[int] = None,
                 max_distance: Optional[int] = None,
                 mimo_mode: Optional[str] = None,
                 mode: Optional[str] = None,
                 n80211d: Optional[str] = None,
                 optional_antenna: Optional[str] = None,
                 optional_antenna_gain: Optional[str] = None,
                 power_level: Optional[int] = None,
                 power_mode: Optional[str] = None,
                 power_value: Optional[int] = None,
                 powersave_optimize: Optional[str] = None,
                 protection_mode: Optional[str] = None,
                 rts_threshold: Optional[int] = None,
                 sam_bssid: Optional[str] = None,
                 sam_ca_certificate: Optional[str] = None,
                 sam_captive_portal: Optional[str] = None,
                 sam_client_certificate: Optional[str] = None,
                 sam_cwp_failure_string: Optional[str] = None,
                 sam_cwp_match_string: Optional[str] = None,
                 sam_cwp_password: Optional[str] = None,
                 sam_cwp_success_string: Optional[str] = None,
                 sam_cwp_test_url: Optional[str] = None,
                 sam_cwp_username: Optional[str] = None,
                 sam_eap_method: Optional[str] = None,
                 sam_password: Optional[str] = None,
                 sam_private_key: Optional[str] = None,
                 sam_private_key_password: Optional[str] = None,
                 sam_report_intv: Optional[int] = None,
                 sam_security_type: Optional[str] = None,
                 sam_server_fqdn: Optional[str] = None,
                 sam_server_ip: Optional[str] = None,
                 sam_server_type: Optional[str] = None,
                 sam_ssid: Optional[str] = None,
                 sam_test: Optional[str] = None,
                 sam_username: Optional[str] = None,
                 short_guard_interval: Optional[str] = None,
                 spectrum_analysis: Optional[str] = None,
                 transmit_optimize: Optional[str] = None,
                 vap_all: Optional[str] = None,
                 vaps: Optional[Sequence['outputs.WtpprofileRadio4Vap']] = None,
                 wids_profile: Optional[str] = None,
                 zero_wait_dfs: Optional[str] = None):
        """
        :param str airtime_fairness: Enable/disable airtime fairness (default = disable). Valid values: `enable`, `disable`.
        :param str amsdu: Enable/disable 802.11n AMSDU support. AMSDU can improve performance if supported by your WiFi clients (default = enable). Valid values: `enable`, `disable`.
        :param str ap_handoff: Enable/disable AP handoff of clients to other APs (default = disable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_addr: MAC address to monitor.
        :param int ap_sniffer_bufsize: Sniffer buffer size (1 - 32 MB, default = 16).
        :param int ap_sniffer_chan: Channel on which to operate the sniffer (default = 6).
        :param str ap_sniffer_ctl: Enable/disable sniffer on WiFi control frame (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_data: Enable/disable sniffer on WiFi data frame (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_mgmt_beacon: Enable/disable sniffer on WiFi management Beacon frames (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_mgmt_other: Enable/disable sniffer on WiFi management other frames  (default = enable). Valid values: `enable`, `disable`.
        :param str ap_sniffer_mgmt_probe: Enable/disable sniffer on WiFi management probe frames (default = enable). Valid values: `enable`, `disable`.
        :param str arrp_profile: Distributed Automatic Radio Resource Provisioning (DARRP) profile name to assign to the radio.
        :param int auto_power_high: The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_level: Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        :param int auto_power_low: The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        :param str auto_power_target: The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        :param str band: WiFi band that Radio 3 operates on.
        :param str band5g_type: WiFi 5G band type. Valid values: `5g-full`, `5g-high`, `5g-low`.
        :param str bandwidth_admission_control: Enable/disable WiFi multimedia (WMM) bandwidth admission control to optimize WiFi bandwidth use. A request to join the wireless network is only allowed if the access point has enough bandwidth to support it. Valid values: `enable`, `disable`.
        :param int bandwidth_capacity: Maximum bandwidth capacity allowed (1 - 600000 Kbps, default = 2000).
        :param int beacon_interval: Beacon interval. The time between beacon frames in msec (the actual range of beacon interval depends on the AP platform type, default = 100).
        :param int bss_color: BSS color value for this 11ax radio (0 - 63, 0 means disable. default = 0).
        :param str bss_color_mode: BSS color mode for this 11ax radio (default = auto). Valid values: `auto`, `static`.
        :param str call_admission_control: Enable/disable WiFi multimedia (WMM) call admission control to optimize WiFi bandwidth use for VoIP calls. New VoIP calls are only accepted if there is enough bandwidth available to support them. Valid values: `enable`, `disable`.
        :param int call_capacity: Maximum number of Voice over WLAN (VoWLAN) phones supported by the radio (0 - 60, default = 10).
        :param str channel_bonding: Channel bandwidth: 160,80, 40, or 20MHz. Channels may use both 20 and 40 by enabling coexistence. Valid values: `160MHz`, `80MHz`, `40MHz`, `20MHz`.
        :param str channel_utilization: Enable/disable measuring channel utilization. Valid values: `enable`, `disable`.
        :param Sequence['WtpprofileRadio4ChannelArgs'] channels: Selected list of wireless radio channels. The structure of `channel` block is documented below.
        :param str coexistence: Enable/disable allowing both HT20 and HT40 on the same radio (default = enable). Valid values: `enable`, `disable`.
        :param str darrp: Enable/disable Distributed Automatic Radio Resource Provisioning (DARRP) to make sure the radio is always using the most optimal channel (default = disable). Valid values: `enable`, `disable`.
        :param str drma: Enable/disable dynamic radio mode assignment (DRMA) (default = disable). Valid values: `disable`, `enable`.
        :param str drma_sensitivity: Network Coverage Factor (NCF) percentage required to consider a radio as redundant (default = low). Valid values: `low`, `medium`, `high`.
        :param int dtim: Delivery Traffic Indication Map (DTIM) period (1 - 255, default = 1). Set higher to save battery life of WiFi client in power-save mode.
        :param int frag_threshold: Maximum packet size that can be sent without fragmentation (800 - 2346 bytes, default = 2346).
        :param str frequency_handoff: Enable/disable frequency handoff of clients to other channels (default = disable). Valid values: `enable`, `disable`.
        :param str iperf_protocol: Iperf test protocol (default = "UDP"). Valid values: `udp`, `tcp`.
        :param int iperf_server_port: Iperf service port number.
        :param int max_clients: Maximum number of stations (STAs) supported by the WTP (default = 0, meaning no client limitation).
        :param int max_distance: Maximum expected distance between the AP and clients (0 - 54000 m, default = 0).
        :param str mimo_mode: Configure radio MIMO mode (default = default). Valid values: `default`, `1x1`, `2x2`, `3x3`, `4x4`, `8x8`.
        :param str mode: Mode of radio 3. Radio 3 can be disabled, configured as an access point, a rogue AP monitor, or a sniffer.
        :param str n80211d: Enable/disable 802.11d countryie(default = enable). Valid values: `enable`, `disable`.
        :param str optional_antenna: Optional antenna used on FAP (default = none).
        :param str optional_antenna_gain: Optional antenna gain in dBi (0 to 20, default = 0).
        :param int power_level: Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        :param str power_mode: Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        :param int power_value: Radio EIRP power in dBm (1 - 33, default = 27).
        :param str powersave_optimize: Enable client power-saving features such as TIM, AC VO, and OBSS etc. Valid values: `tim`, `ac-vo`, `no-obss-scan`, `no-11b-rate`, `client-rate-follow`.
        :param str protection_mode: Enable/disable 802.11g protection modes to support backwards compatibility with older clients (rtscts, ctsonly, disable). Valid values: `rtscts`, `ctsonly`, `disable`.
        :param int rts_threshold: Maximum packet size for RTS transmissions, specifying the maximum size of a data packet before RTS/CTS (256 - 2346 bytes, default = 2346).
        :param str sam_bssid: BSSID for WiFi network.
        :param str sam_ca_certificate: CA certificate for WPA2/WPA3-ENTERPRISE.
        :param str sam_captive_portal: Enable/disable Captive Portal Authentication (default = disable). Valid values: `enable`, `disable`.
        :param str sam_client_certificate: Client certificate for WPA2/WPA3-ENTERPRISE.
        :param str sam_cwp_failure_string: Failure identification on the page after an incorrect login.
        :param str sam_cwp_match_string: Identification string from the captive portal login form.
        :param str sam_cwp_password: Password for captive portal authentication.
        :param str sam_cwp_success_string: Success identification on the page after a successful login.
        :param str sam_cwp_test_url: Website the client is trying to access.
        :param str sam_cwp_username: Username for captive portal authentication.
        :param str sam_eap_method: Select WPA2/WPA3-ENTERPRISE EAP Method (default = PEAP). Valid values: `both`, `tls`, `peap`.
        :param str sam_password: Passphrase for WiFi network connection.
        :param str sam_private_key: Private key for WPA2/WPA3-ENTERPRISE.
        :param str sam_private_key_password: Password for private key file for WPA2/WPA3-ENTERPRISE.
        :param int sam_report_intv: SAM report interval (sec), 0 for a one-time report.
        :param str sam_security_type: Select WiFi network security type (default = "wpa-personal").
        :param str sam_server_fqdn: SAM test server domain name.
        :param str sam_server_ip: SAM test server IP address.
        :param str sam_server_type: Select SAM server type (default = "IP"). Valid values: `ip`, `fqdn`.
        :param str sam_ssid: SSID for WiFi network.
        :param str sam_test: Select SAM test type (default = "PING"). Valid values: `ping`, `iperf`.
        :param str sam_username: Username for WiFi network connection.
        :param str short_guard_interval: Use either the short guard interval (Short GI) of 400 ns or the long guard interval (Long GI) of 800 ns. Valid values: `enable`, `disable`.
        :param str spectrum_analysis: Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        :param str transmit_optimize: Packet transmission optimization options including power saving, aggregation limiting, retry limiting, etc. All are enabled by default. Valid values: `disable`, `power-save`, `aggr-limit`, `retry-limit`, `send-bar`.
        :param str vap_all: Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        :param Sequence['WtpprofileRadio4VapArgs'] vaps: Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        :param str wids_profile: Wireless Intrusion Detection System (WIDS) profile name to assign to the radio.
        :param str zero_wait_dfs: Enable/disable zero wait DFS on radio (default = enable). Valid values: `enable`, `disable`.
        """
        if airtime_fairness is not None:
            pulumi.set(__self__, "airtime_fairness", airtime_fairness)
        if amsdu is not None:
            pulumi.set(__self__, "amsdu", amsdu)
        if ap_handoff is not None:
            pulumi.set(__self__, "ap_handoff", ap_handoff)
        if ap_sniffer_addr is not None:
            pulumi.set(__self__, "ap_sniffer_addr", ap_sniffer_addr)
        if ap_sniffer_bufsize is not None:
            pulumi.set(__self__, "ap_sniffer_bufsize", ap_sniffer_bufsize)
        if ap_sniffer_chan is not None:
            pulumi.set(__self__, "ap_sniffer_chan", ap_sniffer_chan)
        if ap_sniffer_ctl is not None:
            pulumi.set(__self__, "ap_sniffer_ctl", ap_sniffer_ctl)
        if ap_sniffer_data is not None:
            pulumi.set(__self__, "ap_sniffer_data", ap_sniffer_data)
        if ap_sniffer_mgmt_beacon is not None:
            pulumi.set(__self__, "ap_sniffer_mgmt_beacon", ap_sniffer_mgmt_beacon)
        if ap_sniffer_mgmt_other is not None:
            pulumi.set(__self__, "ap_sniffer_mgmt_other", ap_sniffer_mgmt_other)
        if ap_sniffer_mgmt_probe is not None:
            pulumi.set(__self__, "ap_sniffer_mgmt_probe", ap_sniffer_mgmt_probe)
        if arrp_profile is not None:
            pulumi.set(__self__, "arrp_profile", arrp_profile)
        if auto_power_high is not None:
            pulumi.set(__self__, "auto_power_high", auto_power_high)
        if auto_power_level is not None:
            pulumi.set(__self__, "auto_power_level", auto_power_level)
        if auto_power_low is not None:
            pulumi.set(__self__, "auto_power_low", auto_power_low)
        if auto_power_target is not None:
            pulumi.set(__self__, "auto_power_target", auto_power_target)
        if band is not None:
            pulumi.set(__self__, "band", band)
        if band5g_type is not None:
            pulumi.set(__self__, "band5g_type", band5g_type)
        if bandwidth_admission_control is not None:
            pulumi.set(__self__, "bandwidth_admission_control", bandwidth_admission_control)
        if bandwidth_capacity is not None:
            pulumi.set(__self__, "bandwidth_capacity", bandwidth_capacity)
        if beacon_interval is not None:
            pulumi.set(__self__, "beacon_interval", beacon_interval)
        if bss_color is not None:
            pulumi.set(__self__, "bss_color", bss_color)
        if bss_color_mode is not None:
            pulumi.set(__self__, "bss_color_mode", bss_color_mode)
        if call_admission_control is not None:
            pulumi.set(__self__, "call_admission_control", call_admission_control)
        if call_capacity is not None:
            pulumi.set(__self__, "call_capacity", call_capacity)
        if channel_bonding is not None:
            pulumi.set(__self__, "channel_bonding", channel_bonding)
        if channel_utilization is not None:
            pulumi.set(__self__, "channel_utilization", channel_utilization)
        if channels is not None:
            pulumi.set(__self__, "channels", channels)
        if coexistence is not None:
            pulumi.set(__self__, "coexistence", coexistence)
        if darrp is not None:
            pulumi.set(__self__, "darrp", darrp)
        if drma is not None:
            pulumi.set(__self__, "drma", drma)
        if drma_sensitivity is not None:
            pulumi.set(__self__, "drma_sensitivity", drma_sensitivity)
        if dtim is not None:
            pulumi.set(__self__, "dtim", dtim)
        if frag_threshold is not None:
            pulumi.set(__self__, "frag_threshold", frag_threshold)
        if frequency_handoff is not None:
            pulumi.set(__self__, "frequency_handoff", frequency_handoff)
        if iperf_protocol is not None:
            pulumi.set(__self__, "iperf_protocol", iperf_protocol)
        if iperf_server_port is not None:
            pulumi.set(__self__, "iperf_server_port", iperf_server_port)
        if max_clients is not None:
            pulumi.set(__self__, "max_clients", max_clients)
        if max_distance is not None:
            pulumi.set(__self__, "max_distance", max_distance)
        if mimo_mode is not None:
            pulumi.set(__self__, "mimo_mode", mimo_mode)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if n80211d is not None:
            pulumi.set(__self__, "n80211d", n80211d)
        if optional_antenna is not None:
            pulumi.set(__self__, "optional_antenna", optional_antenna)
        if optional_antenna_gain is not None:
            pulumi.set(__self__, "optional_antenna_gain", optional_antenna_gain)
        if power_level is not None:
            pulumi.set(__self__, "power_level", power_level)
        if power_mode is not None:
            pulumi.set(__self__, "power_mode", power_mode)
        if power_value is not None:
            pulumi.set(__self__, "power_value", power_value)
        if powersave_optimize is not None:
            pulumi.set(__self__, "powersave_optimize", powersave_optimize)
        if protection_mode is not None:
            pulumi.set(__self__, "protection_mode", protection_mode)
        if rts_threshold is not None:
            pulumi.set(__self__, "rts_threshold", rts_threshold)
        if sam_bssid is not None:
            pulumi.set(__self__, "sam_bssid", sam_bssid)
        if sam_ca_certificate is not None:
            pulumi.set(__self__, "sam_ca_certificate", sam_ca_certificate)
        if sam_captive_portal is not None:
            pulumi.set(__self__, "sam_captive_portal", sam_captive_portal)
        if sam_client_certificate is not None:
            pulumi.set(__self__, "sam_client_certificate", sam_client_certificate)
        if sam_cwp_failure_string is not None:
            pulumi.set(__self__, "sam_cwp_failure_string", sam_cwp_failure_string)
        if sam_cwp_match_string is not None:
            pulumi.set(__self__, "sam_cwp_match_string", sam_cwp_match_string)
        if sam_cwp_password is not None:
            pulumi.set(__self__, "sam_cwp_password", sam_cwp_password)
        if sam_cwp_success_string is not None:
            pulumi.set(__self__, "sam_cwp_success_string", sam_cwp_success_string)
        if sam_cwp_test_url is not None:
            pulumi.set(__self__, "sam_cwp_test_url", sam_cwp_test_url)
        if sam_cwp_username is not None:
            pulumi.set(__self__, "sam_cwp_username", sam_cwp_username)
        if sam_eap_method is not None:
            pulumi.set(__self__, "sam_eap_method", sam_eap_method)
        if sam_password is not None:
            pulumi.set(__self__, "sam_password", sam_password)
        if sam_private_key is not None:
            pulumi.set(__self__, "sam_private_key", sam_private_key)
        if sam_private_key_password is not None:
            pulumi.set(__self__, "sam_private_key_password", sam_private_key_password)
        if sam_report_intv is not None:
            pulumi.set(__self__, "sam_report_intv", sam_report_intv)
        if sam_security_type is not None:
            pulumi.set(__self__, "sam_security_type", sam_security_type)
        if sam_server_fqdn is not None:
            pulumi.set(__self__, "sam_server_fqdn", sam_server_fqdn)
        if sam_server_ip is not None:
            pulumi.set(__self__, "sam_server_ip", sam_server_ip)
        if sam_server_type is not None:
            pulumi.set(__self__, "sam_server_type", sam_server_type)
        if sam_ssid is not None:
            pulumi.set(__self__, "sam_ssid", sam_ssid)
        if sam_test is not None:
            pulumi.set(__self__, "sam_test", sam_test)
        if sam_username is not None:
            pulumi.set(__self__, "sam_username", sam_username)
        if short_guard_interval is not None:
            pulumi.set(__self__, "short_guard_interval", short_guard_interval)
        if spectrum_analysis is not None:
            pulumi.set(__self__, "spectrum_analysis", spectrum_analysis)
        if transmit_optimize is not None:
            pulumi.set(__self__, "transmit_optimize", transmit_optimize)
        if vap_all is not None:
            pulumi.set(__self__, "vap_all", vap_all)
        if vaps is not None:
            pulumi.set(__self__, "vaps", vaps)
        if wids_profile is not None:
            pulumi.set(__self__, "wids_profile", wids_profile)
        if zero_wait_dfs is not None:
            pulumi.set(__self__, "zero_wait_dfs", zero_wait_dfs)

    @property
    @pulumi.getter(name="airtimeFairness")
    def airtime_fairness(self) -> Optional[str]:
        """
        Enable/disable airtime fairness (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "airtime_fairness")

    @property
    @pulumi.getter
    def amsdu(self) -> Optional[str]:
        """
        Enable/disable 802.11n AMSDU support. AMSDU can improve performance if supported by your WiFi clients (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "amsdu")

    @property
    @pulumi.getter(name="apHandoff")
    def ap_handoff(self) -> Optional[str]:
        """
        Enable/disable AP handoff of clients to other APs (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_handoff")

    @property
    @pulumi.getter(name="apSnifferAddr")
    def ap_sniffer_addr(self) -> Optional[str]:
        """
        MAC address to monitor.
        """
        return pulumi.get(self, "ap_sniffer_addr")

    @property
    @pulumi.getter(name="apSnifferBufsize")
    def ap_sniffer_bufsize(self) -> Optional[int]:
        """
        Sniffer buffer size (1 - 32 MB, default = 16).
        """
        return pulumi.get(self, "ap_sniffer_bufsize")

    @property
    @pulumi.getter(name="apSnifferChan")
    def ap_sniffer_chan(self) -> Optional[int]:
        """
        Channel on which to operate the sniffer (default = 6).
        """
        return pulumi.get(self, "ap_sniffer_chan")

    @property
    @pulumi.getter(name="apSnifferCtl")
    def ap_sniffer_ctl(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi control frame (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_ctl")

    @property
    @pulumi.getter(name="apSnifferData")
    def ap_sniffer_data(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi data frame (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_data")

    @property
    @pulumi.getter(name="apSnifferMgmtBeacon")
    def ap_sniffer_mgmt_beacon(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi management Beacon frames (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_mgmt_beacon")

    @property
    @pulumi.getter(name="apSnifferMgmtOther")
    def ap_sniffer_mgmt_other(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi management other frames  (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_mgmt_other")

    @property
    @pulumi.getter(name="apSnifferMgmtProbe")
    def ap_sniffer_mgmt_probe(self) -> Optional[str]:
        """
        Enable/disable sniffer on WiFi management probe frames (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "ap_sniffer_mgmt_probe")

    @property
    @pulumi.getter(name="arrpProfile")
    def arrp_profile(self) -> Optional[str]:
        """
        Distributed Automatic Radio Resource Provisioning (DARRP) profile name to assign to the radio.
        """
        return pulumi.get(self, "arrp_profile")

    @property
    @pulumi.getter(name="autoPowerHigh")
    def auto_power_high(self) -> Optional[int]:
        """
        The upper bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_high")

    @property
    @pulumi.getter(name="autoPowerLevel")
    def auto_power_level(self) -> Optional[str]:
        """
        Enable/disable automatic power-level adjustment to prevent co-channel interference (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "auto_power_level")

    @property
    @pulumi.getter(name="autoPowerLow")
    def auto_power_low(self) -> Optional[int]:
        """
        The lower bound of automatic transmit power adjustment in dBm (the actual range of transmit power depends on the AP platform type).
        """
        return pulumi.get(self, "auto_power_low")

    @property
    @pulumi.getter(name="autoPowerTarget")
    def auto_power_target(self) -> Optional[str]:
        """
        The target of automatic transmit power adjustment in dBm. (-95 to -20, default = -70).
        """
        return pulumi.get(self, "auto_power_target")

    @property
    @pulumi.getter
    def band(self) -> Optional[str]:
        """
        WiFi band that Radio 3 operates on.
        """
        return pulumi.get(self, "band")

    @property
    @pulumi.getter(name="band5gType")
    def band5g_type(self) -> Optional[str]:
        """
        WiFi 5G band type. Valid values: `5g-full`, `5g-high`, `5g-low`.
        """
        return pulumi.get(self, "band5g_type")

    @property
    @pulumi.getter(name="bandwidthAdmissionControl")
    def bandwidth_admission_control(self) -> Optional[str]:
        """
        Enable/disable WiFi multimedia (WMM) bandwidth admission control to optimize WiFi bandwidth use. A request to join the wireless network is only allowed if the access point has enough bandwidth to support it. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "bandwidth_admission_control")

    @property
    @pulumi.getter(name="bandwidthCapacity")
    def bandwidth_capacity(self) -> Optional[int]:
        """
        Maximum bandwidth capacity allowed (1 - 600000 Kbps, default = 2000).
        """
        return pulumi.get(self, "bandwidth_capacity")

    @property
    @pulumi.getter(name="beaconInterval")
    def beacon_interval(self) -> Optional[int]:
        """
        Beacon interval. The time between beacon frames in msec (the actual range of beacon interval depends on the AP platform type, default = 100).
        """
        return pulumi.get(self, "beacon_interval")

    @property
    @pulumi.getter(name="bssColor")
    def bss_color(self) -> Optional[int]:
        """
        BSS color value for this 11ax radio (0 - 63, 0 means disable. default = 0).
        """
        return pulumi.get(self, "bss_color")

    @property
    @pulumi.getter(name="bssColorMode")
    def bss_color_mode(self) -> Optional[str]:
        """
        BSS color mode for this 11ax radio (default = auto). Valid values: `auto`, `static`.
        """
        return pulumi.get(self, "bss_color_mode")

    @property
    @pulumi.getter(name="callAdmissionControl")
    def call_admission_control(self) -> Optional[str]:
        """
        Enable/disable WiFi multimedia (WMM) call admission control to optimize WiFi bandwidth use for VoIP calls. New VoIP calls are only accepted if there is enough bandwidth available to support them. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "call_admission_control")

    @property
    @pulumi.getter(name="callCapacity")
    def call_capacity(self) -> Optional[int]:
        """
        Maximum number of Voice over WLAN (VoWLAN) phones supported by the radio (0 - 60, default = 10).
        """
        return pulumi.get(self, "call_capacity")

    @property
    @pulumi.getter(name="channelBonding")
    def channel_bonding(self) -> Optional[str]:
        """
        Channel bandwidth: 160,80, 40, or 20MHz. Channels may use both 20 and 40 by enabling coexistence. Valid values: `160MHz`, `80MHz`, `40MHz`, `20MHz`.
        """
        return pulumi.get(self, "channel_bonding")

    @property
    @pulumi.getter(name="channelUtilization")
    def channel_utilization(self) -> Optional[str]:
        """
        Enable/disable measuring channel utilization. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "channel_utilization")

    @property
    @pulumi.getter
    def channels(self) -> Optional[Sequence['outputs.WtpprofileRadio4Channel']]:
        """
        Selected list of wireless radio channels. The structure of `channel` block is documented below.
        """
        return pulumi.get(self, "channels")

    @property
    @pulumi.getter
    def coexistence(self) -> Optional[str]:
        """
        Enable/disable allowing both HT20 and HT40 on the same radio (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "coexistence")

    @property
    @pulumi.getter
    def darrp(self) -> Optional[str]:
        """
        Enable/disable Distributed Automatic Radio Resource Provisioning (DARRP) to make sure the radio is always using the most optimal channel (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "darrp")

    @property
    @pulumi.getter
    def drma(self) -> Optional[str]:
        """
        Enable/disable dynamic radio mode assignment (DRMA) (default = disable). Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "drma")

    @property
    @pulumi.getter(name="drmaSensitivity")
    def drma_sensitivity(self) -> Optional[str]:
        """
        Network Coverage Factor (NCF) percentage required to consider a radio as redundant (default = low). Valid values: `low`, `medium`, `high`.
        """
        return pulumi.get(self, "drma_sensitivity")

    @property
    @pulumi.getter
    def dtim(self) -> Optional[int]:
        """
        Delivery Traffic Indication Map (DTIM) period (1 - 255, default = 1). Set higher to save battery life of WiFi client in power-save mode.
        """
        return pulumi.get(self, "dtim")

    @property
    @pulumi.getter(name="fragThreshold")
    def frag_threshold(self) -> Optional[int]:
        """
        Maximum packet size that can be sent without fragmentation (800 - 2346 bytes, default = 2346).
        """
        return pulumi.get(self, "frag_threshold")

    @property
    @pulumi.getter(name="frequencyHandoff")
    def frequency_handoff(self) -> Optional[str]:
        """
        Enable/disable frequency handoff of clients to other channels (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "frequency_handoff")

    @property
    @pulumi.getter(name="iperfProtocol")
    def iperf_protocol(self) -> Optional[str]:
        """
        Iperf test protocol (default = "UDP"). Valid values: `udp`, `tcp`.
        """
        return pulumi.get(self, "iperf_protocol")

    @property
    @pulumi.getter(name="iperfServerPort")
    def iperf_server_port(self) -> Optional[int]:
        """
        Iperf service port number.
        """
        return pulumi.get(self, "iperf_server_port")

    @property
    @pulumi.getter(name="maxClients")
    def max_clients(self) -> Optional[int]:
        """
        Maximum number of stations (STAs) supported by the WTP (default = 0, meaning no client limitation).
        """
        return pulumi.get(self, "max_clients")

    @property
    @pulumi.getter(name="maxDistance")
    def max_distance(self) -> Optional[int]:
        """
        Maximum expected distance between the AP and clients (0 - 54000 m, default = 0).
        """
        return pulumi.get(self, "max_distance")

    @property
    @pulumi.getter(name="mimoMode")
    def mimo_mode(self) -> Optional[str]:
        """
        Configure radio MIMO mode (default = default). Valid values: `default`, `1x1`, `2x2`, `3x3`, `4x4`, `8x8`.
        """
        return pulumi.get(self, "mimo_mode")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        Mode of radio 3. Radio 3 can be disabled, configured as an access point, a rogue AP monitor, or a sniffer.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter
    def n80211d(self) -> Optional[str]:
        """
        Enable/disable 802.11d countryie(default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "n80211d")

    @property
    @pulumi.getter(name="optionalAntenna")
    def optional_antenna(self) -> Optional[str]:
        """
        Optional antenna used on FAP (default = none).
        """
        return pulumi.get(self, "optional_antenna")

    @property
    @pulumi.getter(name="optionalAntennaGain")
    def optional_antenna_gain(self) -> Optional[str]:
        """
        Optional antenna gain in dBi (0 to 20, default = 0).
        """
        return pulumi.get(self, "optional_antenna_gain")

    @property
    @pulumi.getter(name="powerLevel")
    def power_level(self) -> Optional[int]:
        """
        Radio power level as a percentage of the maximum transmit power (0 - 100, default = 100).
        """
        return pulumi.get(self, "power_level")

    @property
    @pulumi.getter(name="powerMode")
    def power_mode(self) -> Optional[str]:
        """
        Set radio effective isotropic radiated power (EIRP) in dBm or by a percentage of the maximum EIRP (default = percentage). This power takes into account both radio transmit power and antenna gain. Higher power level settings may be constrained by local regulatory requirements and AP capabilities. Valid values: `dBm`, `percentage`.
        """
        return pulumi.get(self, "power_mode")

    @property
    @pulumi.getter(name="powerValue")
    def power_value(self) -> Optional[int]:
        """
        Radio EIRP power in dBm (1 - 33, default = 27).
        """
        return pulumi.get(self, "power_value")

    @property
    @pulumi.getter(name="powersaveOptimize")
    def powersave_optimize(self) -> Optional[str]:
        """
        Enable client power-saving features such as TIM, AC VO, and OBSS etc. Valid values: `tim`, `ac-vo`, `no-obss-scan`, `no-11b-rate`, `client-rate-follow`.
        """
        return pulumi.get(self, "powersave_optimize")

    @property
    @pulumi.getter(name="protectionMode")
    def protection_mode(self) -> Optional[str]:
        """
        Enable/disable 802.11g protection modes to support backwards compatibility with older clients (rtscts, ctsonly, disable). Valid values: `rtscts`, `ctsonly`, `disable`.
        """
        return pulumi.get(self, "protection_mode")

    @property
    @pulumi.getter(name="rtsThreshold")
    def rts_threshold(self) -> Optional[int]:
        """
        Maximum packet size for RTS transmissions, specifying the maximum size of a data packet before RTS/CTS (256 - 2346 bytes, default = 2346).
        """
        return pulumi.get(self, "rts_threshold")

    @property
    @pulumi.getter(name="samBssid")
    def sam_bssid(self) -> Optional[str]:
        """
        BSSID for WiFi network.
        """
        return pulumi.get(self, "sam_bssid")

    @property
    @pulumi.getter(name="samCaCertificate")
    def sam_ca_certificate(self) -> Optional[str]:
        """
        CA certificate for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_ca_certificate")

    @property
    @pulumi.getter(name="samCaptivePortal")
    def sam_captive_portal(self) -> Optional[str]:
        """
        Enable/disable Captive Portal Authentication (default = disable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "sam_captive_portal")

    @property
    @pulumi.getter(name="samClientCertificate")
    def sam_client_certificate(self) -> Optional[str]:
        """
        Client certificate for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_client_certificate")

    @property
    @pulumi.getter(name="samCwpFailureString")
    def sam_cwp_failure_string(self) -> Optional[str]:
        """
        Failure identification on the page after an incorrect login.
        """
        return pulumi.get(self, "sam_cwp_failure_string")

    @property
    @pulumi.getter(name="samCwpMatchString")
    def sam_cwp_match_string(self) -> Optional[str]:
        """
        Identification string from the captive portal login form.
        """
        return pulumi.get(self, "sam_cwp_match_string")

    @property
    @pulumi.getter(name="samCwpPassword")
    def sam_cwp_password(self) -> Optional[str]:
        """
        Password for captive portal authentication.
        """
        return pulumi.get(self, "sam_cwp_password")

    @property
    @pulumi.getter(name="samCwpSuccessString")
    def sam_cwp_success_string(self) -> Optional[str]:
        """
        Success identification on the page after a successful login.
        """
        return pulumi.get(self, "sam_cwp_success_string")

    @property
    @pulumi.getter(name="samCwpTestUrl")
    def sam_cwp_test_url(self) -> Optional[str]:
        """
        Website the client is trying to access.
        """
        return pulumi.get(self, "sam_cwp_test_url")

    @property
    @pulumi.getter(name="samCwpUsername")
    def sam_cwp_username(self) -> Optional[str]:
        """
        Username for captive portal authentication.
        """
        return pulumi.get(self, "sam_cwp_username")

    @property
    @pulumi.getter(name="samEapMethod")
    def sam_eap_method(self) -> Optional[str]:
        """
        Select WPA2/WPA3-ENTERPRISE EAP Method (default = PEAP). Valid values: `both`, `tls`, `peap`.
        """
        return pulumi.get(self, "sam_eap_method")

    @property
    @pulumi.getter(name="samPassword")
    def sam_password(self) -> Optional[str]:
        """
        Passphrase for WiFi network connection.
        """
        return pulumi.get(self, "sam_password")

    @property
    @pulumi.getter(name="samPrivateKey")
    def sam_private_key(self) -> Optional[str]:
        """
        Private key for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_private_key")

    @property
    @pulumi.getter(name="samPrivateKeyPassword")
    def sam_private_key_password(self) -> Optional[str]:
        """
        Password for private key file for WPA2/WPA3-ENTERPRISE.
        """
        return pulumi.get(self, "sam_private_key_password")

    @property
    @pulumi.getter(name="samReportIntv")
    def sam_report_intv(self) -> Optional[int]:
        """
        SAM report interval (sec), 0 for a one-time report.
        """
        return pulumi.get(self, "sam_report_intv")

    @property
    @pulumi.getter(name="samSecurityType")
    def sam_security_type(self) -> Optional[str]:
        """
        Select WiFi network security type (default = "wpa-personal").
        """
        return pulumi.get(self, "sam_security_type")

    @property
    @pulumi.getter(name="samServerFqdn")
    def sam_server_fqdn(self) -> Optional[str]:
        """
        SAM test server domain name.
        """
        return pulumi.get(self, "sam_server_fqdn")

    @property
    @pulumi.getter(name="samServerIp")
    def sam_server_ip(self) -> Optional[str]:
        """
        SAM test server IP address.
        """
        return pulumi.get(self, "sam_server_ip")

    @property
    @pulumi.getter(name="samServerType")
    def sam_server_type(self) -> Optional[str]:
        """
        Select SAM server type (default = "IP"). Valid values: `ip`, `fqdn`.
        """
        return pulumi.get(self, "sam_server_type")

    @property
    @pulumi.getter(name="samSsid")
    def sam_ssid(self) -> Optional[str]:
        """
        SSID for WiFi network.
        """
        return pulumi.get(self, "sam_ssid")

    @property
    @pulumi.getter(name="samTest")
    def sam_test(self) -> Optional[str]:
        """
        Select SAM test type (default = "PING"). Valid values: `ping`, `iperf`.
        """
        return pulumi.get(self, "sam_test")

    @property
    @pulumi.getter(name="samUsername")
    def sam_username(self) -> Optional[str]:
        """
        Username for WiFi network connection.
        """
        return pulumi.get(self, "sam_username")

    @property
    @pulumi.getter(name="shortGuardInterval")
    def short_guard_interval(self) -> Optional[str]:
        """
        Use either the short guard interval (Short GI) of 400 ns or the long guard interval (Long GI) of 800 ns. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "short_guard_interval")

    @property
    @pulumi.getter(name="spectrumAnalysis")
    def spectrum_analysis(self) -> Optional[str]:
        """
        Enable/disable spectrum analysis to find interference that would negatively impact wireless performance.
        """
        return pulumi.get(self, "spectrum_analysis")

    @property
    @pulumi.getter(name="transmitOptimize")
    def transmit_optimize(self) -> Optional[str]:
        """
        Packet transmission optimization options including power saving, aggregation limiting, retry limiting, etc. All are enabled by default. Valid values: `disable`, `power-save`, `aggr-limit`, `retry-limit`, `send-bar`.
        """
        return pulumi.get(self, "transmit_optimize")

    @property
    @pulumi.getter(name="vapAll")
    def vap_all(self) -> Optional[str]:
        """
        Enable/disable the automatic inheritance of all Virtual Access Points (VAPs) (default = enable).
        """
        return pulumi.get(self, "vap_all")

    @property
    @pulumi.getter
    def vaps(self) -> Optional[Sequence['outputs.WtpprofileRadio4Vap']]:
        """
        Manually selected list of Virtual Access Points (VAPs). The structure of `vaps` block is documented below.
        """
        return pulumi.get(self, "vaps")

    @property
    @pulumi.getter(name="widsProfile")
    def wids_profile(self) -> Optional[str]:
        """
        Wireless Intrusion Detection System (WIDS) profile name to assign to the radio.
        """
        return pulumi.get(self, "wids_profile")

    @property
    @pulumi.getter(name="zeroWaitDfs")
    def zero_wait_dfs(self) -> Optional[str]:
        """
        Enable/disable zero wait DFS on radio (default = enable). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "zero_wait_dfs")


@pulumi.output_type
class WtpprofileRadio4Channel(dict):
    def __init__(__self__, *,
                 chan: Optional[str] = None):
        """
        :param str chan: Channel number.
        """
        if chan is not None:
            pulumi.set(__self__, "chan", chan)

    @property
    @pulumi.getter
    def chan(self) -> Optional[str]:
        """
        Channel number.
        """
        return pulumi.get(self, "chan")


@pulumi.output_type
class WtpprofileRadio4Vap(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Virtual Access Point (VAP) name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Virtual Access Point (VAP) name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WtpprofileSplitTunnelingAcl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destIp":
            suggest = "dest_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WtpprofileSplitTunnelingAcl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WtpprofileSplitTunnelingAcl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WtpprofileSplitTunnelingAcl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dest_ip: Optional[str] = None,
                 id: Optional[int] = None):
        """
        :param str dest_ip: Destination IP and mask for the split-tunneling subnet.
               
               The `radio_1` block supports:
        :param int id: ID.
        """
        if dest_ip is not None:
            pulumi.set(__self__, "dest_ip", dest_ip)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter(name="destIp")
    def dest_ip(self) -> Optional[str]:
        """
        Destination IP and mask for the split-tunneling subnet.

        The `radio_1` block supports:
        """
        return pulumi.get(self, "dest_ip")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        ID.
        """
        return pulumi.get(self, "id")


