# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'DynamicportpolicyPolicy',
    'DynamicportpolicyPolicyInterfaceTag',
    'FlowtrackingAggregate',
    'FlowtrackingCollector',
    'FortilinksettingsNacPorts',
    'FortilinksettingsNacPortsNacSegmentVlan',
    'GlobalCustomCommand',
    'GlobalDisableDiscovery',
    'LldpprofileCustomTlv',
    'LldpprofileMedLocationService',
    'LldpprofileMedNetworkPolicy',
    'LocationAddressCivic',
    'LocationCoordinates',
    'LocationElinNumber',
    'ManagedswitchCustomCommand',
    'ManagedswitchDhcpSnoopingStaticClient',
    'ManagedswitchIgmpSnooping',
    'ManagedswitchIgmpSnoopingVlan',
    'ManagedswitchIpSourceGuard',
    'ManagedswitchIpSourceGuardBindingEntry',
    'ManagedswitchMirror',
    'ManagedswitchMirrorSrcEgress',
    'ManagedswitchMirrorSrcIngress',
    'ManagedswitchN8021xSettings',
    'ManagedswitchPort',
    'ManagedswitchPortAclGroup',
    'ManagedswitchPortAllowedVlan',
    'ManagedswitchPortDhcpSnoopOption82Override',
    'ManagedswitchPortExportTag',
    'ManagedswitchPortFortiswitchAcl',
    'ManagedswitchPortInterfaceTag',
    'ManagedswitchPortMember',
    'ManagedswitchPortUntaggedVlan',
    'ManagedswitchRemoteLog',
    'ManagedswitchRouteOffloadRouter',
    'ManagedswitchSnmpCommunity',
    'ManagedswitchSnmpCommunityHost',
    'ManagedswitchSnmpSysinfo',
    'ManagedswitchSnmpTrapThreshold',
    'ManagedswitchSnmpUser',
    'ManagedswitchStaticMac',
    'ManagedswitchStormControl',
    'ManagedswitchStpInstance',
    'ManagedswitchStpSettings',
    'ManagedswitchSwitchLog',
    'ManagedswitchSwitchStpSettings',
    'ManagedswitchVlan',
    'QuarantineTarget',
    'QuarantineTargetTag',
    'SnmpcommunityHost',
    'StpinstanceVlanRange',
    'SwitchgroupMember',
    'TrafficsnifferTargetIp',
    'TrafficsnifferTargetMac',
    'TrafficsnifferTargetPort',
    'TrafficsnifferTargetPortInPort',
    'TrafficsnifferTargetPortOutPort',
    'VlanPortalMessageOverrides',
    'VlanSelectedUsergroup',
    'VlanpolicyAllowedVlan',
    'VlanpolicyUntaggedVlan',
]

@pulumi.output_type
class DynamicportpolicyPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bouncePortLink":
            suggest = "bounce_port_link"
        elif key == "hwVendor":
            suggest = "hw_vendor"
        elif key == "interfaceTags":
            suggest = "interface_tags"
        elif key == "lldpProfile":
            suggest = "lldp_profile"
        elif key == "qosPolicy":
            suggest = "qos_policy"
        elif key == "vlanPolicy":
            suggest = "vlan_policy"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DynamicportpolicyPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DynamicportpolicyPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DynamicportpolicyPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bounce_port_link: Optional[str] = None,
                 category: Optional[str] = None,
                 description: Optional[str] = None,
                 family: Optional[str] = None,
                 host: Optional[str] = None,
                 hw_vendor: Optional[str] = None,
                 interface_tags: Optional[Sequence['outputs.DynamicportpolicyPolicyInterfaceTag']] = None,
                 lldp_profile: Optional[str] = None,
                 mac: Optional[str] = None,
                 n8021x: Optional[str] = None,
                 name: Optional[str] = None,
                 qos_policy: Optional[str] = None,
                 status: Optional[str] = None,
                 type: Optional[str] = None,
                 vlan_policy: Optional[str] = None):
        """
        :param str bounce_port_link: Enable/disable bouncing (administratively bring the link down, up) of a switch port where this policy is applied. Helps to clear and reassign VLAN from lldp-profile. Valid values: `disable`, `enable`.
        :param str category: Category of Dynamic port policy. Valid values: `device`, `interface-tag`.
        :param str description: Description for the policy.
        :param str family: Policy matching family.
        :param str host: Policy matching host.
        :param str hw_vendor: Match policy based on hardware vendor.
        :param Sequence['DynamicportpolicyPolicyInterfaceTagArgs'] interface_tags: Policy matching the FortiSwitch interface object tags. The structure of `interface_tags` block is documented below.
        :param str lldp_profile: LLDP profile to be applied when using this policy.
        :param str mac: Policy matching MAC address.
        :param str n8021x: 802.1x security policy to be applied when using this policy.
        :param str name: Policy name.
        :param str qos_policy: QoS policy to be applied when using this policy.
        :param str status: Enable/disable policy. Valid values: `enable`, `disable`.
        :param str type: Policy matching type.
        :param str vlan_policy: VLAN policy to be applied when using this policy.
        """
        if bounce_port_link is not None:
            pulumi.set(__self__, "bounce_port_link", bounce_port_link)
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if family is not None:
            pulumi.set(__self__, "family", family)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if hw_vendor is not None:
            pulumi.set(__self__, "hw_vendor", hw_vendor)
        if interface_tags is not None:
            pulumi.set(__self__, "interface_tags", interface_tags)
        if lldp_profile is not None:
            pulumi.set(__self__, "lldp_profile", lldp_profile)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if n8021x is not None:
            pulumi.set(__self__, "n8021x", n8021x)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if qos_policy is not None:
            pulumi.set(__self__, "qos_policy", qos_policy)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vlan_policy is not None:
            pulumi.set(__self__, "vlan_policy", vlan_policy)

    @property
    @pulumi.getter(name="bouncePortLink")
    def bounce_port_link(self) -> Optional[str]:
        """
        Enable/disable bouncing (administratively bring the link down, up) of a switch port where this policy is applied. Helps to clear and reassign VLAN from lldp-profile. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "bounce_port_link")

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        Category of Dynamic port policy. Valid values: `device`, `interface-tag`.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the policy.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def family(self) -> Optional[str]:
        """
        Policy matching family.
        """
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def host(self) -> Optional[str]:
        """
        Policy matching host.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter(name="hwVendor")
    def hw_vendor(self) -> Optional[str]:
        """
        Match policy based on hardware vendor.
        """
        return pulumi.get(self, "hw_vendor")

    @property
    @pulumi.getter(name="interfaceTags")
    def interface_tags(self) -> Optional[Sequence['outputs.DynamicportpolicyPolicyInterfaceTag']]:
        """
        Policy matching the FortiSwitch interface object tags. The structure of `interface_tags` block is documented below.
        """
        return pulumi.get(self, "interface_tags")

    @property
    @pulumi.getter(name="lldpProfile")
    def lldp_profile(self) -> Optional[str]:
        """
        LLDP profile to be applied when using this policy.
        """
        return pulumi.get(self, "lldp_profile")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        """
        Policy matching MAC address.
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def n8021x(self) -> Optional[str]:
        """
        802.1x security policy to be applied when using this policy.
        """
        return pulumi.get(self, "n8021x")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="qosPolicy")
    def qos_policy(self) -> Optional[str]:
        """
        QoS policy to be applied when using this policy.
        """
        return pulumi.get(self, "qos_policy")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable policy. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Policy matching type.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="vlanPolicy")
    def vlan_policy(self) -> Optional[str]:
        """
        VLAN policy to be applied when using this policy.
        """
        return pulumi.get(self, "vlan_policy")


@pulumi.output_type
class DynamicportpolicyPolicyInterfaceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagName":
            suggest = "tag_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DynamicportpolicyPolicyInterfaceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DynamicportpolicyPolicyInterfaceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DynamicportpolicyPolicyInterfaceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_name: Optional[str] = None):
        """
        :param str tag_name: FortiSwitch port tag name.
        """
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[str]:
        """
        FortiSwitch port tag name.
        """
        return pulumi.get(self, "tag_name")


@pulumi.output_type
class FlowtrackingAggregate(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None,
                 ip: Optional[str] = None):
        """
        :param int id: Aggregate id.
        :param str ip: IP address to group all matching traffic sessions to a flow.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Aggregate id.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IP address to group all matching traffic sessions to a flow.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class FlowtrackingCollector(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 transport: Optional[str] = None):
        """
        :param str ip: Collector IP address.
        :param str name: Collector name.
        :param int port: Collector port number(0-65535, default:0, netflow:2055, ipfix:4739).
        :param str transport: Collector L4 transport protocol for exporting packets. Valid values: `udp`, `tcp`, `sctp`.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if transport is not None:
            pulumi.set(__self__, "transport", transport)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Collector IP address.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Collector name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Collector port number(0-65535, default:0, netflow:2055, ipfix:4739).
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def transport(self) -> Optional[str]:
        """
        Collector L4 transport protocol for exporting packets. Valid values: `udp`, `tcp`, `sctp`.
        """
        return pulumi.get(self, "transport")


@pulumi.output_type
class FortilinksettingsNacPorts(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bounceNacPort":
            suggest = "bounce_nac_port"
        elif key == "lanSegment":
            suggest = "lan_segment"
        elif key == "memberChange":
            suggest = "member_change"
        elif key == "nacLanInterface":
            suggest = "nac_lan_interface"
        elif key == "nacSegmentVlans":
            suggest = "nac_segment_vlans"
        elif key == "onboardingVlan":
            suggest = "onboarding_vlan"
        elif key == "parentKey":
            suggest = "parent_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FortilinksettingsNacPorts. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FortilinksettingsNacPorts.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FortilinksettingsNacPorts.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bounce_nac_port: Optional[str] = None,
                 lan_segment: Optional[str] = None,
                 member_change: Optional[int] = None,
                 nac_lan_interface: Optional[str] = None,
                 nac_segment_vlans: Optional[Sequence['outputs.FortilinksettingsNacPortsNacSegmentVlan']] = None,
                 onboarding_vlan: Optional[str] = None,
                 parent_key: Optional[str] = None):
        """
        :param str bounce_nac_port: Enable/disable bouncing (administratively bring the link down, up) of a switch port when NAC mode is configured on the port. Helps to re-initiate the DHCP process for a device. Valid values: `disable`, `enable`.
        :param str lan_segment: Enable/disable LAN segment feature on the FortiLink interface. Valid values: `enabled`, `disabled`.
        :param int member_change: Member change flag.
        :param str nac_lan_interface: Configure NAC LAN interface.
        :param Sequence['FortilinksettingsNacPortsNacSegmentVlanArgs'] nac_segment_vlans: Configure NAC segment VLANs. The structure of `nac_segment_vlans` block is documented below.
        :param str onboarding_vlan: Default NAC Onboarding VLAN when NAC devices are discovered.
        :param str parent_key: Parent key name.
        """
        if bounce_nac_port is not None:
            pulumi.set(__self__, "bounce_nac_port", bounce_nac_port)
        if lan_segment is not None:
            pulumi.set(__self__, "lan_segment", lan_segment)
        if member_change is not None:
            pulumi.set(__self__, "member_change", member_change)
        if nac_lan_interface is not None:
            pulumi.set(__self__, "nac_lan_interface", nac_lan_interface)
        if nac_segment_vlans is not None:
            pulumi.set(__self__, "nac_segment_vlans", nac_segment_vlans)
        if onboarding_vlan is not None:
            pulumi.set(__self__, "onboarding_vlan", onboarding_vlan)
        if parent_key is not None:
            pulumi.set(__self__, "parent_key", parent_key)

    @property
    @pulumi.getter(name="bounceNacPort")
    def bounce_nac_port(self) -> Optional[str]:
        """
        Enable/disable bouncing (administratively bring the link down, up) of a switch port when NAC mode is configured on the port. Helps to re-initiate the DHCP process for a device. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "bounce_nac_port")

    @property
    @pulumi.getter(name="lanSegment")
    def lan_segment(self) -> Optional[str]:
        """
        Enable/disable LAN segment feature on the FortiLink interface. Valid values: `enabled`, `disabled`.
        """
        return pulumi.get(self, "lan_segment")

    @property
    @pulumi.getter(name="memberChange")
    def member_change(self) -> Optional[int]:
        """
        Member change flag.
        """
        return pulumi.get(self, "member_change")

    @property
    @pulumi.getter(name="nacLanInterface")
    def nac_lan_interface(self) -> Optional[str]:
        """
        Configure NAC LAN interface.
        """
        return pulumi.get(self, "nac_lan_interface")

    @property
    @pulumi.getter(name="nacSegmentVlans")
    def nac_segment_vlans(self) -> Optional[Sequence['outputs.FortilinksettingsNacPortsNacSegmentVlan']]:
        """
        Configure NAC segment VLANs. The structure of `nac_segment_vlans` block is documented below.
        """
        return pulumi.get(self, "nac_segment_vlans")

    @property
    @pulumi.getter(name="onboardingVlan")
    def onboarding_vlan(self) -> Optional[str]:
        """
        Default NAC Onboarding VLAN when NAC devices are discovered.
        """
        return pulumi.get(self, "onboarding_vlan")

    @property
    @pulumi.getter(name="parentKey")
    def parent_key(self) -> Optional[str]:
        """
        Parent key name.
        """
        return pulumi.get(self, "parent_key")


@pulumi.output_type
class FortilinksettingsNacPortsNacSegmentVlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanName":
            suggest = "vlan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FortilinksettingsNacPortsNacSegmentVlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FortilinksettingsNacPortsNacSegmentVlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FortilinksettingsNacPortsNacSegmentVlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vlan_name: Optional[str] = None):
        """
        :param str vlan_name: VLAN interface name.
        """
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[str]:
        """
        VLAN interface name.
        """
        return pulumi.get(self, "vlan_name")


@pulumi.output_type
class GlobalCustomCommand(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandEntry":
            suggest = "command_entry"
        elif key == "commandName":
            suggest = "command_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GlobalCustomCommand. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GlobalCustomCommand.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GlobalCustomCommand.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_entry: Optional[str] = None,
                 command_name: Optional[str] = None):
        """
        :param str command_entry: List of FortiSwitch commands.
        :param str command_name: Name of custom command to push to all FortiSwitches in VDOM.
        """
        if command_entry is not None:
            pulumi.set(__self__, "command_entry", command_entry)
        if command_name is not None:
            pulumi.set(__self__, "command_name", command_name)

    @property
    @pulumi.getter(name="commandEntry")
    def command_entry(self) -> Optional[str]:
        """
        List of FortiSwitch commands.
        """
        return pulumi.get(self, "command_entry")

    @property
    @pulumi.getter(name="commandName")
    def command_name(self) -> Optional[str]:
        """
        Name of custom command to push to all FortiSwitches in VDOM.
        """
        return pulumi.get(self, "command_name")


@pulumi.output_type
class GlobalDisableDiscovery(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Managed device ID.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Managed device ID.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class LldpprofileCustomTlv(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "informationString":
            suggest = "information_string"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LldpprofileCustomTlv. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LldpprofileCustomTlv.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LldpprofileCustomTlv.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 information_string: Optional[str] = None,
                 name: Optional[str] = None,
                 oui: Optional[str] = None,
                 subtype: Optional[int] = None):
        """
        :param str information_string: Organizationally defined information string (0 - 507 hexadecimal bytes).
        :param str name: TLV name (not sent).
        :param str oui: Organizationally unique identifier (OUI), a 3-byte hexadecimal number, for this TLV.
        :param int subtype: Organizationally defined subtype (0 - 255).
        """
        if information_string is not None:
            pulumi.set(__self__, "information_string", information_string)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if oui is not None:
            pulumi.set(__self__, "oui", oui)
        if subtype is not None:
            pulumi.set(__self__, "subtype", subtype)

    @property
    @pulumi.getter(name="informationString")
    def information_string(self) -> Optional[str]:
        """
        Organizationally defined information string (0 - 507 hexadecimal bytes).
        """
        return pulumi.get(self, "information_string")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        TLV name (not sent).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def oui(self) -> Optional[str]:
        """
        Organizationally unique identifier (OUI), a 3-byte hexadecimal number, for this TLV.
        """
        return pulumi.get(self, "oui")

    @property
    @pulumi.getter
    def subtype(self) -> Optional[int]:
        """
        Organizationally defined subtype (0 - 255).
        """
        return pulumi.get(self, "subtype")


@pulumi.output_type
class LldpprofileMedLocationService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sysLocationId":
            suggest = "sys_location_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LldpprofileMedLocationService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LldpprofileMedLocationService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LldpprofileMedLocationService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 status: Optional[str] = None,
                 sys_location_id: Optional[str] = None):
        """
        :param str name: Location service type name.
        :param str status: Enable or disable this TLV. Valid values: `disable`, `enable`.
        :param str sys_location_id: Location service ID.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if sys_location_id is not None:
            pulumi.set(__self__, "sys_location_id", sys_location_id)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Location service type name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable or disable this TLV. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="sysLocationId")
    def sys_location_id(self) -> Optional[str]:
        """
        Location service ID.
        """
        return pulumi.get(self, "sys_location_id")


@pulumi.output_type
class LldpprofileMedNetworkPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignVlan":
            suggest = "assign_vlan"
        elif key == "vlanIntf":
            suggest = "vlan_intf"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LldpprofileMedNetworkPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LldpprofileMedNetworkPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LldpprofileMedNetworkPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assign_vlan: Optional[str] = None,
                 dscp: Optional[int] = None,
                 name: Optional[str] = None,
                 priority: Optional[int] = None,
                 status: Optional[str] = None,
                 vlan: Optional[int] = None,
                 vlan_intf: Optional[str] = None):
        """
        :param str assign_vlan: Enable/disable VLAN assignment when this profile is applied on managed FortiSwitch port. Valid values: `disable`, `enable`.
        :param int dscp: Advertised Differentiated Services Code Point (DSCP) value, a packet header value indicating the level of service requested for traffic, such as high priority or best effort delivery.
        :param str name: Policy type name.
        :param int priority: Advertised Layer 2 priority (0 - 7; from lowest to highest priority).
        :param str status: Enable or disable this TLV. Valid values: `disable`, `enable`.
        :param int vlan: ID of VLAN to advertise, if configured on port (0 - 4094, 0 = priority tag).
        :param str vlan_intf: VLAN interface to advertise; if configured on port.
        """
        if assign_vlan is not None:
            pulumi.set(__self__, "assign_vlan", assign_vlan)
        if dscp is not None:
            pulumi.set(__self__, "dscp", dscp)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)
        if vlan_intf is not None:
            pulumi.set(__self__, "vlan_intf", vlan_intf)

    @property
    @pulumi.getter(name="assignVlan")
    def assign_vlan(self) -> Optional[str]:
        """
        Enable/disable VLAN assignment when this profile is applied on managed FortiSwitch port. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "assign_vlan")

    @property
    @pulumi.getter
    def dscp(self) -> Optional[int]:
        """
        Advertised Differentiated Services Code Point (DSCP) value, a packet header value indicating the level of service requested for traffic, such as high priority or best effort delivery.
        """
        return pulumi.get(self, "dscp")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Policy type name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def priority(self) -> Optional[int]:
        """
        Advertised Layer 2 priority (0 - 7; from lowest to highest priority).
        """
        return pulumi.get(self, "priority")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable or disable this TLV. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter
    def vlan(self) -> Optional[int]:
        """
        ID of VLAN to advertise, if configured on port (0 - 4094, 0 = priority tag).
        """
        return pulumi.get(self, "vlan")

    @property
    @pulumi.getter(name="vlanIntf")
    def vlan_intf(self) -> Optional[str]:
        """
        VLAN interface to advertise; if configured on port.
        """
        return pulumi.get(self, "vlan_intf")


@pulumi.output_type
class LocationAddressCivic(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalCode":
            suggest = "additional_code"
        elif key == "branchRoad":
            suggest = "branch_road"
        elif key == "cityDivision":
            suggest = "city_division"
        elif key == "countrySubdivision":
            suggest = "country_subdivision"
        elif key == "numberSuffix":
            suggest = "number_suffix"
        elif key == "parentKey":
            suggest = "parent_key"
        elif key == "placeType":
            suggest = "place_type"
        elif key == "postOfficeBox":
            suggest = "post_office_box"
        elif key == "postalCommunity":
            suggest = "postal_community"
        elif key == "primaryRoad":
            suggest = "primary_road"
        elif key == "roadSection":
            suggest = "road_section"
        elif key == "streetNamePostMod":
            suggest = "street_name_post_mod"
        elif key == "streetNamePreMod":
            suggest = "street_name_pre_mod"
        elif key == "streetSuffix":
            suggest = "street_suffix"
        elif key == "subBranchRoad":
            suggest = "sub_branch_road"
        elif key == "trailingStrSuffix":
            suggest = "trailing_str_suffix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocationAddressCivic. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocationAddressCivic.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocationAddressCivic.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional: Optional[str] = None,
                 additional_code: Optional[str] = None,
                 block: Optional[str] = None,
                 branch_road: Optional[str] = None,
                 building: Optional[str] = None,
                 city: Optional[str] = None,
                 city_division: Optional[str] = None,
                 country: Optional[str] = None,
                 country_subdivision: Optional[str] = None,
                 county: Optional[str] = None,
                 direction: Optional[str] = None,
                 floor: Optional[str] = None,
                 landmark: Optional[str] = None,
                 language: Optional[str] = None,
                 name: Optional[str] = None,
                 number: Optional[str] = None,
                 number_suffix: Optional[str] = None,
                 parent_key: Optional[str] = None,
                 place_type: Optional[str] = None,
                 post_office_box: Optional[str] = None,
                 postal_community: Optional[str] = None,
                 primary_road: Optional[str] = None,
                 road_section: Optional[str] = None,
                 room: Optional[str] = None,
                 script: Optional[str] = None,
                 seat: Optional[str] = None,
                 street: Optional[str] = None,
                 street_name_post_mod: Optional[str] = None,
                 street_name_pre_mod: Optional[str] = None,
                 street_suffix: Optional[str] = None,
                 sub_branch_road: Optional[str] = None,
                 trailing_str_suffix: Optional[str] = None,
                 unit: Optional[str] = None,
                 zip: Optional[str] = None):
        """
        :param str additional: Location additional details.
        :param str additional_code: Location additional code details.
        :param str block: Location block details.
        :param str branch_road: Location branch road details.
        :param str building: Location building details.
        :param str city: Location city details.
        :param str city_division: Location city division details.
        :param str country: The two-letter ISO 3166 country code in capital ASCII letters eg. US, CA, DK, DE.
        :param str country_subdivision: National subdivisions (state, canton, region, province, or prefecture).
        :param str county: County, parish, gun (JP), or district (IN).
        :param str direction: Leading street direction.
        :param str floor: Floor.
        :param str landmark: Landmark or vanity address.
        :param str language: Language.
        :param str name: Name (residence and office occupant).
        :param str number: House number.
        :param str number_suffix: House number suffix.
        :param str parent_key: Parent key name.
        :param str place_type: Placetype.
        :param str post_office_box: Post office box (P.O. box).
        :param str postal_community: Postal community name.
        :param str primary_road: Primary road name.
        :param str road_section: Road section.
        :param str room: Room number.
        :param str script: Script used to present the address information.
        :param str seat: Seat number.
        :param str street: Street.
        :param str street_name_post_mod: Street name post modifier.
        :param str street_name_pre_mod: Street name pre modifier.
        :param str street_suffix: Street suffix.
        :param str sub_branch_road: Sub branch road name.
        :param str trailing_str_suffix: Trailing street suffix.
        :param str unit: Unit (apartment, suite).
        :param str zip: Postal/zip code.
        """
        if additional is not None:
            pulumi.set(__self__, "additional", additional)
        if additional_code is not None:
            pulumi.set(__self__, "additional_code", additional_code)
        if block is not None:
            pulumi.set(__self__, "block", block)
        if branch_road is not None:
            pulumi.set(__self__, "branch_road", branch_road)
        if building is not None:
            pulumi.set(__self__, "building", building)
        if city is not None:
            pulumi.set(__self__, "city", city)
        if city_division is not None:
            pulumi.set(__self__, "city_division", city_division)
        if country is not None:
            pulumi.set(__self__, "country", country)
        if country_subdivision is not None:
            pulumi.set(__self__, "country_subdivision", country_subdivision)
        if county is not None:
            pulumi.set(__self__, "county", county)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if floor is not None:
            pulumi.set(__self__, "floor", floor)
        if landmark is not None:
            pulumi.set(__self__, "landmark", landmark)
        if language is not None:
            pulumi.set(__self__, "language", language)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if number is not None:
            pulumi.set(__self__, "number", number)
        if number_suffix is not None:
            pulumi.set(__self__, "number_suffix", number_suffix)
        if parent_key is not None:
            pulumi.set(__self__, "parent_key", parent_key)
        if place_type is not None:
            pulumi.set(__self__, "place_type", place_type)
        if post_office_box is not None:
            pulumi.set(__self__, "post_office_box", post_office_box)
        if postal_community is not None:
            pulumi.set(__self__, "postal_community", postal_community)
        if primary_road is not None:
            pulumi.set(__self__, "primary_road", primary_road)
        if road_section is not None:
            pulumi.set(__self__, "road_section", road_section)
        if room is not None:
            pulumi.set(__self__, "room", room)
        if script is not None:
            pulumi.set(__self__, "script", script)
        if seat is not None:
            pulumi.set(__self__, "seat", seat)
        if street is not None:
            pulumi.set(__self__, "street", street)
        if street_name_post_mod is not None:
            pulumi.set(__self__, "street_name_post_mod", street_name_post_mod)
        if street_name_pre_mod is not None:
            pulumi.set(__self__, "street_name_pre_mod", street_name_pre_mod)
        if street_suffix is not None:
            pulumi.set(__self__, "street_suffix", street_suffix)
        if sub_branch_road is not None:
            pulumi.set(__self__, "sub_branch_road", sub_branch_road)
        if trailing_str_suffix is not None:
            pulumi.set(__self__, "trailing_str_suffix", trailing_str_suffix)
        if unit is not None:
            pulumi.set(__self__, "unit", unit)
        if zip is not None:
            pulumi.set(__self__, "zip", zip)

    @property
    @pulumi.getter
    def additional(self) -> Optional[str]:
        """
        Location additional details.
        """
        return pulumi.get(self, "additional")

    @property
    @pulumi.getter(name="additionalCode")
    def additional_code(self) -> Optional[str]:
        """
        Location additional code details.
        """
        return pulumi.get(self, "additional_code")

    @property
    @pulumi.getter
    def block(self) -> Optional[str]:
        """
        Location block details.
        """
        return pulumi.get(self, "block")

    @property
    @pulumi.getter(name="branchRoad")
    def branch_road(self) -> Optional[str]:
        """
        Location branch road details.
        """
        return pulumi.get(self, "branch_road")

    @property
    @pulumi.getter
    def building(self) -> Optional[str]:
        """
        Location building details.
        """
        return pulumi.get(self, "building")

    @property
    @pulumi.getter
    def city(self) -> Optional[str]:
        """
        Location city details.
        """
        return pulumi.get(self, "city")

    @property
    @pulumi.getter(name="cityDivision")
    def city_division(self) -> Optional[str]:
        """
        Location city division details.
        """
        return pulumi.get(self, "city_division")

    @property
    @pulumi.getter
    def country(self) -> Optional[str]:
        """
        The two-letter ISO 3166 country code in capital ASCII letters eg. US, CA, DK, DE.
        """
        return pulumi.get(self, "country")

    @property
    @pulumi.getter(name="countrySubdivision")
    def country_subdivision(self) -> Optional[str]:
        """
        National subdivisions (state, canton, region, province, or prefecture).
        """
        return pulumi.get(self, "country_subdivision")

    @property
    @pulumi.getter
    def county(self) -> Optional[str]:
        """
        County, parish, gun (JP), or district (IN).
        """
        return pulumi.get(self, "county")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        Leading street direction.
        """
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def floor(self) -> Optional[str]:
        """
        Floor.
        """
        return pulumi.get(self, "floor")

    @property
    @pulumi.getter
    def landmark(self) -> Optional[str]:
        """
        Landmark or vanity address.
        """
        return pulumi.get(self, "landmark")

    @property
    @pulumi.getter
    def language(self) -> Optional[str]:
        """
        Language.
        """
        return pulumi.get(self, "language")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name (residence and office occupant).
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def number(self) -> Optional[str]:
        """
        House number.
        """
        return pulumi.get(self, "number")

    @property
    @pulumi.getter(name="numberSuffix")
    def number_suffix(self) -> Optional[str]:
        """
        House number suffix.
        """
        return pulumi.get(self, "number_suffix")

    @property
    @pulumi.getter(name="parentKey")
    def parent_key(self) -> Optional[str]:
        """
        Parent key name.
        """
        return pulumi.get(self, "parent_key")

    @property
    @pulumi.getter(name="placeType")
    def place_type(self) -> Optional[str]:
        """
        Placetype.
        """
        return pulumi.get(self, "place_type")

    @property
    @pulumi.getter(name="postOfficeBox")
    def post_office_box(self) -> Optional[str]:
        """
        Post office box (P.O. box).
        """
        return pulumi.get(self, "post_office_box")

    @property
    @pulumi.getter(name="postalCommunity")
    def postal_community(self) -> Optional[str]:
        """
        Postal community name.
        """
        return pulumi.get(self, "postal_community")

    @property
    @pulumi.getter(name="primaryRoad")
    def primary_road(self) -> Optional[str]:
        """
        Primary road name.
        """
        return pulumi.get(self, "primary_road")

    @property
    @pulumi.getter(name="roadSection")
    def road_section(self) -> Optional[str]:
        """
        Road section.
        """
        return pulumi.get(self, "road_section")

    @property
    @pulumi.getter
    def room(self) -> Optional[str]:
        """
        Room number.
        """
        return pulumi.get(self, "room")

    @property
    @pulumi.getter
    def script(self) -> Optional[str]:
        """
        Script used to present the address information.
        """
        return pulumi.get(self, "script")

    @property
    @pulumi.getter
    def seat(self) -> Optional[str]:
        """
        Seat number.
        """
        return pulumi.get(self, "seat")

    @property
    @pulumi.getter
    def street(self) -> Optional[str]:
        """
        Street.
        """
        return pulumi.get(self, "street")

    @property
    @pulumi.getter(name="streetNamePostMod")
    def street_name_post_mod(self) -> Optional[str]:
        """
        Street name post modifier.
        """
        return pulumi.get(self, "street_name_post_mod")

    @property
    @pulumi.getter(name="streetNamePreMod")
    def street_name_pre_mod(self) -> Optional[str]:
        """
        Street name pre modifier.
        """
        return pulumi.get(self, "street_name_pre_mod")

    @property
    @pulumi.getter(name="streetSuffix")
    def street_suffix(self) -> Optional[str]:
        """
        Street suffix.
        """
        return pulumi.get(self, "street_suffix")

    @property
    @pulumi.getter(name="subBranchRoad")
    def sub_branch_road(self) -> Optional[str]:
        """
        Sub branch road name.
        """
        return pulumi.get(self, "sub_branch_road")

    @property
    @pulumi.getter(name="trailingStrSuffix")
    def trailing_str_suffix(self) -> Optional[str]:
        """
        Trailing street suffix.
        """
        return pulumi.get(self, "trailing_str_suffix")

    @property
    @pulumi.getter
    def unit(self) -> Optional[str]:
        """
        Unit (apartment, suite).
        """
        return pulumi.get(self, "unit")

    @property
    @pulumi.getter
    def zip(self) -> Optional[str]:
        """
        Postal/zip code.
        """
        return pulumi.get(self, "zip")


@pulumi.output_type
class LocationCoordinates(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "altitudeUnit":
            suggest = "altitude_unit"
        elif key == "parentKey":
            suggest = "parent_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocationCoordinates. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocationCoordinates.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocationCoordinates.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 altitude: Optional[str] = None,
                 altitude_unit: Optional[str] = None,
                 datum: Optional[str] = None,
                 latitude: Optional[str] = None,
                 longitude: Optional[str] = None,
                 parent_key: Optional[str] = None):
        """
        :param str altitude: +/- Floating point no. eg. 117.47.
        :param str altitude_unit: m ( meters), f ( floors). Valid values: `m`, `f`.
        :param str datum: WGS84, NAD83, NAD83/MLLW. Valid values: `WGS84`, `NAD83`, `NAD83/MLLW`.
        :param str latitude: Floating point start with ( +/- )  or end with ( N or S ) eg. +/-16.67 or 16.67N.
        :param str longitude: Floating point start with ( +/- )  or end with ( E or W ) eg. +/-26.789 or 26.789E.
        :param str parent_key: Parent key name.
        """
        if altitude is not None:
            pulumi.set(__self__, "altitude", altitude)
        if altitude_unit is not None:
            pulumi.set(__self__, "altitude_unit", altitude_unit)
        if datum is not None:
            pulumi.set(__self__, "datum", datum)
        if latitude is not None:
            pulumi.set(__self__, "latitude", latitude)
        if longitude is not None:
            pulumi.set(__self__, "longitude", longitude)
        if parent_key is not None:
            pulumi.set(__self__, "parent_key", parent_key)

    @property
    @pulumi.getter
    def altitude(self) -> Optional[str]:
        """
        +/- Floating point no. eg. 117.47.
        """
        return pulumi.get(self, "altitude")

    @property
    @pulumi.getter(name="altitudeUnit")
    def altitude_unit(self) -> Optional[str]:
        """
        m ( meters), f ( floors). Valid values: `m`, `f`.
        """
        return pulumi.get(self, "altitude_unit")

    @property
    @pulumi.getter
    def datum(self) -> Optional[str]:
        """
        WGS84, NAD83, NAD83/MLLW. Valid values: `WGS84`, `NAD83`, `NAD83/MLLW`.
        """
        return pulumi.get(self, "datum")

    @property
    @pulumi.getter
    def latitude(self) -> Optional[str]:
        """
        Floating point start with ( +/- )  or end with ( N or S ) eg. +/-16.67 or 16.67N.
        """
        return pulumi.get(self, "latitude")

    @property
    @pulumi.getter
    def longitude(self) -> Optional[str]:
        """
        Floating point start with ( +/- )  or end with ( E or W ) eg. +/-26.789 or 26.789E.
        """
        return pulumi.get(self, "longitude")

    @property
    @pulumi.getter(name="parentKey")
    def parent_key(self) -> Optional[str]:
        """
        Parent key name.
        """
        return pulumi.get(self, "parent_key")


@pulumi.output_type
class LocationElinNumber(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "elinNum":
            suggest = "elin_num"
        elif key == "parentKey":
            suggest = "parent_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocationElinNumber. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocationElinNumber.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocationElinNumber.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 elin_num: Optional[str] = None,
                 parent_key: Optional[str] = None):
        """
        :param str elin_num: Configure ELIN callback number.
        :param str parent_key: Parent key name.
        """
        if elin_num is not None:
            pulumi.set(__self__, "elin_num", elin_num)
        if parent_key is not None:
            pulumi.set(__self__, "parent_key", parent_key)

    @property
    @pulumi.getter(name="elinNum")
    def elin_num(self) -> Optional[str]:
        """
        Configure ELIN callback number.
        """
        return pulumi.get(self, "elin_num")

    @property
    @pulumi.getter(name="parentKey")
    def parent_key(self) -> Optional[str]:
        """
        Parent key name.
        """
        return pulumi.get(self, "parent_key")


@pulumi.output_type
class ManagedswitchCustomCommand(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "commandEntry":
            suggest = "command_entry"
        elif key == "commandName":
            suggest = "command_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchCustomCommand. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchCustomCommand.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchCustomCommand.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 command_entry: Optional[str] = None,
                 command_name: Optional[str] = None):
        """
        :param str command_entry: List of FortiSwitch commands.
        :param str command_name: Names of commands to be pushed to this FortiSwitch device, as configured under config switch-controller custom-command.
        """
        if command_entry is not None:
            pulumi.set(__self__, "command_entry", command_entry)
        if command_name is not None:
            pulumi.set(__self__, "command_name", command_name)

    @property
    @pulumi.getter(name="commandEntry")
    def command_entry(self) -> Optional[str]:
        """
        List of FortiSwitch commands.
        """
        return pulumi.get(self, "command_entry")

    @property
    @pulumi.getter(name="commandName")
    def command_name(self) -> Optional[str]:
        """
        Names of commands to be pushed to this FortiSwitch device, as configured under config switch-controller custom-command.
        """
        return pulumi.get(self, "command_name")


@pulumi.output_type
class ManagedswitchDhcpSnoopingStaticClient(dict):
    def __init__(__self__, *,
                 ip: Optional[str] = None,
                 mac: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[str] = None,
                 vlan: Optional[str] = None):
        """
        :param str ip: Client static IP address.
        :param str mac: Client MAC address.
        :param str name: Client name.
        :param str port: Interface name.
        :param str vlan: VLAN name.
        """
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Client static IP address.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        """
        Client MAC address.
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Client name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def vlan(self) -> Optional[str]:
        """
        VLAN name.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class ManagedswitchIgmpSnooping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agingTime":
            suggest = "aging_time"
        elif key == "floodUnknownMulticast":
            suggest = "flood_unknown_multicast"
        elif key == "localOverride":
            suggest = "local_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchIgmpSnooping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchIgmpSnooping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchIgmpSnooping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aging_time: Optional[int] = None,
                 flood_unknown_multicast: Optional[str] = None,
                 local_override: Optional[str] = None,
                 vlans: Optional[Sequence['outputs.ManagedswitchIgmpSnoopingVlan']] = None):
        """
        :param int aging_time: Maximum time to retain a multicast snooping entry for which no packets have been seen (15 - 3600 sec, default = 300).
        :param str flood_unknown_multicast: Enable/disable unknown multicast flooding. Valid values: `enable`, `disable`.
        :param str local_override: Enable/disable overriding the global IGMP snooping configuration. Valid values: `enable`, `disable`.
        :param Sequence['ManagedswitchIgmpSnoopingVlanArgs'] vlans: Configure IGMP snooping VLAN. The structure of `vlans` block is documented below.
        """
        if aging_time is not None:
            pulumi.set(__self__, "aging_time", aging_time)
        if flood_unknown_multicast is not None:
            pulumi.set(__self__, "flood_unknown_multicast", flood_unknown_multicast)
        if local_override is not None:
            pulumi.set(__self__, "local_override", local_override)
        if vlans is not None:
            pulumi.set(__self__, "vlans", vlans)

    @property
    @pulumi.getter(name="agingTime")
    def aging_time(self) -> Optional[int]:
        """
        Maximum time to retain a multicast snooping entry for which no packets have been seen (15 - 3600 sec, default = 300).
        """
        return pulumi.get(self, "aging_time")

    @property
    @pulumi.getter(name="floodUnknownMulticast")
    def flood_unknown_multicast(self) -> Optional[str]:
        """
        Enable/disable unknown multicast flooding. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "flood_unknown_multicast")

    @property
    @pulumi.getter(name="localOverride")
    def local_override(self) -> Optional[str]:
        """
        Enable/disable overriding the global IGMP snooping configuration. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "local_override")

    @property
    @pulumi.getter
    def vlans(self) -> Optional[Sequence['outputs.ManagedswitchIgmpSnoopingVlan']]:
        """
        Configure IGMP snooping VLAN. The structure of `vlans` block is documented below.
        """
        return pulumi.get(self, "vlans")


@pulumi.output_type
class ManagedswitchIgmpSnoopingVlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "querierAddr":
            suggest = "querier_addr"
        elif key == "vlanName":
            suggest = "vlan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchIgmpSnoopingVlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchIgmpSnoopingVlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchIgmpSnoopingVlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 proxy: Optional[str] = None,
                 querier: Optional[str] = None,
                 querier_addr: Optional[str] = None,
                 version: Optional[int] = None,
                 vlan_name: Optional[str] = None):
        """
        :param str proxy: IGMP snooping proxy for the VLAN interface. Valid values: `disable`, `enable`, `global`.
        :param str querier: Enable/disable IGMP snooping querier for the VLAN interface. Valid values: `disable`, `enable`.
        :param str querier_addr: IGMP snooping querier address.
        :param int version: IGMP snooping querier version.
               
               The `n802_1x_settings` block supports:
        :param str vlan_name: List of FortiSwitch VLANs.
        """
        if proxy is not None:
            pulumi.set(__self__, "proxy", proxy)
        if querier is not None:
            pulumi.set(__self__, "querier", querier)
        if querier_addr is not None:
            pulumi.set(__self__, "querier_addr", querier_addr)
        if version is not None:
            pulumi.set(__self__, "version", version)
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @property
    @pulumi.getter
    def proxy(self) -> Optional[str]:
        """
        IGMP snooping proxy for the VLAN interface. Valid values: `disable`, `enable`, `global`.
        """
        return pulumi.get(self, "proxy")

    @property
    @pulumi.getter
    def querier(self) -> Optional[str]:
        """
        Enable/disable IGMP snooping querier for the VLAN interface. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "querier")

    @property
    @pulumi.getter(name="querierAddr")
    def querier_addr(self) -> Optional[str]:
        """
        IGMP snooping querier address.
        """
        return pulumi.get(self, "querier_addr")

    @property
    @pulumi.getter
    def version(self) -> Optional[int]:
        """
        IGMP snooping querier version.

        The `n802_1x_settings` block supports:
        """
        return pulumi.get(self, "version")

    @property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[str]:
        """
        List of FortiSwitch VLANs.
        """
        return pulumi.get(self, "vlan_name")


@pulumi.output_type
class ManagedswitchIpSourceGuard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bindingEntries":
            suggest = "binding_entries"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchIpSourceGuard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchIpSourceGuard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchIpSourceGuard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 binding_entries: Optional[Sequence['outputs.ManagedswitchIpSourceGuardBindingEntry']] = None,
                 description: Optional[str] = None,
                 port: Optional[str] = None):
        """
        :param Sequence['ManagedswitchIpSourceGuardBindingEntryArgs'] binding_entries: IP and MAC address configuration. The structure of `binding_entry` block is documented below.
        :param str description: Description.
        :param str port: Ingress interface to which source guard is bound.
        """
        if binding_entries is not None:
            pulumi.set(__self__, "binding_entries", binding_entries)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="bindingEntries")
    def binding_entries(self) -> Optional[Sequence['outputs.ManagedswitchIpSourceGuardBindingEntry']]:
        """
        IP and MAC address configuration. The structure of `binding_entry` block is documented below.
        """
        return pulumi.get(self, "binding_entries")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def port(self) -> Optional[str]:
        """
        Ingress interface to which source guard is bound.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ManagedswitchIpSourceGuardBindingEntry(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryName":
            suggest = "entry_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchIpSourceGuardBindingEntry. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchIpSourceGuardBindingEntry.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchIpSourceGuardBindingEntry.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_name: Optional[str] = None,
                 ip: Optional[str] = None,
                 mac: Optional[str] = None):
        """
        :param str entry_name: Configure binding pair.
        :param str ip: Source IP for this rule.
        :param str mac: MAC address for this rule.
        """
        if entry_name is not None:
            pulumi.set(__self__, "entry_name", entry_name)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)

    @property
    @pulumi.getter(name="entryName")
    def entry_name(self) -> Optional[str]:
        """
        Configure binding pair.
        """
        return pulumi.get(self, "entry_name")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Source IP for this rule.
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        """
        MAC address for this rule.
        """
        return pulumi.get(self, "mac")


@pulumi.output_type
class ManagedswitchMirror(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "srcEgresses":
            suggest = "src_egresses"
        elif key == "srcIngresses":
            suggest = "src_ingresses"
        elif key == "switchingPacket":
            suggest = "switching_packet"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchMirror. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchMirror.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchMirror.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dst: Optional[str] = None,
                 name: Optional[str] = None,
                 src_egresses: Optional[Sequence['outputs.ManagedswitchMirrorSrcEgress']] = None,
                 src_ingresses: Optional[Sequence['outputs.ManagedswitchMirrorSrcIngress']] = None,
                 status: Optional[str] = None,
                 switching_packet: Optional[str] = None):
        """
        :param str dst: Destination port.
        :param str name: Mirror name.
        :param Sequence['ManagedswitchMirrorSrcEgressArgs'] src_egresses: Source egress interfaces. The structure of `src_egress` block is documented below.
        :param Sequence['ManagedswitchMirrorSrcIngressArgs'] src_ingresses: Source ingress interfaces. The structure of `src_ingress` block is documented below.
        :param str status: Active/inactive mirror configuration. Valid values: `active`, `inactive`.
        :param str switching_packet: Enable/disable switching functionality when mirroring. Valid values: `enable`, `disable`.
        """
        if dst is not None:
            pulumi.set(__self__, "dst", dst)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if src_egresses is not None:
            pulumi.set(__self__, "src_egresses", src_egresses)
        if src_ingresses is not None:
            pulumi.set(__self__, "src_ingresses", src_ingresses)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if switching_packet is not None:
            pulumi.set(__self__, "switching_packet", switching_packet)

    @property
    @pulumi.getter
    def dst(self) -> Optional[str]:
        """
        Destination port.
        """
        return pulumi.get(self, "dst")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Mirror name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="srcEgresses")
    def src_egresses(self) -> Optional[Sequence['outputs.ManagedswitchMirrorSrcEgress']]:
        """
        Source egress interfaces. The structure of `src_egress` block is documented below.
        """
        return pulumi.get(self, "src_egresses")

    @property
    @pulumi.getter(name="srcIngresses")
    def src_ingresses(self) -> Optional[Sequence['outputs.ManagedswitchMirrorSrcIngress']]:
        """
        Source ingress interfaces. The structure of `src_ingress` block is documented below.
        """
        return pulumi.get(self, "src_ingresses")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Active/inactive mirror configuration. Valid values: `active`, `inactive`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="switchingPacket")
    def switching_packet(self) -> Optional[str]:
        """
        Enable/disable switching functionality when mirroring. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "switching_packet")


@pulumi.output_type
class ManagedswitchMirrorSrcEgress(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ManagedswitchMirrorSrcIngress(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ManagedswitchN8021xSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "linkDownAuth":
            suggest = "link_down_auth"
        elif key == "localOverride":
            suggest = "local_override"
        elif key == "mabReauth":
            suggest = "mab_reauth"
        elif key == "macCalledStationDelimiter":
            suggest = "mac_called_station_delimiter"
        elif key == "macCallingStationDelimiter":
            suggest = "mac_calling_station_delimiter"
        elif key == "macCase":
            suggest = "mac_case"
        elif key == "macPasswordDelimiter":
            suggest = "mac_password_delimiter"
        elif key == "macUsernameDelimiter":
            suggest = "mac_username_delimiter"
        elif key == "maxReauthAttempt":
            suggest = "max_reauth_attempt"
        elif key == "reauthPeriod":
            suggest = "reauth_period"
        elif key == "txPeriod":
            suggest = "tx_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchN8021xSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchN8021xSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchN8021xSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 link_down_auth: Optional[str] = None,
                 local_override: Optional[str] = None,
                 mab_reauth: Optional[str] = None,
                 mac_called_station_delimiter: Optional[str] = None,
                 mac_calling_station_delimiter: Optional[str] = None,
                 mac_case: Optional[str] = None,
                 mac_password_delimiter: Optional[str] = None,
                 mac_username_delimiter: Optional[str] = None,
                 max_reauth_attempt: Optional[int] = None,
                 reauth_period: Optional[int] = None,
                 tx_period: Optional[int] = None):
        """
        :param str link_down_auth: Authentication state to set if a link is down. Valid values: `set-unauth`, `no-action`.
        :param str local_override: Enable/disable overriding the global IGMP snooping configuration. Valid values: `enable`, `disable`.
        :param str mab_reauth: Enable or disable MAB reauthentication settings. Valid values: `disable`, `enable`.
        :param str mac_called_station_delimiter: MAC called station delimiter (default = hyphen). Valid values: `colon`, `hyphen`, `none`, `single-hyphen`.
        :param str mac_calling_station_delimiter: MAC calling station delimiter (default = hyphen). Valid values: `colon`, `hyphen`, `none`, `single-hyphen`.
        :param str mac_case: MAC case (default = lowercase). Valid values: `lowercase`, `uppercase`.
        :param str mac_password_delimiter: MAC authentication password delimiter (default = hyphen). Valid values: `colon`, `hyphen`, `none`, `single-hyphen`.
        :param str mac_username_delimiter: MAC authentication username delimiter (default = hyphen). Valid values: `colon`, `hyphen`, `none`, `single-hyphen`.
        :param int max_reauth_attempt: Maximum number of authentication attempts (0 - 15, default = 3).
        :param int reauth_period: Reauthentication time interval (1 - 1440 min, default = 60, 0 = disable).
        :param int tx_period: 802.1X Tx period (seconds, default=30).
        """
        if link_down_auth is not None:
            pulumi.set(__self__, "link_down_auth", link_down_auth)
        if local_override is not None:
            pulumi.set(__self__, "local_override", local_override)
        if mab_reauth is not None:
            pulumi.set(__self__, "mab_reauth", mab_reauth)
        if mac_called_station_delimiter is not None:
            pulumi.set(__self__, "mac_called_station_delimiter", mac_called_station_delimiter)
        if mac_calling_station_delimiter is not None:
            pulumi.set(__self__, "mac_calling_station_delimiter", mac_calling_station_delimiter)
        if mac_case is not None:
            pulumi.set(__self__, "mac_case", mac_case)
        if mac_password_delimiter is not None:
            pulumi.set(__self__, "mac_password_delimiter", mac_password_delimiter)
        if mac_username_delimiter is not None:
            pulumi.set(__self__, "mac_username_delimiter", mac_username_delimiter)
        if max_reauth_attempt is not None:
            pulumi.set(__self__, "max_reauth_attempt", max_reauth_attempt)
        if reauth_period is not None:
            pulumi.set(__self__, "reauth_period", reauth_period)
        if tx_period is not None:
            pulumi.set(__self__, "tx_period", tx_period)

    @property
    @pulumi.getter(name="linkDownAuth")
    def link_down_auth(self) -> Optional[str]:
        """
        Authentication state to set if a link is down. Valid values: `set-unauth`, `no-action`.
        """
        return pulumi.get(self, "link_down_auth")

    @property
    @pulumi.getter(name="localOverride")
    def local_override(self) -> Optional[str]:
        """
        Enable/disable overriding the global IGMP snooping configuration. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "local_override")

    @property
    @pulumi.getter(name="mabReauth")
    def mab_reauth(self) -> Optional[str]:
        """
        Enable or disable MAB reauthentication settings. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "mab_reauth")

    @property
    @pulumi.getter(name="macCalledStationDelimiter")
    def mac_called_station_delimiter(self) -> Optional[str]:
        """
        MAC called station delimiter (default = hyphen). Valid values: `colon`, `hyphen`, `none`, `single-hyphen`.
        """
        return pulumi.get(self, "mac_called_station_delimiter")

    @property
    @pulumi.getter(name="macCallingStationDelimiter")
    def mac_calling_station_delimiter(self) -> Optional[str]:
        """
        MAC calling station delimiter (default = hyphen). Valid values: `colon`, `hyphen`, `none`, `single-hyphen`.
        """
        return pulumi.get(self, "mac_calling_station_delimiter")

    @property
    @pulumi.getter(name="macCase")
    def mac_case(self) -> Optional[str]:
        """
        MAC case (default = lowercase). Valid values: `lowercase`, `uppercase`.
        """
        return pulumi.get(self, "mac_case")

    @property
    @pulumi.getter(name="macPasswordDelimiter")
    def mac_password_delimiter(self) -> Optional[str]:
        """
        MAC authentication password delimiter (default = hyphen). Valid values: `colon`, `hyphen`, `none`, `single-hyphen`.
        """
        return pulumi.get(self, "mac_password_delimiter")

    @property
    @pulumi.getter(name="macUsernameDelimiter")
    def mac_username_delimiter(self) -> Optional[str]:
        """
        MAC authentication username delimiter (default = hyphen). Valid values: `colon`, `hyphen`, `none`, `single-hyphen`.
        """
        return pulumi.get(self, "mac_username_delimiter")

    @property
    @pulumi.getter(name="maxReauthAttempt")
    def max_reauth_attempt(self) -> Optional[int]:
        """
        Maximum number of authentication attempts (0 - 15, default = 3).
        """
        return pulumi.get(self, "max_reauth_attempt")

    @property
    @pulumi.getter(name="reauthPeriod")
    def reauth_period(self) -> Optional[int]:
        """
        Reauthentication time interval (1 - 1440 min, default = 60, 0 = disable).
        """
        return pulumi.get(self, "reauth_period")

    @property
    @pulumi.getter(name="txPeriod")
    def tx_period(self) -> Optional[int]:
        """
        802.1X Tx period (seconds, default=30).
        """
        return pulumi.get(self, "tx_period")


@pulumi.output_type
class ManagedswitchPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessMode":
            suggest = "access_mode"
        elif key == "aclGroups":
            suggest = "acl_groups"
        elif key == "aggregatorMode":
            suggest = "aggregator_mode"
        elif key == "allowedVlans":
            suggest = "allowed_vlans"
        elif key == "allowedVlansAll":
            suggest = "allowed_vlans_all"
        elif key == "arpInspectionTrust":
            suggest = "arp_inspection_trust"
        elif key == "authenticatedPort":
            suggest = "authenticated_port"
        elif key == "dhcpSnoopOption82Overrides":
            suggest = "dhcp_snoop_option82_overrides"
        elif key == "dhcpSnoopOption82Trust":
            suggest = "dhcp_snoop_option82_trust"
        elif key == "dhcpSnooping":
            suggest = "dhcp_snooping"
        elif key == "discardMode":
            suggest = "discard_mode"
        elif key == "edgePort":
            suggest = "edge_port"
        elif key == "encryptedPort":
            suggest = "encrypted_port"
        elif key == "exportTags":
            suggest = "export_tags"
        elif key == "exportTo":
            suggest = "export_to"
        elif key == "exportToPool":
            suggest = "export_to_pool"
        elif key == "exportToPoolFlag":
            suggest = "export_to_pool_flag"
        elif key == "fecCapable":
            suggest = "fec_capable"
        elif key == "fecState":
            suggest = "fec_state"
        elif key == "fgtPeerDeviceName":
            suggest = "fgt_peer_device_name"
        elif key == "fgtPeerPortName":
            suggest = "fgt_peer_port_name"
        elif key == "fiberPort":
            suggest = "fiber_port"
        elif key == "flapDuration":
            suggest = "flap_duration"
        elif key == "flapRate":
            suggest = "flap_rate"
        elif key == "flapTimeout":
            suggest = "flap_timeout"
        elif key == "flowControl":
            suggest = "flow_control"
        elif key == "fortilinkPort":
            suggest = "fortilink_port"
        elif key == "fortiswitchAcls":
            suggest = "fortiswitch_acls"
        elif key == "igmpSnooping":
            suggest = "igmp_snooping"
        elif key == "igmpSnoopingFloodReports":
            suggest = "igmp_snooping_flood_reports"
        elif key == "igmpsFloodReports":
            suggest = "igmps_flood_reports"
        elif key == "igmpsFloodTraffic":
            suggest = "igmps_flood_traffic"
        elif key == "interfaceTags":
            suggest = "interface_tags"
        elif key == "ipSourceGuard":
            suggest = "ip_source_guard"
        elif key == "islLocalTrunkName":
            suggest = "isl_local_trunk_name"
        elif key == "islPeerDeviceName":
            suggest = "isl_peer_device_name"
        elif key == "islPeerDeviceSn":
            suggest = "isl_peer_device_sn"
        elif key == "islPeerPortName":
            suggest = "isl_peer_port_name"
        elif key == "lacpSpeed":
            suggest = "lacp_speed"
        elif key == "learningLimit":
            suggest = "learning_limit"
        elif key == "linkStatus":
            suggest = "link_status"
        elif key == "lldpProfile":
            suggest = "lldp_profile"
        elif key == "lldpStatus":
            suggest = "lldp_status"
        elif key == "loopGuard":
            suggest = "loop_guard"
        elif key == "loopGuardTimeout":
            suggest = "loop_guard_timeout"
        elif key == "macAddr":
            suggest = "mac_addr"
        elif key == "matchedDppIntfTags":
            suggest = "matched_dpp_intf_tags"
        elif key == "matchedDppPolicy":
            suggest = "matched_dpp_policy"
        elif key == "maxBundle":
            suggest = "max_bundle"
        elif key == "mcastSnoopingFloodTraffic":
            suggest = "mcast_snooping_flood_traffic"
        elif key == "mclagIclPort":
            suggest = "mclag_icl_port"
        elif key == "mediaType":
            suggest = "media_type"
        elif key == "memberWithdrawalBehavior":
            suggest = "member_withdrawal_behavior"
        elif key == "minBundle":
            suggest = "min_bundle"
        elif key == "p2pPort":
            suggest = "p2p_port"
        elif key == "packetSampleRate":
            suggest = "packet_sample_rate"
        elif key == "packetSampler":
            suggest = "packet_sampler"
        elif key == "pauseMeter":
            suggest = "pause_meter"
        elif key == "pauseMeterResume":
            suggest = "pause_meter_resume"
        elif key == "poeCapable":
            suggest = "poe_capable"
        elif key == "poeMaxPower":
            suggest = "poe_max_power"
        elif key == "poeModeBtCabable":
            suggest = "poe_mode_bt_cabable"
        elif key == "poePortMode":
            suggest = "poe_port_mode"
        elif key == "poePortPower":
            suggest = "poe_port_power"
        elif key == "poePortPriority":
            suggest = "poe_port_priority"
        elif key == "poePreStandardDetection":
            suggest = "poe_pre_standard_detection"
        elif key == "poeStandard":
            suggest = "poe_standard"
        elif key == "poeStatus":
            suggest = "poe_status"
        elif key == "portName":
            suggest = "port_name"
        elif key == "portNumber":
            suggest = "port_number"
        elif key == "portOwner":
            suggest = "port_owner"
        elif key == "portPolicy":
            suggest = "port_policy"
        elif key == "portPrefixType":
            suggest = "port_prefix_type"
        elif key == "portSecurityPolicy":
            suggest = "port_security_policy"
        elif key == "portSelectionCriteria":
            suggest = "port_selection_criteria"
        elif key == "ptpPolicy":
            suggest = "ptp_policy"
        elif key == "ptpStatus":
            suggest = "ptp_status"
        elif key == "qosPolicy":
            suggest = "qos_policy"
        elif key == "restrictedAuthPort":
            suggest = "restricted_auth_port"
        elif key == "rpvstPort":
            suggest = "rpvst_port"
        elif key == "sampleDirection":
            suggest = "sample_direction"
        elif key == "sflowCounterInterval":
            suggest = "sflow_counter_interval"
        elif key == "sflowSampleRate":
            suggest = "sflow_sample_rate"
        elif key == "sflowSampler":
            suggest = "sflow_sampler"
        elif key == "speedMask":
            suggest = "speed_mask"
        elif key == "stackingPort":
            suggest = "stacking_port"
        elif key == "stickyMac":
            suggest = "sticky_mac"
        elif key == "stormControlPolicy":
            suggest = "storm_control_policy"
        elif key == "stpBpduGuard":
            suggest = "stp_bpdu_guard"
        elif key == "stpBpduGuardTimeout":
            suggest = "stp_bpdu_guard_timeout"
        elif key == "stpRootGuard":
            suggest = "stp_root_guard"
        elif key == "stpState":
            suggest = "stp_state"
        elif key == "switchId":
            suggest = "switch_id"
        elif key == "untaggedVlans":
            suggest = "untagged_vlans"
        elif key == "virtualPort":
            suggest = "virtual_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_mode: Optional[str] = None,
                 acl_groups: Optional[Sequence['outputs.ManagedswitchPortAclGroup']] = None,
                 aggregator_mode: Optional[str] = None,
                 allowed_vlans: Optional[Sequence['outputs.ManagedswitchPortAllowedVlan']] = None,
                 allowed_vlans_all: Optional[str] = None,
                 arp_inspection_trust: Optional[str] = None,
                 authenticated_port: Optional[int] = None,
                 bundle: Optional[str] = None,
                 description: Optional[str] = None,
                 dhcp_snoop_option82_overrides: Optional[Sequence['outputs.ManagedswitchPortDhcpSnoopOption82Override']] = None,
                 dhcp_snoop_option82_trust: Optional[str] = None,
                 dhcp_snooping: Optional[str] = None,
                 discard_mode: Optional[str] = None,
                 edge_port: Optional[str] = None,
                 encrypted_port: Optional[int] = None,
                 export_tags: Optional[Sequence['outputs.ManagedswitchPortExportTag']] = None,
                 export_to: Optional[str] = None,
                 export_to_pool: Optional[str] = None,
                 export_to_pool_flag: Optional[int] = None,
                 fec_capable: Optional[int] = None,
                 fec_state: Optional[str] = None,
                 fgt_peer_device_name: Optional[str] = None,
                 fgt_peer_port_name: Optional[str] = None,
                 fiber_port: Optional[int] = None,
                 flags: Optional[int] = None,
                 flap_duration: Optional[int] = None,
                 flap_rate: Optional[int] = None,
                 flap_timeout: Optional[int] = None,
                 flapguard: Optional[str] = None,
                 flow_control: Optional[str] = None,
                 fortilink_port: Optional[int] = None,
                 fortiswitch_acls: Optional[Sequence['outputs.ManagedswitchPortFortiswitchAcl']] = None,
                 igmp_snooping: Optional[str] = None,
                 igmp_snooping_flood_reports: Optional[str] = None,
                 igmps_flood_reports: Optional[str] = None,
                 igmps_flood_traffic: Optional[str] = None,
                 interface_tags: Optional[Sequence['outputs.ManagedswitchPortInterfaceTag']] = None,
                 ip_source_guard: Optional[str] = None,
                 isl_local_trunk_name: Optional[str] = None,
                 isl_peer_device_name: Optional[str] = None,
                 isl_peer_device_sn: Optional[str] = None,
                 isl_peer_port_name: Optional[str] = None,
                 lacp_speed: Optional[str] = None,
                 learning_limit: Optional[int] = None,
                 link_status: Optional[str] = None,
                 lldp_profile: Optional[str] = None,
                 lldp_status: Optional[str] = None,
                 loop_guard: Optional[str] = None,
                 loop_guard_timeout: Optional[int] = None,
                 mac_addr: Optional[str] = None,
                 matched_dpp_intf_tags: Optional[str] = None,
                 matched_dpp_policy: Optional[str] = None,
                 max_bundle: Optional[int] = None,
                 mcast_snooping_flood_traffic: Optional[str] = None,
                 mclag: Optional[str] = None,
                 mclag_icl_port: Optional[int] = None,
                 media_type: Optional[str] = None,
                 member_withdrawal_behavior: Optional[str] = None,
                 members: Optional[Sequence['outputs.ManagedswitchPortMember']] = None,
                 min_bundle: Optional[int] = None,
                 mode: Optional[str] = None,
                 p2p_port: Optional[int] = None,
                 packet_sample_rate: Optional[int] = None,
                 packet_sampler: Optional[str] = None,
                 pause_meter: Optional[int] = None,
                 pause_meter_resume: Optional[str] = None,
                 poe_capable: Optional[int] = None,
                 poe_max_power: Optional[str] = None,
                 poe_mode_bt_cabable: Optional[int] = None,
                 poe_port_mode: Optional[str] = None,
                 poe_port_power: Optional[str] = None,
                 poe_port_priority: Optional[str] = None,
                 poe_pre_standard_detection: Optional[str] = None,
                 poe_standard: Optional[str] = None,
                 poe_status: Optional[str] = None,
                 port_name: Optional[str] = None,
                 port_number: Optional[int] = None,
                 port_owner: Optional[str] = None,
                 port_policy: Optional[str] = None,
                 port_prefix_type: Optional[int] = None,
                 port_security_policy: Optional[str] = None,
                 port_selection_criteria: Optional[str] = None,
                 ptp_policy: Optional[str] = None,
                 ptp_status: Optional[str] = None,
                 qos_policy: Optional[str] = None,
                 restricted_auth_port: Optional[int] = None,
                 rpvst_port: Optional[str] = None,
                 sample_direction: Optional[str] = None,
                 sflow_counter_interval: Optional[int] = None,
                 sflow_sample_rate: Optional[int] = None,
                 sflow_sampler: Optional[str] = None,
                 speed: Optional[str] = None,
                 speed_mask: Optional[int] = None,
                 stacking_port: Optional[int] = None,
                 status: Optional[str] = None,
                 sticky_mac: Optional[str] = None,
                 storm_control_policy: Optional[str] = None,
                 stp_bpdu_guard: Optional[str] = None,
                 stp_bpdu_guard_timeout: Optional[int] = None,
                 stp_root_guard: Optional[str] = None,
                 stp_state: Optional[str] = None,
                 switch_id: Optional[str] = None,
                 type: Optional[str] = None,
                 untagged_vlans: Optional[Sequence['outputs.ManagedswitchPortUntaggedVlan']] = None,
                 virtual_port: Optional[int] = None,
                 vlan: Optional[str] = None):
        """
        :param str access_mode: Access mode of the port.
        :param Sequence['ManagedswitchPortAclGroupArgs'] acl_groups: ACL groups on this port. The structure of `acl_group` block is documented below.
        :param str aggregator_mode: LACP member select mode. Valid values: `bandwidth`, `count`.
        :param Sequence['ManagedswitchPortAllowedVlanArgs'] allowed_vlans: Configure switch port tagged vlans The structure of `allowed_vlans` block is documented below.
        :param str allowed_vlans_all: Enable/disable all defined vlans on this port. Valid values: `enable`, `disable`.
        :param str arp_inspection_trust: Trusted or untrusted dynamic ARP inspection. Valid values: `untrusted`, `trusted`.
        :param int authenticated_port: Peer to Peer Authenticated port.
        :param str bundle: Enable/disable Link Aggregation Group (LAG) bundling for non-FortiLink interfaces. Valid values: `enable`, `disable`.
        :param str description: Description for port.
        :param Sequence['ManagedswitchPortDhcpSnoopOption82OverrideArgs'] dhcp_snoop_option82_overrides: Configure DHCP snooping option 82 override. The structure of `dhcp_snoop_option82_override` block is documented below.
        :param str dhcp_snoop_option82_trust: Enable/disable allowance of DHCP with option-82 on untrusted interface. Valid values: `enable`, `disable`.
        :param str dhcp_snooping: Trusted or untrusted DHCP-snooping interface. Valid values: `untrusted`, `trusted`.
        :param str discard_mode: Configure discard mode for port. Valid values: `none`, `all-untagged`, `all-tagged`.
        :param str edge_port: Enable/disable this interface as an edge port, bridging connections between workstations and/or computers. Valid values: `enable`, `disable`.
        :param int encrypted_port: Peer to Peer Encrypted port.
        :param Sequence['ManagedswitchPortExportTagArgs'] export_tags: Switch controller export tag name. The structure of `export_tags` block is documented below.
        :param str export_to: Export managed-switch port to a tenant VDOM.
        :param str export_to_pool: Switch controller export port to pool-list.
        :param int export_to_pool_flag: Switch controller export port to pool-list.
        :param int fec_capable: FEC capable.
        :param str fec_state: State of forward error correction.
        :param str fgt_peer_device_name: FGT peer device name.
        :param str fgt_peer_port_name: FGT peer port name.
        :param int fiber_port: Fiber-port.
        :param int flags: Port properties flags.
        :param int flap_duration: Period over which flap events are calculated (seconds).
        :param int flap_rate: Number of stage change events needed within flap-duration.
        :param int flap_timeout: Flap guard disabling protection (min).
        :param str flapguard: Enable/disable flap guard. Valid values: `enable`, `disable`.
        :param str flow_control: Flow control direction. Valid values: `disable`, `tx`, `rx`, `both`.
        :param int fortilink_port: FortiLink uplink port.
        :param Sequence['ManagedswitchPortFortiswitchAclArgs'] fortiswitch_acls: ACLs on this port. The structure of `fortiswitch_acls` block is documented below.
        :param str igmp_snooping: Set IGMP snooping mode for the physical port interface. Valid values: `enable`, `disable`.
        :param str igmp_snooping_flood_reports: Enable/disable flooding of IGMP reports to this interface when igmp-snooping enabled. Valid values: `enable`, `disable`.
        :param str igmps_flood_reports: Enable/disable flooding of IGMP reports to this interface when igmp-snooping enabled. Valid values: `enable`, `disable`.
        :param str igmps_flood_traffic: Enable/disable flooding of IGMP snooping traffic to this interface. Valid values: `enable`, `disable`.
        :param Sequence['ManagedswitchPortInterfaceTagArgs'] interface_tags: Tag(s) associated with the interface for various features including virtual port pool, dynamic port policy. The structure of `interface_tags` block is documented below.
        :param str ip_source_guard: Enable/disable IP source guard. Valid values: `disable`, `enable`.
        :param str isl_local_trunk_name: ISL local trunk name.
        :param str isl_peer_device_name: ISL peer device name.
        :param str isl_peer_device_sn: ISL peer device serial number.
        :param str isl_peer_port_name: ISL peer port name.
        :param str lacp_speed: end Link Aggregation Control Protocol (LACP) messages every 30 seconds (slow) or every second (fast). Valid values: `slow`, `fast`.
        :param int learning_limit: Limit the number of dynamic MAC addresses on this Port (1 - 128, 0 = no limit, default).
        :param str link_status: Port link status. Valid values: `up`, `down`.
        :param str lldp_profile: LLDP port TLV profile.
        :param str lldp_status: LLDP transmit and receive status. Valid values: `disable`, `rx-only`, `tx-only`, `tx-rx`.
        :param str loop_guard: Enable/disable loop-guard on this interface, an STP optimization used to prevent network loops. Valid values: `enabled`, `disabled`.
        :param int loop_guard_timeout: Loop-guard timeout (0 - 120 min, default = 45).
        :param str mac_addr: Port/Trunk MAC.
        :param str matched_dpp_intf_tags: Matched interface tags in the dynamic port policy.
        :param str matched_dpp_policy: Matched child policy in the dynamic port policy.
        :param int max_bundle: Maximum size of LAG bundle (1 - 24, default = 24)
        :param str mcast_snooping_flood_traffic: Enable/disable flooding of IGMP snooping traffic to this interface. Valid values: `enable`, `disable`.
        :param str mclag: Enable/disable multi-chassis link aggregation (MCLAG). Valid values: `enable`, `disable`.
        :param int mclag_icl_port: MCLAG-ICL port.
        :param str media_type: Media type.
        :param str member_withdrawal_behavior: Port behavior after it withdraws because of loss of control packets. Valid values: `forward`, `block`.
        :param Sequence['ManagedswitchPortMemberArgs'] members: Aggregated LAG bundle interfaces. The structure of `members` block is documented below.
        :param int min_bundle: Minimum size of LAG bundle (1 - 24, default = 1)
        :param str mode: LACP mode: ignore and do not send control messages, or negotiate 802.3ad aggregation passively or actively. Valid values: `static`, `lacp-passive`, `lacp-active`.
        :param int p2p_port: General peer to peer tunnel port.
        :param int packet_sample_rate: Packet sampling rate (0 - 99999 p/sec).
        :param str packet_sampler: Enable/disable packet sampling on this interface. Valid values: `enabled`, `disabled`.
        :param int pause_meter: Configure ingress pause metering rate, in kbps (default = 0, disabled).
        :param str pause_meter_resume: Resume threshold for resuming traffic on ingress port. Valid values: `75%!`(MISSING), `50%!`(MISSING), `25%!`(MISSING).
        :param int poe_capable: PoE capable.
        :param str poe_max_power: PoE maximum power.
        :param int poe_mode_bt_cabable: PoE mode IEEE 802.3BT capable.
        :param str poe_port_mode: Configure PoE port mode. Valid values: `ieee802-3af`, `ieee802-3at`, `ieee802-3bt`.
        :param str poe_port_power: Configure PoE port power. Valid values: `normal`, `perpetual`, `perpetual-fast`.
        :param str poe_port_priority: Configure PoE port priority. Valid values: `critical-priority`, `high-priority`, `low-priority`, `medium-priority`.
        :param str poe_pre_standard_detection: Enable/disable PoE pre-standard detection. Valid values: `enable`, `disable`.
        :param str poe_standard: PoE standard supported.
        :param str poe_status: Enable/disable PoE status. Valid values: `enable`, `disable`.
        :param str port_name: Switch port name.
        :param int port_number: Port number.
        :param str port_owner: Switch port name.
        :param str port_policy: Switch controller dynamic port policy from available options.
        :param int port_prefix_type: Port prefix type.
        :param str port_security_policy: Switch controller authentication policy to apply to this managed switch from available options.
        :param str port_selection_criteria: Algorithm for aggregate port selection. Valid values: `src-mac`, `dst-mac`, `src-dst-mac`, `src-ip`, `dst-ip`, `src-dst-ip`.
        :param str ptp_policy: PTP policy configuration.
        :param str ptp_status: Enable/disable PTP policy on this FortiSwitch port. Valid values: `disable`, `enable`.
        :param str qos_policy: Switch controller QoS policy from available options.
        :param int restricted_auth_port: Peer to Peer Restricted Authenticated port.
        :param str rpvst_port: Enable/disable inter-operability with rapid PVST on this interface. Valid values: `disabled`, `enabled`.
        :param str sample_direction: sFlow sample direction. Valid values: `tx`, `rx`, `both`.
        :param int sflow_counter_interval: sFlow sampler counter polling interval (1 - 255 sec).
        :param int sflow_sample_rate: sFlow sampler sample rate (0 - 99999 p/sec).
        :param str sflow_sampler: Enable/disable sFlow protocol on this interface. Valid values: `enabled`, `disabled`.
        :param str speed: Switch port speed; default and available settings depend on hardware.
        :param int speed_mask: Switch port speed mask.
        :param int stacking_port: Stacking port.
        :param str status: Switch port admin status: up or down. Valid values: `up`, `down`.
        :param str sticky_mac: Enable or disable sticky-mac on the interface. Valid values: `enable`, `disable`.
        :param str storm_control_policy: Switch controller storm control policy from available options.
        :param str stp_bpdu_guard: Enable/disable STP BPDU guard on this interface. Valid values: `enabled`, `disabled`.
        :param int stp_bpdu_guard_timeout: BPDU Guard disabling protection (0 - 120 min).
        :param str stp_root_guard: Enable/disable STP root guard on this interface. Valid values: `enabled`, `disabled`.
        :param str stp_state: Enable/disable Spanning Tree Protocol (STP) on this interface. Valid values: `enabled`, `disabled`.
        :param str switch_id: Switch id.
        :param str type: Interface type: physical or trunk port. Valid values: `physical`, `trunk`.
        :param Sequence['ManagedswitchPortUntaggedVlanArgs'] untagged_vlans: Configure switch port untagged vlans The structure of `untagged_vlans` block is documented below.
        :param int virtual_port: Virtualized switch port.
        :param str vlan: Assign switch ports to a VLAN.
        """
        if access_mode is not None:
            pulumi.set(__self__, "access_mode", access_mode)
        if acl_groups is not None:
            pulumi.set(__self__, "acl_groups", acl_groups)
        if aggregator_mode is not None:
            pulumi.set(__self__, "aggregator_mode", aggregator_mode)
        if allowed_vlans is not None:
            pulumi.set(__self__, "allowed_vlans", allowed_vlans)
        if allowed_vlans_all is not None:
            pulumi.set(__self__, "allowed_vlans_all", allowed_vlans_all)
        if arp_inspection_trust is not None:
            pulumi.set(__self__, "arp_inspection_trust", arp_inspection_trust)
        if authenticated_port is not None:
            pulumi.set(__self__, "authenticated_port", authenticated_port)
        if bundle is not None:
            pulumi.set(__self__, "bundle", bundle)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if dhcp_snoop_option82_overrides is not None:
            pulumi.set(__self__, "dhcp_snoop_option82_overrides", dhcp_snoop_option82_overrides)
        if dhcp_snoop_option82_trust is not None:
            pulumi.set(__self__, "dhcp_snoop_option82_trust", dhcp_snoop_option82_trust)
        if dhcp_snooping is not None:
            pulumi.set(__self__, "dhcp_snooping", dhcp_snooping)
        if discard_mode is not None:
            pulumi.set(__self__, "discard_mode", discard_mode)
        if edge_port is not None:
            pulumi.set(__self__, "edge_port", edge_port)
        if encrypted_port is not None:
            pulumi.set(__self__, "encrypted_port", encrypted_port)
        if export_tags is not None:
            pulumi.set(__self__, "export_tags", export_tags)
        if export_to is not None:
            pulumi.set(__self__, "export_to", export_to)
        if export_to_pool is not None:
            pulumi.set(__self__, "export_to_pool", export_to_pool)
        if export_to_pool_flag is not None:
            pulumi.set(__self__, "export_to_pool_flag", export_to_pool_flag)
        if fec_capable is not None:
            pulumi.set(__self__, "fec_capable", fec_capable)
        if fec_state is not None:
            pulumi.set(__self__, "fec_state", fec_state)
        if fgt_peer_device_name is not None:
            pulumi.set(__self__, "fgt_peer_device_name", fgt_peer_device_name)
        if fgt_peer_port_name is not None:
            pulumi.set(__self__, "fgt_peer_port_name", fgt_peer_port_name)
        if fiber_port is not None:
            pulumi.set(__self__, "fiber_port", fiber_port)
        if flags is not None:
            pulumi.set(__self__, "flags", flags)
        if flap_duration is not None:
            pulumi.set(__self__, "flap_duration", flap_duration)
        if flap_rate is not None:
            pulumi.set(__self__, "flap_rate", flap_rate)
        if flap_timeout is not None:
            pulumi.set(__self__, "flap_timeout", flap_timeout)
        if flapguard is not None:
            pulumi.set(__self__, "flapguard", flapguard)
        if flow_control is not None:
            pulumi.set(__self__, "flow_control", flow_control)
        if fortilink_port is not None:
            pulumi.set(__self__, "fortilink_port", fortilink_port)
        if fortiswitch_acls is not None:
            pulumi.set(__self__, "fortiswitch_acls", fortiswitch_acls)
        if igmp_snooping is not None:
            pulumi.set(__self__, "igmp_snooping", igmp_snooping)
        if igmp_snooping_flood_reports is not None:
            pulumi.set(__self__, "igmp_snooping_flood_reports", igmp_snooping_flood_reports)
        if igmps_flood_reports is not None:
            pulumi.set(__self__, "igmps_flood_reports", igmps_flood_reports)
        if igmps_flood_traffic is not None:
            pulumi.set(__self__, "igmps_flood_traffic", igmps_flood_traffic)
        if interface_tags is not None:
            pulumi.set(__self__, "interface_tags", interface_tags)
        if ip_source_guard is not None:
            pulumi.set(__self__, "ip_source_guard", ip_source_guard)
        if isl_local_trunk_name is not None:
            pulumi.set(__self__, "isl_local_trunk_name", isl_local_trunk_name)
        if isl_peer_device_name is not None:
            pulumi.set(__self__, "isl_peer_device_name", isl_peer_device_name)
        if isl_peer_device_sn is not None:
            pulumi.set(__self__, "isl_peer_device_sn", isl_peer_device_sn)
        if isl_peer_port_name is not None:
            pulumi.set(__self__, "isl_peer_port_name", isl_peer_port_name)
        if lacp_speed is not None:
            pulumi.set(__self__, "lacp_speed", lacp_speed)
        if learning_limit is not None:
            pulumi.set(__self__, "learning_limit", learning_limit)
        if link_status is not None:
            pulumi.set(__self__, "link_status", link_status)
        if lldp_profile is not None:
            pulumi.set(__self__, "lldp_profile", lldp_profile)
        if lldp_status is not None:
            pulumi.set(__self__, "lldp_status", lldp_status)
        if loop_guard is not None:
            pulumi.set(__self__, "loop_guard", loop_guard)
        if loop_guard_timeout is not None:
            pulumi.set(__self__, "loop_guard_timeout", loop_guard_timeout)
        if mac_addr is not None:
            pulumi.set(__self__, "mac_addr", mac_addr)
        if matched_dpp_intf_tags is not None:
            pulumi.set(__self__, "matched_dpp_intf_tags", matched_dpp_intf_tags)
        if matched_dpp_policy is not None:
            pulumi.set(__self__, "matched_dpp_policy", matched_dpp_policy)
        if max_bundle is not None:
            pulumi.set(__self__, "max_bundle", max_bundle)
        if mcast_snooping_flood_traffic is not None:
            pulumi.set(__self__, "mcast_snooping_flood_traffic", mcast_snooping_flood_traffic)
        if mclag is not None:
            pulumi.set(__self__, "mclag", mclag)
        if mclag_icl_port is not None:
            pulumi.set(__self__, "mclag_icl_port", mclag_icl_port)
        if media_type is not None:
            pulumi.set(__self__, "media_type", media_type)
        if member_withdrawal_behavior is not None:
            pulumi.set(__self__, "member_withdrawal_behavior", member_withdrawal_behavior)
        if members is not None:
            pulumi.set(__self__, "members", members)
        if min_bundle is not None:
            pulumi.set(__self__, "min_bundle", min_bundle)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if p2p_port is not None:
            pulumi.set(__self__, "p2p_port", p2p_port)
        if packet_sample_rate is not None:
            pulumi.set(__self__, "packet_sample_rate", packet_sample_rate)
        if packet_sampler is not None:
            pulumi.set(__self__, "packet_sampler", packet_sampler)
        if pause_meter is not None:
            pulumi.set(__self__, "pause_meter", pause_meter)
        if pause_meter_resume is not None:
            pulumi.set(__self__, "pause_meter_resume", pause_meter_resume)
        if poe_capable is not None:
            pulumi.set(__self__, "poe_capable", poe_capable)
        if poe_max_power is not None:
            pulumi.set(__self__, "poe_max_power", poe_max_power)
        if poe_mode_bt_cabable is not None:
            pulumi.set(__self__, "poe_mode_bt_cabable", poe_mode_bt_cabable)
        if poe_port_mode is not None:
            pulumi.set(__self__, "poe_port_mode", poe_port_mode)
        if poe_port_power is not None:
            pulumi.set(__self__, "poe_port_power", poe_port_power)
        if poe_port_priority is not None:
            pulumi.set(__self__, "poe_port_priority", poe_port_priority)
        if poe_pre_standard_detection is not None:
            pulumi.set(__self__, "poe_pre_standard_detection", poe_pre_standard_detection)
        if poe_standard is not None:
            pulumi.set(__self__, "poe_standard", poe_standard)
        if poe_status is not None:
            pulumi.set(__self__, "poe_status", poe_status)
        if port_name is not None:
            pulumi.set(__self__, "port_name", port_name)
        if port_number is not None:
            pulumi.set(__self__, "port_number", port_number)
        if port_owner is not None:
            pulumi.set(__self__, "port_owner", port_owner)
        if port_policy is not None:
            pulumi.set(__self__, "port_policy", port_policy)
        if port_prefix_type is not None:
            pulumi.set(__self__, "port_prefix_type", port_prefix_type)
        if port_security_policy is not None:
            pulumi.set(__self__, "port_security_policy", port_security_policy)
        if port_selection_criteria is not None:
            pulumi.set(__self__, "port_selection_criteria", port_selection_criteria)
        if ptp_policy is not None:
            pulumi.set(__self__, "ptp_policy", ptp_policy)
        if ptp_status is not None:
            pulumi.set(__self__, "ptp_status", ptp_status)
        if qos_policy is not None:
            pulumi.set(__self__, "qos_policy", qos_policy)
        if restricted_auth_port is not None:
            pulumi.set(__self__, "restricted_auth_port", restricted_auth_port)
        if rpvst_port is not None:
            pulumi.set(__self__, "rpvst_port", rpvst_port)
        if sample_direction is not None:
            pulumi.set(__self__, "sample_direction", sample_direction)
        if sflow_counter_interval is not None:
            pulumi.set(__self__, "sflow_counter_interval", sflow_counter_interval)
        if sflow_sample_rate is not None:
            pulumi.set(__self__, "sflow_sample_rate", sflow_sample_rate)
        if sflow_sampler is not None:
            pulumi.set(__self__, "sflow_sampler", sflow_sampler)
        if speed is not None:
            pulumi.set(__self__, "speed", speed)
        if speed_mask is not None:
            pulumi.set(__self__, "speed_mask", speed_mask)
        if stacking_port is not None:
            pulumi.set(__self__, "stacking_port", stacking_port)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if sticky_mac is not None:
            pulumi.set(__self__, "sticky_mac", sticky_mac)
        if storm_control_policy is not None:
            pulumi.set(__self__, "storm_control_policy", storm_control_policy)
        if stp_bpdu_guard is not None:
            pulumi.set(__self__, "stp_bpdu_guard", stp_bpdu_guard)
        if stp_bpdu_guard_timeout is not None:
            pulumi.set(__self__, "stp_bpdu_guard_timeout", stp_bpdu_guard_timeout)
        if stp_root_guard is not None:
            pulumi.set(__self__, "stp_root_guard", stp_root_guard)
        if stp_state is not None:
            pulumi.set(__self__, "stp_state", stp_state)
        if switch_id is not None:
            pulumi.set(__self__, "switch_id", switch_id)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if untagged_vlans is not None:
            pulumi.set(__self__, "untagged_vlans", untagged_vlans)
        if virtual_port is not None:
            pulumi.set(__self__, "virtual_port", virtual_port)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @property
    @pulumi.getter(name="accessMode")
    def access_mode(self) -> Optional[str]:
        """
        Access mode of the port.
        """
        return pulumi.get(self, "access_mode")

    @property
    @pulumi.getter(name="aclGroups")
    def acl_groups(self) -> Optional[Sequence['outputs.ManagedswitchPortAclGroup']]:
        """
        ACL groups on this port. The structure of `acl_group` block is documented below.
        """
        return pulumi.get(self, "acl_groups")

    @property
    @pulumi.getter(name="aggregatorMode")
    def aggregator_mode(self) -> Optional[str]:
        """
        LACP member select mode. Valid values: `bandwidth`, `count`.
        """
        return pulumi.get(self, "aggregator_mode")

    @property
    @pulumi.getter(name="allowedVlans")
    def allowed_vlans(self) -> Optional[Sequence['outputs.ManagedswitchPortAllowedVlan']]:
        """
        Configure switch port tagged vlans The structure of `allowed_vlans` block is documented below.
        """
        return pulumi.get(self, "allowed_vlans")

    @property
    @pulumi.getter(name="allowedVlansAll")
    def allowed_vlans_all(self) -> Optional[str]:
        """
        Enable/disable all defined vlans on this port. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "allowed_vlans_all")

    @property
    @pulumi.getter(name="arpInspectionTrust")
    def arp_inspection_trust(self) -> Optional[str]:
        """
        Trusted or untrusted dynamic ARP inspection. Valid values: `untrusted`, `trusted`.
        """
        return pulumi.get(self, "arp_inspection_trust")

    @property
    @pulumi.getter(name="authenticatedPort")
    def authenticated_port(self) -> Optional[int]:
        """
        Peer to Peer Authenticated port.
        """
        return pulumi.get(self, "authenticated_port")

    @property
    @pulumi.getter
    def bundle(self) -> Optional[str]:
        """
        Enable/disable Link Aggregation Group (LAG) bundling for non-FortiLink interfaces. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "bundle")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for port.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="dhcpSnoopOption82Overrides")
    def dhcp_snoop_option82_overrides(self) -> Optional[Sequence['outputs.ManagedswitchPortDhcpSnoopOption82Override']]:
        """
        Configure DHCP snooping option 82 override. The structure of `dhcp_snoop_option82_override` block is documented below.
        """
        return pulumi.get(self, "dhcp_snoop_option82_overrides")

    @property
    @pulumi.getter(name="dhcpSnoopOption82Trust")
    def dhcp_snoop_option82_trust(self) -> Optional[str]:
        """
        Enable/disable allowance of DHCP with option-82 on untrusted interface. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "dhcp_snoop_option82_trust")

    @property
    @pulumi.getter(name="dhcpSnooping")
    def dhcp_snooping(self) -> Optional[str]:
        """
        Trusted or untrusted DHCP-snooping interface. Valid values: `untrusted`, `trusted`.
        """
        return pulumi.get(self, "dhcp_snooping")

    @property
    @pulumi.getter(name="discardMode")
    def discard_mode(self) -> Optional[str]:
        """
        Configure discard mode for port. Valid values: `none`, `all-untagged`, `all-tagged`.
        """
        return pulumi.get(self, "discard_mode")

    @property
    @pulumi.getter(name="edgePort")
    def edge_port(self) -> Optional[str]:
        """
        Enable/disable this interface as an edge port, bridging connections between workstations and/or computers. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "edge_port")

    @property
    @pulumi.getter(name="encryptedPort")
    def encrypted_port(self) -> Optional[int]:
        """
        Peer to Peer Encrypted port.
        """
        return pulumi.get(self, "encrypted_port")

    @property
    @pulumi.getter(name="exportTags")
    def export_tags(self) -> Optional[Sequence['outputs.ManagedswitchPortExportTag']]:
        """
        Switch controller export tag name. The structure of `export_tags` block is documented below.
        """
        return pulumi.get(self, "export_tags")

    @property
    @pulumi.getter(name="exportTo")
    def export_to(self) -> Optional[str]:
        """
        Export managed-switch port to a tenant VDOM.
        """
        return pulumi.get(self, "export_to")

    @property
    @pulumi.getter(name="exportToPool")
    def export_to_pool(self) -> Optional[str]:
        """
        Switch controller export port to pool-list.
        """
        return pulumi.get(self, "export_to_pool")

    @property
    @pulumi.getter(name="exportToPoolFlag")
    def export_to_pool_flag(self) -> Optional[int]:
        """
        Switch controller export port to pool-list.
        """
        return pulumi.get(self, "export_to_pool_flag")

    @property
    @pulumi.getter(name="fecCapable")
    def fec_capable(self) -> Optional[int]:
        """
        FEC capable.
        """
        return pulumi.get(self, "fec_capable")

    @property
    @pulumi.getter(name="fecState")
    def fec_state(self) -> Optional[str]:
        """
        State of forward error correction.
        """
        return pulumi.get(self, "fec_state")

    @property
    @pulumi.getter(name="fgtPeerDeviceName")
    def fgt_peer_device_name(self) -> Optional[str]:
        """
        FGT peer device name.
        """
        return pulumi.get(self, "fgt_peer_device_name")

    @property
    @pulumi.getter(name="fgtPeerPortName")
    def fgt_peer_port_name(self) -> Optional[str]:
        """
        FGT peer port name.
        """
        return pulumi.get(self, "fgt_peer_port_name")

    @property
    @pulumi.getter(name="fiberPort")
    def fiber_port(self) -> Optional[int]:
        """
        Fiber-port.
        """
        return pulumi.get(self, "fiber_port")

    @property
    @pulumi.getter
    def flags(self) -> Optional[int]:
        """
        Port properties flags.
        """
        return pulumi.get(self, "flags")

    @property
    @pulumi.getter(name="flapDuration")
    def flap_duration(self) -> Optional[int]:
        """
        Period over which flap events are calculated (seconds).
        """
        return pulumi.get(self, "flap_duration")

    @property
    @pulumi.getter(name="flapRate")
    def flap_rate(self) -> Optional[int]:
        """
        Number of stage change events needed within flap-duration.
        """
        return pulumi.get(self, "flap_rate")

    @property
    @pulumi.getter(name="flapTimeout")
    def flap_timeout(self) -> Optional[int]:
        """
        Flap guard disabling protection (min).
        """
        return pulumi.get(self, "flap_timeout")

    @property
    @pulumi.getter
    def flapguard(self) -> Optional[str]:
        """
        Enable/disable flap guard. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "flapguard")

    @property
    @pulumi.getter(name="flowControl")
    def flow_control(self) -> Optional[str]:
        """
        Flow control direction. Valid values: `disable`, `tx`, `rx`, `both`.
        """
        return pulumi.get(self, "flow_control")

    @property
    @pulumi.getter(name="fortilinkPort")
    def fortilink_port(self) -> Optional[int]:
        """
        FortiLink uplink port.
        """
        return pulumi.get(self, "fortilink_port")

    @property
    @pulumi.getter(name="fortiswitchAcls")
    def fortiswitch_acls(self) -> Optional[Sequence['outputs.ManagedswitchPortFortiswitchAcl']]:
        """
        ACLs on this port. The structure of `fortiswitch_acls` block is documented below.
        """
        return pulumi.get(self, "fortiswitch_acls")

    @property
    @pulumi.getter(name="igmpSnooping")
    def igmp_snooping(self) -> Optional[str]:
        """
        Set IGMP snooping mode for the physical port interface. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "igmp_snooping")

    @property
    @pulumi.getter(name="igmpSnoopingFloodReports")
    def igmp_snooping_flood_reports(self) -> Optional[str]:
        """
        Enable/disable flooding of IGMP reports to this interface when igmp-snooping enabled. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "igmp_snooping_flood_reports")

    @property
    @pulumi.getter(name="igmpsFloodReports")
    def igmps_flood_reports(self) -> Optional[str]:
        """
        Enable/disable flooding of IGMP reports to this interface when igmp-snooping enabled. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "igmps_flood_reports")

    @property
    @pulumi.getter(name="igmpsFloodTraffic")
    def igmps_flood_traffic(self) -> Optional[str]:
        """
        Enable/disable flooding of IGMP snooping traffic to this interface. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "igmps_flood_traffic")

    @property
    @pulumi.getter(name="interfaceTags")
    def interface_tags(self) -> Optional[Sequence['outputs.ManagedswitchPortInterfaceTag']]:
        """
        Tag(s) associated with the interface for various features including virtual port pool, dynamic port policy. The structure of `interface_tags` block is documented below.
        """
        return pulumi.get(self, "interface_tags")

    @property
    @pulumi.getter(name="ipSourceGuard")
    def ip_source_guard(self) -> Optional[str]:
        """
        Enable/disable IP source guard. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "ip_source_guard")

    @property
    @pulumi.getter(name="islLocalTrunkName")
    def isl_local_trunk_name(self) -> Optional[str]:
        """
        ISL local trunk name.
        """
        return pulumi.get(self, "isl_local_trunk_name")

    @property
    @pulumi.getter(name="islPeerDeviceName")
    def isl_peer_device_name(self) -> Optional[str]:
        """
        ISL peer device name.
        """
        return pulumi.get(self, "isl_peer_device_name")

    @property
    @pulumi.getter(name="islPeerDeviceSn")
    def isl_peer_device_sn(self) -> Optional[str]:
        """
        ISL peer device serial number.
        """
        return pulumi.get(self, "isl_peer_device_sn")

    @property
    @pulumi.getter(name="islPeerPortName")
    def isl_peer_port_name(self) -> Optional[str]:
        """
        ISL peer port name.
        """
        return pulumi.get(self, "isl_peer_port_name")

    @property
    @pulumi.getter(name="lacpSpeed")
    def lacp_speed(self) -> Optional[str]:
        """
        end Link Aggregation Control Protocol (LACP) messages every 30 seconds (slow) or every second (fast). Valid values: `slow`, `fast`.
        """
        return pulumi.get(self, "lacp_speed")

    @property
    @pulumi.getter(name="learningLimit")
    def learning_limit(self) -> Optional[int]:
        """
        Limit the number of dynamic MAC addresses on this Port (1 - 128, 0 = no limit, default).
        """
        return pulumi.get(self, "learning_limit")

    @property
    @pulumi.getter(name="linkStatus")
    def link_status(self) -> Optional[str]:
        """
        Port link status. Valid values: `up`, `down`.
        """
        return pulumi.get(self, "link_status")

    @property
    @pulumi.getter(name="lldpProfile")
    def lldp_profile(self) -> Optional[str]:
        """
        LLDP port TLV profile.
        """
        return pulumi.get(self, "lldp_profile")

    @property
    @pulumi.getter(name="lldpStatus")
    def lldp_status(self) -> Optional[str]:
        """
        LLDP transmit and receive status. Valid values: `disable`, `rx-only`, `tx-only`, `tx-rx`.
        """
        return pulumi.get(self, "lldp_status")

    @property
    @pulumi.getter(name="loopGuard")
    def loop_guard(self) -> Optional[str]:
        """
        Enable/disable loop-guard on this interface, an STP optimization used to prevent network loops. Valid values: `enabled`, `disabled`.
        """
        return pulumi.get(self, "loop_guard")

    @property
    @pulumi.getter(name="loopGuardTimeout")
    def loop_guard_timeout(self) -> Optional[int]:
        """
        Loop-guard timeout (0 - 120 min, default = 45).
        """
        return pulumi.get(self, "loop_guard_timeout")

    @property
    @pulumi.getter(name="macAddr")
    def mac_addr(self) -> Optional[str]:
        """
        Port/Trunk MAC.
        """
        return pulumi.get(self, "mac_addr")

    @property
    @pulumi.getter(name="matchedDppIntfTags")
    def matched_dpp_intf_tags(self) -> Optional[str]:
        """
        Matched interface tags in the dynamic port policy.
        """
        return pulumi.get(self, "matched_dpp_intf_tags")

    @property
    @pulumi.getter(name="matchedDppPolicy")
    def matched_dpp_policy(self) -> Optional[str]:
        """
        Matched child policy in the dynamic port policy.
        """
        return pulumi.get(self, "matched_dpp_policy")

    @property
    @pulumi.getter(name="maxBundle")
    def max_bundle(self) -> Optional[int]:
        """
        Maximum size of LAG bundle (1 - 24, default = 24)
        """
        return pulumi.get(self, "max_bundle")

    @property
    @pulumi.getter(name="mcastSnoopingFloodTraffic")
    def mcast_snooping_flood_traffic(self) -> Optional[str]:
        """
        Enable/disable flooding of IGMP snooping traffic to this interface. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "mcast_snooping_flood_traffic")

    @property
    @pulumi.getter
    def mclag(self) -> Optional[str]:
        """
        Enable/disable multi-chassis link aggregation (MCLAG). Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "mclag")

    @property
    @pulumi.getter(name="mclagIclPort")
    def mclag_icl_port(self) -> Optional[int]:
        """
        MCLAG-ICL port.
        """
        return pulumi.get(self, "mclag_icl_port")

    @property
    @pulumi.getter(name="mediaType")
    def media_type(self) -> Optional[str]:
        """
        Media type.
        """
        return pulumi.get(self, "media_type")

    @property
    @pulumi.getter(name="memberWithdrawalBehavior")
    def member_withdrawal_behavior(self) -> Optional[str]:
        """
        Port behavior after it withdraws because of loss of control packets. Valid values: `forward`, `block`.
        """
        return pulumi.get(self, "member_withdrawal_behavior")

    @property
    @pulumi.getter
    def members(self) -> Optional[Sequence['outputs.ManagedswitchPortMember']]:
        """
        Aggregated LAG bundle interfaces. The structure of `members` block is documented below.
        """
        return pulumi.get(self, "members")

    @property
    @pulumi.getter(name="minBundle")
    def min_bundle(self) -> Optional[int]:
        """
        Minimum size of LAG bundle (1 - 24, default = 1)
        """
        return pulumi.get(self, "min_bundle")

    @property
    @pulumi.getter
    def mode(self) -> Optional[str]:
        """
        LACP mode: ignore and do not send control messages, or negotiate 802.3ad aggregation passively or actively. Valid values: `static`, `lacp-passive`, `lacp-active`.
        """
        return pulumi.get(self, "mode")

    @property
    @pulumi.getter(name="p2pPort")
    def p2p_port(self) -> Optional[int]:
        """
        General peer to peer tunnel port.
        """
        return pulumi.get(self, "p2p_port")

    @property
    @pulumi.getter(name="packetSampleRate")
    def packet_sample_rate(self) -> Optional[int]:
        """
        Packet sampling rate (0 - 99999 p/sec).
        """
        return pulumi.get(self, "packet_sample_rate")

    @property
    @pulumi.getter(name="packetSampler")
    def packet_sampler(self) -> Optional[str]:
        """
        Enable/disable packet sampling on this interface. Valid values: `enabled`, `disabled`.
        """
        return pulumi.get(self, "packet_sampler")

    @property
    @pulumi.getter(name="pauseMeter")
    def pause_meter(self) -> Optional[int]:
        """
        Configure ingress pause metering rate, in kbps (default = 0, disabled).
        """
        return pulumi.get(self, "pause_meter")

    @property
    @pulumi.getter(name="pauseMeterResume")
    def pause_meter_resume(self) -> Optional[str]:
        """
        Resume threshold for resuming traffic on ingress port. Valid values: `75%!`(MISSING), `50%!`(MISSING), `25%!`(MISSING).
        """
        return pulumi.get(self, "pause_meter_resume")

    @property
    @pulumi.getter(name="poeCapable")
    def poe_capable(self) -> Optional[int]:
        """
        PoE capable.
        """
        return pulumi.get(self, "poe_capable")

    @property
    @pulumi.getter(name="poeMaxPower")
    def poe_max_power(self) -> Optional[str]:
        """
        PoE maximum power.
        """
        return pulumi.get(self, "poe_max_power")

    @property
    @pulumi.getter(name="poeModeBtCabable")
    def poe_mode_bt_cabable(self) -> Optional[int]:
        """
        PoE mode IEEE 802.3BT capable.
        """
        return pulumi.get(self, "poe_mode_bt_cabable")

    @property
    @pulumi.getter(name="poePortMode")
    def poe_port_mode(self) -> Optional[str]:
        """
        Configure PoE port mode. Valid values: `ieee802-3af`, `ieee802-3at`, `ieee802-3bt`.
        """
        return pulumi.get(self, "poe_port_mode")

    @property
    @pulumi.getter(name="poePortPower")
    def poe_port_power(self) -> Optional[str]:
        """
        Configure PoE port power. Valid values: `normal`, `perpetual`, `perpetual-fast`.
        """
        return pulumi.get(self, "poe_port_power")

    @property
    @pulumi.getter(name="poePortPriority")
    def poe_port_priority(self) -> Optional[str]:
        """
        Configure PoE port priority. Valid values: `critical-priority`, `high-priority`, `low-priority`, `medium-priority`.
        """
        return pulumi.get(self, "poe_port_priority")

    @property
    @pulumi.getter(name="poePreStandardDetection")
    def poe_pre_standard_detection(self) -> Optional[str]:
        """
        Enable/disable PoE pre-standard detection. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "poe_pre_standard_detection")

    @property
    @pulumi.getter(name="poeStandard")
    def poe_standard(self) -> Optional[str]:
        """
        PoE standard supported.
        """
        return pulumi.get(self, "poe_standard")

    @property
    @pulumi.getter(name="poeStatus")
    def poe_status(self) -> Optional[str]:
        """
        Enable/disable PoE status. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "poe_status")

    @property
    @pulumi.getter(name="portName")
    def port_name(self) -> Optional[str]:
        """
        Switch port name.
        """
        return pulumi.get(self, "port_name")

    @property
    @pulumi.getter(name="portNumber")
    def port_number(self) -> Optional[int]:
        """
        Port number.
        """
        return pulumi.get(self, "port_number")

    @property
    @pulumi.getter(name="portOwner")
    def port_owner(self) -> Optional[str]:
        """
        Switch port name.
        """
        return pulumi.get(self, "port_owner")

    @property
    @pulumi.getter(name="portPolicy")
    def port_policy(self) -> Optional[str]:
        """
        Switch controller dynamic port policy from available options.
        """
        return pulumi.get(self, "port_policy")

    @property
    @pulumi.getter(name="portPrefixType")
    def port_prefix_type(self) -> Optional[int]:
        """
        Port prefix type.
        """
        return pulumi.get(self, "port_prefix_type")

    @property
    @pulumi.getter(name="portSecurityPolicy")
    def port_security_policy(self) -> Optional[str]:
        """
        Switch controller authentication policy to apply to this managed switch from available options.
        """
        return pulumi.get(self, "port_security_policy")

    @property
    @pulumi.getter(name="portSelectionCriteria")
    def port_selection_criteria(self) -> Optional[str]:
        """
        Algorithm for aggregate port selection. Valid values: `src-mac`, `dst-mac`, `src-dst-mac`, `src-ip`, `dst-ip`, `src-dst-ip`.
        """
        return pulumi.get(self, "port_selection_criteria")

    @property
    @pulumi.getter(name="ptpPolicy")
    def ptp_policy(self) -> Optional[str]:
        """
        PTP policy configuration.
        """
        return pulumi.get(self, "ptp_policy")

    @property
    @pulumi.getter(name="ptpStatus")
    def ptp_status(self) -> Optional[str]:
        """
        Enable/disable PTP policy on this FortiSwitch port. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "ptp_status")

    @property
    @pulumi.getter(name="qosPolicy")
    def qos_policy(self) -> Optional[str]:
        """
        Switch controller QoS policy from available options.
        """
        return pulumi.get(self, "qos_policy")

    @property
    @pulumi.getter(name="restrictedAuthPort")
    def restricted_auth_port(self) -> Optional[int]:
        """
        Peer to Peer Restricted Authenticated port.
        """
        return pulumi.get(self, "restricted_auth_port")

    @property
    @pulumi.getter(name="rpvstPort")
    def rpvst_port(self) -> Optional[str]:
        """
        Enable/disable inter-operability with rapid PVST on this interface. Valid values: `disabled`, `enabled`.
        """
        return pulumi.get(self, "rpvst_port")

    @property
    @pulumi.getter(name="sampleDirection")
    def sample_direction(self) -> Optional[str]:
        """
        sFlow sample direction. Valid values: `tx`, `rx`, `both`.
        """
        return pulumi.get(self, "sample_direction")

    @property
    @pulumi.getter(name="sflowCounterInterval")
    def sflow_counter_interval(self) -> Optional[int]:
        """
        sFlow sampler counter polling interval (1 - 255 sec).
        """
        return pulumi.get(self, "sflow_counter_interval")

    @property
    @pulumi.getter(name="sflowSampleRate")
    def sflow_sample_rate(self) -> Optional[int]:
        """
        sFlow sampler sample rate (0 - 99999 p/sec).
        """
        return pulumi.get(self, "sflow_sample_rate")

    @property
    @pulumi.getter(name="sflowSampler")
    def sflow_sampler(self) -> Optional[str]:
        """
        Enable/disable sFlow protocol on this interface. Valid values: `enabled`, `disabled`.
        """
        return pulumi.get(self, "sflow_sampler")

    @property
    @pulumi.getter
    def speed(self) -> Optional[str]:
        """
        Switch port speed; default and available settings depend on hardware.
        """
        return pulumi.get(self, "speed")

    @property
    @pulumi.getter(name="speedMask")
    def speed_mask(self) -> Optional[int]:
        """
        Switch port speed mask.
        """
        return pulumi.get(self, "speed_mask")

    @property
    @pulumi.getter(name="stackingPort")
    def stacking_port(self) -> Optional[int]:
        """
        Stacking port.
        """
        return pulumi.get(self, "stacking_port")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Switch port admin status: up or down. Valid values: `up`, `down`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="stickyMac")
    def sticky_mac(self) -> Optional[str]:
        """
        Enable or disable sticky-mac on the interface. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "sticky_mac")

    @property
    @pulumi.getter(name="stormControlPolicy")
    def storm_control_policy(self) -> Optional[str]:
        """
        Switch controller storm control policy from available options.
        """
        return pulumi.get(self, "storm_control_policy")

    @property
    @pulumi.getter(name="stpBpduGuard")
    def stp_bpdu_guard(self) -> Optional[str]:
        """
        Enable/disable STP BPDU guard on this interface. Valid values: `enabled`, `disabled`.
        """
        return pulumi.get(self, "stp_bpdu_guard")

    @property
    @pulumi.getter(name="stpBpduGuardTimeout")
    def stp_bpdu_guard_timeout(self) -> Optional[int]:
        """
        BPDU Guard disabling protection (0 - 120 min).
        """
        return pulumi.get(self, "stp_bpdu_guard_timeout")

    @property
    @pulumi.getter(name="stpRootGuard")
    def stp_root_guard(self) -> Optional[str]:
        """
        Enable/disable STP root guard on this interface. Valid values: `enabled`, `disabled`.
        """
        return pulumi.get(self, "stp_root_guard")

    @property
    @pulumi.getter(name="stpState")
    def stp_state(self) -> Optional[str]:
        """
        Enable/disable Spanning Tree Protocol (STP) on this interface. Valid values: `enabled`, `disabled`.
        """
        return pulumi.get(self, "stp_state")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> Optional[str]:
        """
        Switch id.
        """
        return pulumi.get(self, "switch_id")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Interface type: physical or trunk port. Valid values: `physical`, `trunk`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="untaggedVlans")
    def untagged_vlans(self) -> Optional[Sequence['outputs.ManagedswitchPortUntaggedVlan']]:
        """
        Configure switch port untagged vlans The structure of `untagged_vlans` block is documented below.
        """
        return pulumi.get(self, "untagged_vlans")

    @property
    @pulumi.getter(name="virtualPort")
    def virtual_port(self) -> Optional[int]:
        """
        Virtualized switch port.
        """
        return pulumi.get(self, "virtual_port")

    @property
    @pulumi.getter
    def vlan(self) -> Optional[str]:
        """
        Assign switch ports to a VLAN.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class ManagedswitchPortAclGroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: ACL group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        ACL group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ManagedswitchPortAllowedVlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanName":
            suggest = "vlan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchPortAllowedVlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchPortAllowedVlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchPortAllowedVlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vlan_name: Optional[str] = None):
        """
        :param str vlan_name: VLAN name.
        """
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[str]:
        """
        VLAN name.
        """
        return pulumi.get(self, "vlan_name")


@pulumi.output_type
class ManagedswitchPortDhcpSnoopOption82Override(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "circuitId":
            suggest = "circuit_id"
        elif key == "remoteId":
            suggest = "remote_id"
        elif key == "vlanName":
            suggest = "vlan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchPortDhcpSnoopOption82Override. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchPortDhcpSnoopOption82Override.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchPortDhcpSnoopOption82Override.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 circuit_id: Optional[str] = None,
                 remote_id: Optional[str] = None,
                 vlan_name: Optional[str] = None):
        """
        :param str circuit_id: Circuit ID string.
        :param str remote_id: Remote ID string.
        :param str vlan_name: VLAN name.
        """
        if circuit_id is not None:
            pulumi.set(__self__, "circuit_id", circuit_id)
        if remote_id is not None:
            pulumi.set(__self__, "remote_id", remote_id)
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @property
    @pulumi.getter(name="circuitId")
    def circuit_id(self) -> Optional[str]:
        """
        Circuit ID string.
        """
        return pulumi.get(self, "circuit_id")

    @property
    @pulumi.getter(name="remoteId")
    def remote_id(self) -> Optional[str]:
        """
        Remote ID string.
        """
        return pulumi.get(self, "remote_id")

    @property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[str]:
        """
        VLAN name.
        """
        return pulumi.get(self, "vlan_name")


@pulumi.output_type
class ManagedswitchPortExportTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagName":
            suggest = "tag_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchPortExportTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchPortExportTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchPortExportTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_name: Optional[str] = None):
        """
        :param str tag_name: Switch tag name.
        """
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[str]:
        """
        Switch tag name.
        """
        return pulumi.get(self, "tag_name")


@pulumi.output_type
class ManagedswitchPortFortiswitchAcl(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None):
        """
        :param int id: ACL ID.
               
               The `dhcp_snoop_option82_override` block supports:
        """
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        ACL ID.

        The `dhcp_snoop_option82_override` block supports:
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class ManagedswitchPortInterfaceTag(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagName":
            suggest = "tag_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchPortInterfaceTag. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchPortInterfaceTag.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchPortInterfaceTag.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tag_name: Optional[str] = None):
        """
        :param str tag_name: FortiSwitch port tag name when exported to a virtual port pool or matched to dynamic port policy.
        """
        if tag_name is not None:
            pulumi.set(__self__, "tag_name", tag_name)

    @property
    @pulumi.getter(name="tagName")
    def tag_name(self) -> Optional[str]:
        """
        FortiSwitch port tag name when exported to a virtual port pool or matched to dynamic port policy.
        """
        return pulumi.get(self, "tag_name")


@pulumi.output_type
class ManagedswitchPortMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "memberName":
            suggest = "member_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchPortMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchPortMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchPortMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 member_name: Optional[str] = None):
        """
        :param str member_name: Interface name from available options.
        """
        if member_name is not None:
            pulumi.set(__self__, "member_name", member_name)

    @property
    @pulumi.getter(name="memberName")
    def member_name(self) -> Optional[str]:
        """
        Interface name from available options.
        """
        return pulumi.get(self, "member_name")


@pulumi.output_type
class ManagedswitchPortUntaggedVlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanName":
            suggest = "vlan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchPortUntaggedVlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchPortUntaggedVlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchPortUntaggedVlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vlan_name: Optional[str] = None):
        """
        :param str vlan_name: VLAN name.
        """
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[str]:
        """
        VLAN name.
        """
        return pulumi.get(self, "vlan_name")


@pulumi.output_type
class ManagedswitchRemoteLog(dict):
    def __init__(__self__, *,
                 csv: Optional[str] = None,
                 facility: Optional[str] = None,
                 name: Optional[str] = None,
                 port: Optional[int] = None,
                 server: Optional[str] = None,
                 severity: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str csv: Enable/disable comma-separated value (CSV) strings. Valid values: `enable`, `disable`.
        :param str facility: Facility to log to remote syslog server. Valid values: `kernel`, `user`, `mail`, `daemon`, `auth`, `syslog`, `lpr`, `news`, `uucp`, `cron`, `authpriv`, `ftp`, `ntp`, `audit`, `alert`, `clock`, `local0`, `local1`, `local2`, `local3`, `local4`, `local5`, `local6`, `local7`.
        :param str name: Remote log name.
        :param int port: Remote syslog server listening port.
        :param str server: IPv4 address of the remote syslog server.
        :param str severity: Severity of logs to be transferred to remote log server. Valid values: `emergency`, `alert`, `critical`, `error`, `warning`, `notification`, `information`, `debug`.
        :param str status: Enable/disable logging by FortiSwitch device to a remote syslog server. Valid values: `enable`, `disable`.
        """
        if csv is not None:
            pulumi.set(__self__, "csv", csv)
        if facility is not None:
            pulumi.set(__self__, "facility", facility)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if server is not None:
            pulumi.set(__self__, "server", server)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def csv(self) -> Optional[str]:
        """
        Enable/disable comma-separated value (CSV) strings. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "csv")

    @property
    @pulumi.getter
    def facility(self) -> Optional[str]:
        """
        Facility to log to remote syslog server. Valid values: `kernel`, `user`, `mail`, `daemon`, `auth`, `syslog`, `lpr`, `news`, `uucp`, `cron`, `authpriv`, `ftp`, `ntp`, `audit`, `alert`, `clock`, `local0`, `local1`, `local2`, `local3`, `local4`, `local5`, `local6`, `local7`.
        """
        return pulumi.get(self, "facility")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Remote log name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def port(self) -> Optional[int]:
        """
        Remote syslog server listening port.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def server(self) -> Optional[str]:
        """
        IPv4 address of the remote syslog server.
        """
        return pulumi.get(self, "server")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        Severity of logs to be transferred to remote log server. Valid values: `emergency`, `alert`, `critical`, `error`, `warning`, `notification`, `information`, `debug`.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable logging by FortiSwitch device to a remote syslog server. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ManagedswitchRouteOffloadRouter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "routerIp":
            suggest = "router_ip"
        elif key == "vlanName":
            suggest = "vlan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchRouteOffloadRouter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchRouteOffloadRouter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchRouteOffloadRouter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 router_ip: Optional[str] = None,
                 vlan_name: Optional[str] = None):
        """
        :param str router_ip: Router IP address.
        :param str vlan_name: VLAN name.
        """
        if router_ip is not None:
            pulumi.set(__self__, "router_ip", router_ip)
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @property
    @pulumi.getter(name="routerIp")
    def router_ip(self) -> Optional[str]:
        """
        Router IP address.
        """
        return pulumi.get(self, "router_ip")

    @property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[str]:
        """
        VLAN name.
        """
        return pulumi.get(self, "vlan_name")


@pulumi.output_type
class ManagedswitchSnmpCommunity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryV1Port":
            suggest = "query_v1_port"
        elif key == "queryV1Status":
            suggest = "query_v1_status"
        elif key == "queryV2cPort":
            suggest = "query_v2c_port"
        elif key == "queryV2cStatus":
            suggest = "query_v2c_status"
        elif key == "trapV1Lport":
            suggest = "trap_v1_lport"
        elif key == "trapV1Rport":
            suggest = "trap_v1_rport"
        elif key == "trapV1Status":
            suggest = "trap_v1_status"
        elif key == "trapV2cLport":
            suggest = "trap_v2c_lport"
        elif key == "trapV2cRport":
            suggest = "trap_v2c_rport"
        elif key == "trapV2cStatus":
            suggest = "trap_v2c_status"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchSnmpCommunity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchSnmpCommunity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchSnmpCommunity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 events: Optional[str] = None,
                 hosts: Optional[Sequence['outputs.ManagedswitchSnmpCommunityHost']] = None,
                 id: Optional[int] = None,
                 name: Optional[str] = None,
                 query_v1_port: Optional[int] = None,
                 query_v1_status: Optional[str] = None,
                 query_v2c_port: Optional[int] = None,
                 query_v2c_status: Optional[str] = None,
                 status: Optional[str] = None,
                 trap_v1_lport: Optional[int] = None,
                 trap_v1_rport: Optional[int] = None,
                 trap_v1_status: Optional[str] = None,
                 trap_v2c_lport: Optional[int] = None,
                 trap_v2c_rport: Optional[int] = None,
                 trap_v2c_status: Optional[str] = None):
        """
        :param str events: SNMP notifications (traps) to send. Valid values: `cpu-high`, `mem-low`, `log-full`, `intf-ip`, `ent-conf-change`.
        :param Sequence['ManagedswitchSnmpCommunityHostArgs'] hosts: Configure IPv4 SNMP managers (hosts). The structure of `hosts` block is documented below.
        :param int id: SNMP community ID.
        :param str name: SNMP community name.
        :param int query_v1_port: SNMP v1 query port (default = 161).
        :param str query_v1_status: Enable/disable SNMP v1 queries. Valid values: `disable`, `enable`.
        :param int query_v2c_port: SNMP v2c query port (default = 161).
        :param str query_v2c_status: Enable/disable SNMP v2c queries. Valid values: `disable`, `enable`.
        :param str status: Enable/disable this SNMP community. Valid values: `disable`, `enable`.
        :param int trap_v1_lport: SNMP v2c trap local port (default = 162).
        :param int trap_v1_rport: SNMP v2c trap remote port (default = 162).
        :param str trap_v1_status: Enable/disable SNMP v1 traps. Valid values: `disable`, `enable`.
        :param int trap_v2c_lport: SNMP v2c trap local port (default = 162).
        :param int trap_v2c_rport: SNMP v2c trap remote port (default = 162).
        :param str trap_v2c_status: Enable/disable SNMP v2c traps. Valid values: `disable`, `enable`.
        """
        if events is not None:
            pulumi.set(__self__, "events", events)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if query_v1_port is not None:
            pulumi.set(__self__, "query_v1_port", query_v1_port)
        if query_v1_status is not None:
            pulumi.set(__self__, "query_v1_status", query_v1_status)
        if query_v2c_port is not None:
            pulumi.set(__self__, "query_v2c_port", query_v2c_port)
        if query_v2c_status is not None:
            pulumi.set(__self__, "query_v2c_status", query_v2c_status)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if trap_v1_lport is not None:
            pulumi.set(__self__, "trap_v1_lport", trap_v1_lport)
        if trap_v1_rport is not None:
            pulumi.set(__self__, "trap_v1_rport", trap_v1_rport)
        if trap_v1_status is not None:
            pulumi.set(__self__, "trap_v1_status", trap_v1_status)
        if trap_v2c_lport is not None:
            pulumi.set(__self__, "trap_v2c_lport", trap_v2c_lport)
        if trap_v2c_rport is not None:
            pulumi.set(__self__, "trap_v2c_rport", trap_v2c_rport)
        if trap_v2c_status is not None:
            pulumi.set(__self__, "trap_v2c_status", trap_v2c_status)

    @property
    @pulumi.getter
    def events(self) -> Optional[str]:
        """
        SNMP notifications (traps) to send. Valid values: `cpu-high`, `mem-low`, `log-full`, `intf-ip`, `ent-conf-change`.
        """
        return pulumi.get(self, "events")

    @property
    @pulumi.getter
    def hosts(self) -> Optional[Sequence['outputs.ManagedswitchSnmpCommunityHost']]:
        """
        Configure IPv4 SNMP managers (hosts). The structure of `hosts` block is documented below.
        """
        return pulumi.get(self, "hosts")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        SNMP community ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        SNMP community name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="queryV1Port")
    def query_v1_port(self) -> Optional[int]:
        """
        SNMP v1 query port (default = 161).
        """
        return pulumi.get(self, "query_v1_port")

    @property
    @pulumi.getter(name="queryV1Status")
    def query_v1_status(self) -> Optional[str]:
        """
        Enable/disable SNMP v1 queries. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "query_v1_status")

    @property
    @pulumi.getter(name="queryV2cPort")
    def query_v2c_port(self) -> Optional[int]:
        """
        SNMP v2c query port (default = 161).
        """
        return pulumi.get(self, "query_v2c_port")

    @property
    @pulumi.getter(name="queryV2cStatus")
    def query_v2c_status(self) -> Optional[str]:
        """
        Enable/disable SNMP v2c queries. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "query_v2c_status")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable this SNMP community. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "status")

    @property
    @pulumi.getter(name="trapV1Lport")
    def trap_v1_lport(self) -> Optional[int]:
        """
        SNMP v2c trap local port (default = 162).
        """
        return pulumi.get(self, "trap_v1_lport")

    @property
    @pulumi.getter(name="trapV1Rport")
    def trap_v1_rport(self) -> Optional[int]:
        """
        SNMP v2c trap remote port (default = 162).
        """
        return pulumi.get(self, "trap_v1_rport")

    @property
    @pulumi.getter(name="trapV1Status")
    def trap_v1_status(self) -> Optional[str]:
        """
        Enable/disable SNMP v1 traps. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "trap_v1_status")

    @property
    @pulumi.getter(name="trapV2cLport")
    def trap_v2c_lport(self) -> Optional[int]:
        """
        SNMP v2c trap local port (default = 162).
        """
        return pulumi.get(self, "trap_v2c_lport")

    @property
    @pulumi.getter(name="trapV2cRport")
    def trap_v2c_rport(self) -> Optional[int]:
        """
        SNMP v2c trap remote port (default = 162).
        """
        return pulumi.get(self, "trap_v2c_rport")

    @property
    @pulumi.getter(name="trapV2cStatus")
    def trap_v2c_status(self) -> Optional[str]:
        """
        Enable/disable SNMP v2c traps. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "trap_v2c_status")


@pulumi.output_type
class ManagedswitchSnmpCommunityHost(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None,
                 ip: Optional[str] = None):
        """
        :param int id: Host entry ID.
        :param str ip: IPv4 address of the SNMP manager (host).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Host entry ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address of the SNMP manager (host).
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class ManagedswitchSnmpSysinfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contactInfo":
            suggest = "contact_info"
        elif key == "engineId":
            suggest = "engine_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchSnmpSysinfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchSnmpSysinfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchSnmpSysinfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 contact_info: Optional[str] = None,
                 description: Optional[str] = None,
                 engine_id: Optional[str] = None,
                 location: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str contact_info: Contact information.
        :param str description: System description.
        :param str engine_id: Local SNMP engine ID string (max 24 char).
        :param str location: System location.
        :param str status: Enable/disable SNMP. Valid values: `disable`, `enable`.
        """
        if contact_info is not None:
            pulumi.set(__self__, "contact_info", contact_info)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if engine_id is not None:
            pulumi.set(__self__, "engine_id", engine_id)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="contactInfo")
    def contact_info(self) -> Optional[str]:
        """
        Contact information.
        """
        return pulumi.get(self, "contact_info")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        System description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="engineId")
    def engine_id(self) -> Optional[str]:
        """
        Local SNMP engine ID string (max 24 char).
        """
        return pulumi.get(self, "engine_id")

    @property
    @pulumi.getter
    def location(self) -> Optional[str]:
        """
        System location.
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable SNMP. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ManagedswitchSnmpTrapThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "trapHighCpuThreshold":
            suggest = "trap_high_cpu_threshold"
        elif key == "trapLogFullThreshold":
            suggest = "trap_log_full_threshold"
        elif key == "trapLowMemoryThreshold":
            suggest = "trap_low_memory_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchSnmpTrapThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchSnmpTrapThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchSnmpTrapThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 trap_high_cpu_threshold: Optional[int] = None,
                 trap_log_full_threshold: Optional[int] = None,
                 trap_low_memory_threshold: Optional[int] = None):
        """
        :param int trap_high_cpu_threshold: CPU usage when trap is sent.
        :param int trap_log_full_threshold: Log disk usage when trap is sent.
        :param int trap_low_memory_threshold: Memory usage when trap is sent.
        """
        if trap_high_cpu_threshold is not None:
            pulumi.set(__self__, "trap_high_cpu_threshold", trap_high_cpu_threshold)
        if trap_log_full_threshold is not None:
            pulumi.set(__self__, "trap_log_full_threshold", trap_log_full_threshold)
        if trap_low_memory_threshold is not None:
            pulumi.set(__self__, "trap_low_memory_threshold", trap_low_memory_threshold)

    @property
    @pulumi.getter(name="trapHighCpuThreshold")
    def trap_high_cpu_threshold(self) -> Optional[int]:
        """
        CPU usage when trap is sent.
        """
        return pulumi.get(self, "trap_high_cpu_threshold")

    @property
    @pulumi.getter(name="trapLogFullThreshold")
    def trap_log_full_threshold(self) -> Optional[int]:
        """
        Log disk usage when trap is sent.
        """
        return pulumi.get(self, "trap_log_full_threshold")

    @property
    @pulumi.getter(name="trapLowMemoryThreshold")
    def trap_low_memory_threshold(self) -> Optional[int]:
        """
        Memory usage when trap is sent.
        """
        return pulumi.get(self, "trap_low_memory_threshold")


@pulumi.output_type
class ManagedswitchSnmpUser(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authProto":
            suggest = "auth_proto"
        elif key == "authPwd":
            suggest = "auth_pwd"
        elif key == "privProto":
            suggest = "priv_proto"
        elif key == "privPwd":
            suggest = "priv_pwd"
        elif key == "queryPort":
            suggest = "query_port"
        elif key == "securityLevel":
            suggest = "security_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchSnmpUser. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchSnmpUser.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchSnmpUser.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_proto: Optional[str] = None,
                 auth_pwd: Optional[str] = None,
                 name: Optional[str] = None,
                 priv_proto: Optional[str] = None,
                 priv_pwd: Optional[str] = None,
                 queries: Optional[str] = None,
                 query_port: Optional[int] = None,
                 security_level: Optional[str] = None):
        """
        :param str auth_proto: Authentication protocol.
        :param str auth_pwd: Password for authentication protocol.
        :param str name: SNMP user name.
        :param str priv_proto: Privacy (encryption) protocol.
        :param str priv_pwd: Password for privacy (encryption) protocol.
        :param str queries: Enable/disable SNMP queries for this user. Valid values: `disable`, `enable`.
        :param int query_port: SNMPv3 query port (default = 161).
        :param str security_level: Security level for message authentication and encryption. Valid values: `no-auth-no-priv`, `auth-no-priv`, `auth-priv`.
        """
        if auth_proto is not None:
            pulumi.set(__self__, "auth_proto", auth_proto)
        if auth_pwd is not None:
            pulumi.set(__self__, "auth_pwd", auth_pwd)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priv_proto is not None:
            pulumi.set(__self__, "priv_proto", priv_proto)
        if priv_pwd is not None:
            pulumi.set(__self__, "priv_pwd", priv_pwd)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if query_port is not None:
            pulumi.set(__self__, "query_port", query_port)
        if security_level is not None:
            pulumi.set(__self__, "security_level", security_level)

    @property
    @pulumi.getter(name="authProto")
    def auth_proto(self) -> Optional[str]:
        """
        Authentication protocol.
        """
        return pulumi.get(self, "auth_proto")

    @property
    @pulumi.getter(name="authPwd")
    def auth_pwd(self) -> Optional[str]:
        """
        Password for authentication protocol.
        """
        return pulumi.get(self, "auth_pwd")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        SNMP user name.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="privProto")
    def priv_proto(self) -> Optional[str]:
        """
        Privacy (encryption) protocol.
        """
        return pulumi.get(self, "priv_proto")

    @property
    @pulumi.getter(name="privPwd")
    def priv_pwd(self) -> Optional[str]:
        """
        Password for privacy (encryption) protocol.
        """
        return pulumi.get(self, "priv_pwd")

    @property
    @pulumi.getter
    def queries(self) -> Optional[str]:
        """
        Enable/disable SNMP queries for this user. Valid values: `disable`, `enable`.
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="queryPort")
    def query_port(self) -> Optional[int]:
        """
        SNMPv3 query port (default = 161).
        """
        return pulumi.get(self, "query_port")

    @property
    @pulumi.getter(name="securityLevel")
    def security_level(self) -> Optional[str]:
        """
        Security level for message authentication and encryption. Valid values: `no-auth-no-priv`, `auth-no-priv`, `auth-priv`.
        """
        return pulumi.get(self, "security_level")


@pulumi.output_type
class ManagedswitchStaticMac(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 id: Optional[int] = None,
                 interface: Optional[str] = None,
                 mac: Optional[str] = None,
                 type: Optional[str] = None,
                 vlan: Optional[str] = None):
        """
        :param str description: Description.
        :param int id: Id
        :param str interface: Interface name.
        :param str mac: MAC address.
        :param str type: Type. Valid values: `static`, `sticky`.
        :param str vlan: Vlan.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if interface is not None:
            pulumi.set(__self__, "interface", interface)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vlan is not None:
            pulumi.set(__self__, "vlan", vlan)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Id
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def interface(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "interface")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        """
        MAC address.
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type. Valid values: `static`, `sticky`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def vlan(self) -> Optional[str]:
        """
        Vlan.
        """
        return pulumi.get(self, "vlan")


@pulumi.output_type
class ManagedswitchStormControl(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localOverride":
            suggest = "local_override"
        elif key == "unknownMulticast":
            suggest = "unknown_multicast"
        elif key == "unknownUnicast":
            suggest = "unknown_unicast"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchStormControl. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchStormControl.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchStormControl.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 broadcast: Optional[str] = None,
                 local_override: Optional[str] = None,
                 rate: Optional[int] = None,
                 unknown_multicast: Optional[str] = None,
                 unknown_unicast: Optional[str] = None):
        """
        :param str broadcast: Enable/disable storm control to drop broadcast traffic. Valid values: `enable`, `disable`.
        :param str local_override: Enable to override global FortiSwitch storm control settings for this FortiSwitch. Valid values: `enable`, `disable`.
        :param int rate: Rate in packets per second at which storm traffic is controlled (1 - 10000000, default = 500). Storm control drops excess traffic data rates beyond this threshold.
        :param str unknown_multicast: Enable/disable storm control to drop unknown multicast traffic. Valid values: `enable`, `disable`.
        :param str unknown_unicast: Enable/disable storm control to drop unknown unicast traffic. Valid values: `enable`, `disable`.
        """
        if broadcast is not None:
            pulumi.set(__self__, "broadcast", broadcast)
        if local_override is not None:
            pulumi.set(__self__, "local_override", local_override)
        if rate is not None:
            pulumi.set(__self__, "rate", rate)
        if unknown_multicast is not None:
            pulumi.set(__self__, "unknown_multicast", unknown_multicast)
        if unknown_unicast is not None:
            pulumi.set(__self__, "unknown_unicast", unknown_unicast)

    @property
    @pulumi.getter
    def broadcast(self) -> Optional[str]:
        """
        Enable/disable storm control to drop broadcast traffic. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "broadcast")

    @property
    @pulumi.getter(name="localOverride")
    def local_override(self) -> Optional[str]:
        """
        Enable to override global FortiSwitch storm control settings for this FortiSwitch. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "local_override")

    @property
    @pulumi.getter
    def rate(self) -> Optional[int]:
        """
        Rate in packets per second at which storm traffic is controlled (1 - 10000000, default = 500). Storm control drops excess traffic data rates beyond this threshold.
        """
        return pulumi.get(self, "rate")

    @property
    @pulumi.getter(name="unknownMulticast")
    def unknown_multicast(self) -> Optional[str]:
        """
        Enable/disable storm control to drop unknown multicast traffic. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "unknown_multicast")

    @property
    @pulumi.getter(name="unknownUnicast")
    def unknown_unicast(self) -> Optional[str]:
        """
        Enable/disable storm control to drop unknown unicast traffic. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "unknown_unicast")


@pulumi.output_type
class ManagedswitchStpInstance(dict):
    def __init__(__self__, *,
                 id: Optional[str] = None,
                 priority: Optional[str] = None):
        """
        :param str id: Instance ID.
        :param str priority: Priority. Valid values: `0`, `4096`, `8192`, `12288`, `16384`, `20480`, `24576`, `28672`, `32768`, `36864`, `40960`, `45056`, `49152`, `53248`, `57344`, `61440`.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        Instance ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def priority(self) -> Optional[str]:
        """
        Priority. Valid values: `0`, `4096`, `8192`, `12288`, `16384`, `20480`, `24576`, `28672`, `32768`, `36864`, `40960`, `45056`, `49152`, `53248`, `57344`, `61440`.
        """
        return pulumi.get(self, "priority")


@pulumi.output_type
class ManagedswitchStpSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "forwardTime":
            suggest = "forward_time"
        elif key == "helloTime":
            suggest = "hello_time"
        elif key == "localOverride":
            suggest = "local_override"
        elif key == "maxAge":
            suggest = "max_age"
        elif key == "maxHops":
            suggest = "max_hops"
        elif key == "pendingTimer":
            suggest = "pending_timer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchStpSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchStpSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchStpSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 forward_time: Optional[int] = None,
                 hello_time: Optional[int] = None,
                 local_override: Optional[str] = None,
                 max_age: Optional[int] = None,
                 max_hops: Optional[int] = None,
                 name: Optional[str] = None,
                 pending_timer: Optional[int] = None,
                 revision: Optional[int] = None,
                 status: Optional[str] = None):
        """
        :param int forward_time: Period of time a port is in listening and learning state (4 - 30 sec, default = 15).
        :param int hello_time: Period of time between successive STP frame Bridge Protocol Data Units (BPDUs) sent on a port (1 - 10 sec, default = 2).
        :param str local_override: Enable to configure local STP settings that override global STP settings. Valid values: `enable`, `disable`.
        :param int max_age: Maximum time before a bridge port saves its configuration BPDU information (6 - 40 sec, default = 20).
        :param int max_hops: Maximum number of hops between the root bridge and the furthest bridge (1- 40, default = 20).
        :param str name: Name of local STP settings configuration.
        :param int pending_timer: Pending time (1 - 15 sec, default = 4).
        :param int revision: STP revision number (0 - 65535).
        :param str status: Enable/disable STP. Valid values: `enable`, `disable`.
        """
        if forward_time is not None:
            pulumi.set(__self__, "forward_time", forward_time)
        if hello_time is not None:
            pulumi.set(__self__, "hello_time", hello_time)
        if local_override is not None:
            pulumi.set(__self__, "local_override", local_override)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)
        if max_hops is not None:
            pulumi.set(__self__, "max_hops", max_hops)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if pending_timer is not None:
            pulumi.set(__self__, "pending_timer", pending_timer)
        if revision is not None:
            pulumi.set(__self__, "revision", revision)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="forwardTime")
    def forward_time(self) -> Optional[int]:
        """
        Period of time a port is in listening and learning state (4 - 30 sec, default = 15).
        """
        return pulumi.get(self, "forward_time")

    @property
    @pulumi.getter(name="helloTime")
    def hello_time(self) -> Optional[int]:
        """
        Period of time between successive STP frame Bridge Protocol Data Units (BPDUs) sent on a port (1 - 10 sec, default = 2).
        """
        return pulumi.get(self, "hello_time")

    @property
    @pulumi.getter(name="localOverride")
    def local_override(self) -> Optional[str]:
        """
        Enable to configure local STP settings that override global STP settings. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "local_override")

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[int]:
        """
        Maximum time before a bridge port saves its configuration BPDU information (6 - 40 sec, default = 20).
        """
        return pulumi.get(self, "max_age")

    @property
    @pulumi.getter(name="maxHops")
    def max_hops(self) -> Optional[int]:
        """
        Maximum number of hops between the root bridge and the furthest bridge (1- 40, default = 20).
        """
        return pulumi.get(self, "max_hops")

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Name of local STP settings configuration.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="pendingTimer")
    def pending_timer(self) -> Optional[int]:
        """
        Pending time (1 - 15 sec, default = 4).
        """
        return pulumi.get(self, "pending_timer")

    @property
    @pulumi.getter
    def revision(self) -> Optional[int]:
        """
        STP revision number (0 - 65535).
        """
        return pulumi.get(self, "revision")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable STP. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ManagedswitchSwitchLog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "localOverride":
            suggest = "local_override"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchSwitchLog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchSwitchLog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchSwitchLog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 local_override: Optional[str] = None,
                 severity: Optional[str] = None,
                 status: Optional[str] = None):
        """
        :param str local_override: Enable to configure local logging settings that override global logging settings. Valid values: `enable`, `disable`.
        :param str severity: Severity of FortiSwitch logs that are added to the FortiGate event log. Valid values: `emergency`, `alert`, `critical`, `error`, `warning`, `notification`, `information`, `debug`.
        :param str status: Enable/disable adding FortiSwitch logs to the FortiGate event log. Valid values: `enable`, `disable`.
        """
        if local_override is not None:
            pulumi.set(__self__, "local_override", local_override)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="localOverride")
    def local_override(self) -> Optional[str]:
        """
        Enable to configure local logging settings that override global logging settings. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "local_override")

    @property
    @pulumi.getter
    def severity(self) -> Optional[str]:
        """
        Severity of FortiSwitch logs that are added to the FortiGate event log. Valid values: `emergency`, `alert`, `critical`, `error`, `warning`, `notification`, `information`, `debug`.
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable adding FortiSwitch logs to the FortiGate event log. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ManagedswitchSwitchStpSettings(dict):
    def __init__(__self__, *,
                 status: Optional[str] = None):
        """
        :param str status: Enable/disable STP. Valid values: `enable`, `disable`.
        """
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def status(self) -> Optional[str]:
        """
        Enable/disable STP. Valid values: `enable`, `disable`.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class ManagedswitchVlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assignmentPriority":
            suggest = "assignment_priority"
        elif key == "vlanName":
            suggest = "vlan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ManagedswitchVlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ManagedswitchVlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ManagedswitchVlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 assignment_priority: Optional[int] = None,
                 vlan_name: Optional[str] = None):
        """
        :param int assignment_priority: 802.1x Radius (Tunnel-Private-Group-Id) VLANID assign-by-name priority. A smaller value has a higher priority.
        :param str vlan_name: VLAN name.
        """
        if assignment_priority is not None:
            pulumi.set(__self__, "assignment_priority", assignment_priority)
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @property
    @pulumi.getter(name="assignmentPriority")
    def assignment_priority(self) -> Optional[int]:
        """
        802.1x Radius (Tunnel-Private-Group-Id) VLANID assign-by-name priority. A smaller value has a higher priority.
        """
        return pulumi.get(self, "assignment_priority")

    @property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[str]:
        """
        VLAN name.
        """
        return pulumi.get(self, "vlan_name")


@pulumi.output_type
class QuarantineTarget(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryId":
            suggest = "entry_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in QuarantineTarget. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        QuarantineTarget.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        QuarantineTarget.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 entry_id: Optional[int] = None,
                 mac: Optional[str] = None,
                 tags: Optional[Sequence['outputs.QuarantineTargetTag']] = None):
        """
        :param str description: Description for the quarantine MAC.
        :param int entry_id: FSW entry id for the quarantine MAC.
        :param str mac: Quarantine MAC.
        :param Sequence['QuarantineTargetTagArgs'] tags: Tags for the quarantine MAC. The structure of `tag` block is documented below.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if entry_id is not None:
            pulumi.set(__self__, "entry_id", entry_id)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the quarantine MAC.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="entryId")
    def entry_id(self) -> Optional[int]:
        """
        FSW entry id for the quarantine MAC.
        """
        return pulumi.get(self, "entry_id")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        """
        Quarantine MAC.
        """
        return pulumi.get(self, "mac")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.QuarantineTargetTag']]:
        """
        Tags for the quarantine MAC. The structure of `tag` block is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class QuarantineTargetTag(dict):
    def __init__(__self__, *,
                 tags: Optional[str] = None):
        """
        :param str tags: Tag string(eg. string1 string2 string3).
        """
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def tags(self) -> Optional[str]:
        """
        Tag string(eg. string1 string2 string3).
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SnmpcommunityHost(dict):
    def __init__(__self__, *,
                 id: Optional[int] = None,
                 ip: Optional[str] = None):
        """
        :param int id: Host entry ID.
        :param str ip: IPv4 address of the SNMP manager (host).
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def id(self) -> Optional[int]:
        """
        Host entry ID.
        """
        return pulumi.get(self, "id")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IPv4 address of the SNMP manager (host).
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class StpinstanceVlanRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanName":
            suggest = "vlan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StpinstanceVlanRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StpinstanceVlanRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StpinstanceVlanRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vlan_name: Optional[str] = None):
        """
        :param str vlan_name: VLAN name.
        """
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[str]:
        """
        VLAN name.
        """
        return pulumi.get(self, "vlan_name")


@pulumi.output_type
class SwitchgroupMember(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "switchId":
            suggest = "switch_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SwitchgroupMember. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SwitchgroupMember.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SwitchgroupMember.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[str] = None,
                 switch_id: Optional[str] = None):
        """
        :param str name: Managed device ID.
        :param str switch_id: Managed device ID.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if switch_id is not None:
            pulumi.set(__self__, "switch_id", switch_id)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Managed device ID.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> Optional[str]:
        """
        Managed device ID.
        """
        return pulumi.get(self, "switch_id")


@pulumi.output_type
class TrafficsnifferTargetIp(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 ip: Optional[str] = None):
        """
        :param str description: Description for the sniffer IP.
        :param str ip: Sniffer IP.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the sniffer IP.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        Sniffer IP.
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class TrafficsnifferTargetMac(dict):
    def __init__(__self__, *,
                 description: Optional[str] = None,
                 mac: Optional[str] = None):
        """
        :param str description: Description for the sniffer MAC.
        :param str mac: Sniffer MAC.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if mac is not None:
            pulumi.set(__self__, "mac", mac)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the sniffer MAC.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def mac(self) -> Optional[str]:
        """
        Sniffer MAC.
        """
        return pulumi.get(self, "mac")


@pulumi.output_type
class TrafficsnifferTargetPort(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "inPorts":
            suggest = "in_ports"
        elif key == "outPorts":
            suggest = "out_ports"
        elif key == "switchId":
            suggest = "switch_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TrafficsnifferTargetPort. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TrafficsnifferTargetPort.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TrafficsnifferTargetPort.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[str] = None,
                 in_ports: Optional[Sequence['outputs.TrafficsnifferTargetPortInPort']] = None,
                 out_ports: Optional[Sequence['outputs.TrafficsnifferTargetPortOutPort']] = None,
                 switch_id: Optional[str] = None):
        """
        :param str description: Description for the sniffer port entry.
        :param Sequence['TrafficsnifferTargetPortInPortArgs'] in_ports: Configure source ingress port interfaces. The structure of `in_ports` block is documented below.
        :param Sequence['TrafficsnifferTargetPortOutPortArgs'] out_ports: Configure source egress port interfaces. The structure of `out_ports` block is documented below.
        :param str switch_id: Managed-switch ID.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if in_ports is not None:
            pulumi.set(__self__, "in_ports", in_ports)
        if out_ports is not None:
            pulumi.set(__self__, "out_ports", out_ports)
        if switch_id is not None:
            pulumi.set(__self__, "switch_id", switch_id)

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description for the sniffer port entry.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter(name="inPorts")
    def in_ports(self) -> Optional[Sequence['outputs.TrafficsnifferTargetPortInPort']]:
        """
        Configure source ingress port interfaces. The structure of `in_ports` block is documented below.
        """
        return pulumi.get(self, "in_ports")

    @property
    @pulumi.getter(name="outPorts")
    def out_ports(self) -> Optional[Sequence['outputs.TrafficsnifferTargetPortOutPort']]:
        """
        Configure source egress port interfaces. The structure of `out_ports` block is documented below.
        """
        return pulumi.get(self, "out_ports")

    @property
    @pulumi.getter(name="switchId")
    def switch_id(self) -> Optional[str]:
        """
        Managed-switch ID.
        """
        return pulumi.get(self, "switch_id")


@pulumi.output_type
class TrafficsnifferTargetPortInPort(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class TrafficsnifferTargetPortOutPort(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: Interface name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        Interface name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VlanPortalMessageOverrides(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authDisclaimerPage":
            suggest = "auth_disclaimer_page"
        elif key == "authLoginFailedPage":
            suggest = "auth_login_failed_page"
        elif key == "authLoginPage":
            suggest = "auth_login_page"
        elif key == "authRejectPage":
            suggest = "auth_reject_page"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VlanPortalMessageOverrides. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VlanPortalMessageOverrides.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VlanPortalMessageOverrides.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_disclaimer_page: Optional[str] = None,
                 auth_login_failed_page: Optional[str] = None,
                 auth_login_page: Optional[str] = None,
                 auth_reject_page: Optional[str] = None):
        """
        :param str auth_disclaimer_page: Override auth-disclaimer-page message with message from portal-message-overrides group.
        :param str auth_login_failed_page: Override auth-login-failed-page message with message from portal-message-overrides group.
        :param str auth_login_page: Override auth-login-page message with message from portal-message-overrides group.
        :param str auth_reject_page: Override auth-reject-page message with message from portal-message-overrides group.
        """
        if auth_disclaimer_page is not None:
            pulumi.set(__self__, "auth_disclaimer_page", auth_disclaimer_page)
        if auth_login_failed_page is not None:
            pulumi.set(__self__, "auth_login_failed_page", auth_login_failed_page)
        if auth_login_page is not None:
            pulumi.set(__self__, "auth_login_page", auth_login_page)
        if auth_reject_page is not None:
            pulumi.set(__self__, "auth_reject_page", auth_reject_page)

    @property
    @pulumi.getter(name="authDisclaimerPage")
    def auth_disclaimer_page(self) -> Optional[str]:
        """
        Override auth-disclaimer-page message with message from portal-message-overrides group.
        """
        return pulumi.get(self, "auth_disclaimer_page")

    @property
    @pulumi.getter(name="authLoginFailedPage")
    def auth_login_failed_page(self) -> Optional[str]:
        """
        Override auth-login-failed-page message with message from portal-message-overrides group.
        """
        return pulumi.get(self, "auth_login_failed_page")

    @property
    @pulumi.getter(name="authLoginPage")
    def auth_login_page(self) -> Optional[str]:
        """
        Override auth-login-page message with message from portal-message-overrides group.
        """
        return pulumi.get(self, "auth_login_page")

    @property
    @pulumi.getter(name="authRejectPage")
    def auth_reject_page(self) -> Optional[str]:
        """
        Override auth-reject-page message with message from portal-message-overrides group.
        """
        return pulumi.get(self, "auth_reject_page")


@pulumi.output_type
class VlanSelectedUsergroup(dict):
    def __init__(__self__, *,
                 name: Optional[str] = None):
        """
        :param str name: User group name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[str]:
        """
        User group name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class VlanpolicyAllowedVlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanName":
            suggest = "vlan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VlanpolicyAllowedVlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VlanpolicyAllowedVlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VlanpolicyAllowedVlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vlan_name: Optional[str] = None):
        """
        :param str vlan_name: VLAN name.
        """
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[str]:
        """
        VLAN name.
        """
        return pulumi.get(self, "vlan_name")


@pulumi.output_type
class VlanpolicyUntaggedVlan(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vlanName":
            suggest = "vlan_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VlanpolicyUntaggedVlan. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VlanpolicyUntaggedVlan.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VlanpolicyUntaggedVlan.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vlan_name: Optional[str] = None):
        """
        :param str vlan_name: VLAN name.
        """
        if vlan_name is not None:
            pulumi.set(__self__, "vlan_name", vlan_name)

    @property
    @pulumi.getter(name="vlanName")
    def vlan_name(self) -> Optional[str]:
        """
        VLAN name.
        """
        return pulumi.get(self, "vlan_name")


