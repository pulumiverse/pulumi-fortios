// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package schedule

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
	"github.com/pulumiverse/pulumi-fortios/sdk/go/fortios/internal"
)

// Recurring schedule configuration.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//	"github.com/pulumiverse/pulumi-fortios/sdk/go/fortios/firewall"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := firewall.NewRecurring(ctx, "trname", &firewall.RecurringArgs{
//				Color: pulumi.Int(0),
//				Day:   pulumi.String("sunday"),
//				End:   pulumi.String("00:00"),
//				Start: pulumi.String("00:00"),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// FirewallSchedule Recurring can be imported using any of these accepted formats:
//
// ```sh
// $ pulumi import fortios:firewall/schedule/recurring:Recurring labelname {{name}}
// ```
//
// If you do not want to import arguments of block:
//
// $ export "FORTIOS_IMPORT_TABLE"="false"
//
// ```sh
// $ pulumi import fortios:firewall/schedule/recurring:Recurring labelname {{name}}
// ```
//
// $ unset "FORTIOS_IMPORT_TABLE"
type Recurring struct {
	pulumi.CustomResourceState

	// Color of icon on the GUI.
	Color pulumi.IntOutput `pulumi:"color"`
	// One or more days of the week on which the schedule is valid. Separate the names of the days with a space. Valid values: `sunday`, `monday`, `tuesday`, `wednesday`, `thursday`, `friday`, `saturday`, `none`.
	Day pulumi.StringOutput `pulumi:"day"`
	// Time of day to end the schedule, format hh:mm.
	End pulumi.StringOutput `pulumi:"end"`
	// Security Fabric global object setting. Valid values: `enable`, `disable`.
	FabricObject pulumi.StringOutput `pulumi:"fabricObject"`
	// Recurring schedule name.
	Name pulumi.StringOutput `pulumi:"name"`
	// Time of day to start the schedule, format hh:mm.
	Start pulumi.StringOutput `pulumi:"start"`
	// Specifies the vdom to which the resource will be applied when the FortiGate unit is running in VDOM mode. Only one vdom can be specified. If you want to inherit the vdom configuration of the provider, please do not set this parameter.
	Vdomparam pulumi.StringOutput `pulumi:"vdomparam"`
}

// NewRecurring registers a new resource with the given unique name, arguments, and options.
func NewRecurring(ctx *pulumi.Context,
	name string, args *RecurringArgs, opts ...pulumi.ResourceOption) (*Recurring, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.End == nil {
		return nil, errors.New("invalid value for required argument 'End'")
	}
	if args.Start == nil {
		return nil, errors.New("invalid value for required argument 'Start'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource Recurring
	err := ctx.RegisterResource("fortios:firewall/schedule/recurring:Recurring", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetRecurring gets an existing Recurring resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetRecurring(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *RecurringState, opts ...pulumi.ResourceOption) (*Recurring, error) {
	var resource Recurring
	err := ctx.ReadResource("fortios:firewall/schedule/recurring:Recurring", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Recurring resources.
type recurringState struct {
	// Color of icon on the GUI.
	Color *int `pulumi:"color"`
	// One or more days of the week on which the schedule is valid. Separate the names of the days with a space. Valid values: `sunday`, `monday`, `tuesday`, `wednesday`, `thursday`, `friday`, `saturday`, `none`.
	Day *string `pulumi:"day"`
	// Time of day to end the schedule, format hh:mm.
	End *string `pulumi:"end"`
	// Security Fabric global object setting. Valid values: `enable`, `disable`.
	FabricObject *string `pulumi:"fabricObject"`
	// Recurring schedule name.
	Name *string `pulumi:"name"`
	// Time of day to start the schedule, format hh:mm.
	Start *string `pulumi:"start"`
	// Specifies the vdom to which the resource will be applied when the FortiGate unit is running in VDOM mode. Only one vdom can be specified. If you want to inherit the vdom configuration of the provider, please do not set this parameter.
	Vdomparam *string `pulumi:"vdomparam"`
}

type RecurringState struct {
	// Color of icon on the GUI.
	Color pulumi.IntPtrInput
	// One or more days of the week on which the schedule is valid. Separate the names of the days with a space. Valid values: `sunday`, `monday`, `tuesday`, `wednesday`, `thursday`, `friday`, `saturday`, `none`.
	Day pulumi.StringPtrInput
	// Time of day to end the schedule, format hh:mm.
	End pulumi.StringPtrInput
	// Security Fabric global object setting. Valid values: `enable`, `disable`.
	FabricObject pulumi.StringPtrInput
	// Recurring schedule name.
	Name pulumi.StringPtrInput
	// Time of day to start the schedule, format hh:mm.
	Start pulumi.StringPtrInput
	// Specifies the vdom to which the resource will be applied when the FortiGate unit is running in VDOM mode. Only one vdom can be specified. If you want to inherit the vdom configuration of the provider, please do not set this parameter.
	Vdomparam pulumi.StringPtrInput
}

func (RecurringState) ElementType() reflect.Type {
	return reflect.TypeOf((*recurringState)(nil)).Elem()
}

type recurringArgs struct {
	// Color of icon on the GUI.
	Color *int `pulumi:"color"`
	// One or more days of the week on which the schedule is valid. Separate the names of the days with a space. Valid values: `sunday`, `monday`, `tuesday`, `wednesday`, `thursday`, `friday`, `saturday`, `none`.
	Day *string `pulumi:"day"`
	// Time of day to end the schedule, format hh:mm.
	End string `pulumi:"end"`
	// Security Fabric global object setting. Valid values: `enable`, `disable`.
	FabricObject *string `pulumi:"fabricObject"`
	// Recurring schedule name.
	Name *string `pulumi:"name"`
	// Time of day to start the schedule, format hh:mm.
	Start string `pulumi:"start"`
	// Specifies the vdom to which the resource will be applied when the FortiGate unit is running in VDOM mode. Only one vdom can be specified. If you want to inherit the vdom configuration of the provider, please do not set this parameter.
	Vdomparam *string `pulumi:"vdomparam"`
}

// The set of arguments for constructing a Recurring resource.
type RecurringArgs struct {
	// Color of icon on the GUI.
	Color pulumi.IntPtrInput
	// One or more days of the week on which the schedule is valid. Separate the names of the days with a space. Valid values: `sunday`, `monday`, `tuesday`, `wednesday`, `thursday`, `friday`, `saturday`, `none`.
	Day pulumi.StringPtrInput
	// Time of day to end the schedule, format hh:mm.
	End pulumi.StringInput
	// Security Fabric global object setting. Valid values: `enable`, `disable`.
	FabricObject pulumi.StringPtrInput
	// Recurring schedule name.
	Name pulumi.StringPtrInput
	// Time of day to start the schedule, format hh:mm.
	Start pulumi.StringInput
	// Specifies the vdom to which the resource will be applied when the FortiGate unit is running in VDOM mode. Only one vdom can be specified. If you want to inherit the vdom configuration of the provider, please do not set this parameter.
	Vdomparam pulumi.StringPtrInput
}

func (RecurringArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*recurringArgs)(nil)).Elem()
}

type RecurringInput interface {
	pulumi.Input

	ToRecurringOutput() RecurringOutput
	ToRecurringOutputWithContext(ctx context.Context) RecurringOutput
}

func (*Recurring) ElementType() reflect.Type {
	return reflect.TypeOf((**Recurring)(nil)).Elem()
}

func (i *Recurring) ToRecurringOutput() RecurringOutput {
	return i.ToRecurringOutputWithContext(context.Background())
}

func (i *Recurring) ToRecurringOutputWithContext(ctx context.Context) RecurringOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurringOutput)
}

// RecurringArrayInput is an input type that accepts RecurringArray and RecurringArrayOutput values.
// You can construct a concrete instance of `RecurringArrayInput` via:
//
//	RecurringArray{ RecurringArgs{...} }
type RecurringArrayInput interface {
	pulumi.Input

	ToRecurringArrayOutput() RecurringArrayOutput
	ToRecurringArrayOutputWithContext(context.Context) RecurringArrayOutput
}

type RecurringArray []RecurringInput

func (RecurringArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Recurring)(nil)).Elem()
}

func (i RecurringArray) ToRecurringArrayOutput() RecurringArrayOutput {
	return i.ToRecurringArrayOutputWithContext(context.Background())
}

func (i RecurringArray) ToRecurringArrayOutputWithContext(ctx context.Context) RecurringArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurringArrayOutput)
}

// RecurringMapInput is an input type that accepts RecurringMap and RecurringMapOutput values.
// You can construct a concrete instance of `RecurringMapInput` via:
//
//	RecurringMap{ "key": RecurringArgs{...} }
type RecurringMapInput interface {
	pulumi.Input

	ToRecurringMapOutput() RecurringMapOutput
	ToRecurringMapOutputWithContext(context.Context) RecurringMapOutput
}

type RecurringMap map[string]RecurringInput

func (RecurringMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Recurring)(nil)).Elem()
}

func (i RecurringMap) ToRecurringMapOutput() RecurringMapOutput {
	return i.ToRecurringMapOutputWithContext(context.Background())
}

func (i RecurringMap) ToRecurringMapOutputWithContext(ctx context.Context) RecurringMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(RecurringMapOutput)
}

type RecurringOutput struct{ *pulumi.OutputState }

func (RecurringOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Recurring)(nil)).Elem()
}

func (o RecurringOutput) ToRecurringOutput() RecurringOutput {
	return o
}

func (o RecurringOutput) ToRecurringOutputWithContext(ctx context.Context) RecurringOutput {
	return o
}

// Color of icon on the GUI.
func (o RecurringOutput) Color() pulumi.IntOutput {
	return o.ApplyT(func(v *Recurring) pulumi.IntOutput { return v.Color }).(pulumi.IntOutput)
}

// One or more days of the week on which the schedule is valid. Separate the names of the days with a space. Valid values: `sunday`, `monday`, `tuesday`, `wednesday`, `thursday`, `friday`, `saturday`, `none`.
func (o RecurringOutput) Day() pulumi.StringOutput {
	return o.ApplyT(func(v *Recurring) pulumi.StringOutput { return v.Day }).(pulumi.StringOutput)
}

// Time of day to end the schedule, format hh:mm.
func (o RecurringOutput) End() pulumi.StringOutput {
	return o.ApplyT(func(v *Recurring) pulumi.StringOutput { return v.End }).(pulumi.StringOutput)
}

// Security Fabric global object setting. Valid values: `enable`, `disable`.
func (o RecurringOutput) FabricObject() pulumi.StringOutput {
	return o.ApplyT(func(v *Recurring) pulumi.StringOutput { return v.FabricObject }).(pulumi.StringOutput)
}

// Recurring schedule name.
func (o RecurringOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Recurring) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Time of day to start the schedule, format hh:mm.
func (o RecurringOutput) Start() pulumi.StringOutput {
	return o.ApplyT(func(v *Recurring) pulumi.StringOutput { return v.Start }).(pulumi.StringOutput)
}

// Specifies the vdom to which the resource will be applied when the FortiGate unit is running in VDOM mode. Only one vdom can be specified. If you want to inherit the vdom configuration of the provider, please do not set this parameter.
func (o RecurringOutput) Vdomparam() pulumi.StringOutput {
	return o.ApplyT(func(v *Recurring) pulumi.StringOutput { return v.Vdomparam }).(pulumi.StringOutput)
}

type RecurringArrayOutput struct{ *pulumi.OutputState }

func (RecurringArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Recurring)(nil)).Elem()
}

func (o RecurringArrayOutput) ToRecurringArrayOutput() RecurringArrayOutput {
	return o
}

func (o RecurringArrayOutput) ToRecurringArrayOutputWithContext(ctx context.Context) RecurringArrayOutput {
	return o
}

func (o RecurringArrayOutput) Index(i pulumi.IntInput) RecurringOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Recurring {
		return vs[0].([]*Recurring)[vs[1].(int)]
	}).(RecurringOutput)
}

type RecurringMapOutput struct{ *pulumi.OutputState }

func (RecurringMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Recurring)(nil)).Elem()
}

func (o RecurringMapOutput) ToRecurringMapOutput() RecurringMapOutput {
	return o
}

func (o RecurringMapOutput) ToRecurringMapOutputWithContext(ctx context.Context) RecurringMapOutput {
	return o
}

func (o RecurringMapOutput) MapIndex(k pulumi.StringInput) RecurringOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Recurring {
		return vs[0].(map[string]*Recurring)[vs[1].(string)]
	}).(RecurringOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*RecurringInput)(nil)).Elem(), &Recurring{})
	pulumi.RegisterInputType(reflect.TypeOf((*RecurringArrayInput)(nil)).Elem(), RecurringArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*RecurringMapInput)(nil)).Elem(), RecurringMap{})
	pulumi.RegisterOutputType(RecurringOutput{})
	pulumi.RegisterOutputType(RecurringArrayOutput{})
	pulumi.RegisterOutputType(RecurringMapOutput{})
}
