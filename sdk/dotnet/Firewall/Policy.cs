// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Pulumi;

namespace Pulumiverse.Fortios.Firewall
{
    /// <summary>
    /// Configure IPv4 policies.
    /// 
    /// ## Example Usage
    /// 
    /// &lt;!--Start PulumiCodeChooser --&gt;
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Fortios = Pulumiverse.Fortios;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var trname = new Fortios.Firewall.Policy("trname", new()
    ///     {
    ///         Action = "accept",
    ///         Dstaddrs = new[]
    ///         {
    ///             new Fortios.Firewall.Inputs.PolicyDstaddrArgs
    ///             {
    ///                 Name = "all",
    ///             },
    ///         },
    ///         Dstintfs = new[]
    ///         {
    ///             new Fortios.Firewall.Inputs.PolicyDstintfArgs
    ///             {
    ///                 Name = "port4",
    ///             },
    ///         },
    ///         Logtraffic = "utm",
    ///         Policyid = 1,
    ///         Schedule = "always",
    ///         Services = new[]
    ///         {
    ///             new Fortios.Firewall.Inputs.PolicyServiceArgs
    ///             {
    ///                 Name = "HTTP",
    ///             },
    ///         },
    ///         Srcaddrs = new[]
    ///         {
    ///             new Fortios.Firewall.Inputs.PolicySrcaddrArgs
    ///             {
    ///                 Name = "all",
    ///             },
    ///         },
    ///         Srcintfs = new[]
    ///         {
    ///             new Fortios.Firewall.Inputs.PolicySrcintfArgs
    ///             {
    ///                 Name = "port3",
    ///             },
    ///         },
    ///         Wanopt = "disable",
    ///         WanoptDetection = "active",
    ///         WanoptPassiveOpt = "default",
    ///         Wccp = "disable",
    ///         Webcache = "disable",
    ///         WebcacheHttps = "disable",
    ///         Wsso = "enable",
    ///     });
    /// 
    ///     var myrule = new Fortios.Firewall.Policy("myrule", new()
    ///     {
    ///         Action = "accept",
    ///         AntiReplay = "enable",
    ///         AuthPath = "disable",
    ///         AutoAsicOffload = "enable",
    ///         AvProfile = "wifi-default",
    ///         Dstintfs = new[]
    ///         {
    ///             new Fortios.Firewall.Inputs.PolicyDstintfArgs
    ///             {
    ///                 Name = "port1",
    ///             },
    ///         },
    ///         InspectionMode = "flow",
    ///         InternetService = "enable",
    ///         InternetServiceNames = new[]
    ///         {
    ///             new Fortios.Firewall.Inputs.PolicyInternetServiceNameArgs
    ///             {
    ///                 Name = "Amazon-AWS",
    ///             },
    ///             new Fortios.Firewall.Inputs.PolicyInternetServiceNameArgs
    ///             {
    ///                 Name = "GitHub-GitHub",
    ///             },
    ///         },
    ///         IpsSensor = "protect_email_server",
    ///         Logtraffic = "utm",
    ///         Policyid = 2,
    ///         Schedule = "always",
    ///         Srcaddrs = new[]
    ///         {
    ///             new Fortios.Firewall.Inputs.PolicySrcaddrArgs
    ///             {
    ///                 Name = "FABRIC_DEVICE",
    ///             },
    ///         },
    ///         Srcintfs = new[]
    ///         {
    ///             new Fortios.Firewall.Inputs.PolicySrcintfArgs
    ///             {
    ///                 Name = "port2",
    ///             },
    ///         },
    ///         SslSshProfile = "certificate-inspection",
    ///         Status = "enable",
    ///         UtmStatus = "enable",
    ///     });
    /// 
    /// });
    /// ```
    /// &lt;!--End PulumiCodeChooser --&gt;
    /// 
    /// ## Import
    /// 
    /// Firewall Policy can be imported using any of these accepted formats:
    /// 
    /// ```sh
    /// $ pulumi import fortios:firewall/policy:Policy labelname {{policyid}}
    /// ```
    /// 
    /// If you do not want to import arguments of block:
    /// 
    /// $ export "FORTIOS_IMPORT_TABLE"="false"
    /// 
    /// ```sh
    /// $ pulumi import fortios:firewall/policy:Policy labelname {{policyid}}
    /// ```
    /// 
    /// $ unset "FORTIOS_IMPORT_TABLE"
    /// </summary>
    [FortiosResourceType("fortios:firewall/policy:Policy")]
    public partial class Policy : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Policy action. On FortiOS versions 6.2.0-6.4.0: allow/deny/ipsec. On FortiOS versions &gt;= 6.4.1: accept/deny/ipsec. Valid values: `accept`, `deny`, `ipsec`.
        /// </summary>
        [Output("action")]
        public Output<string> Action { get; private set; } = null!;

        /// <summary>
        /// Enable/disable anti-replay check. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("antiReplay")]
        public Output<string> AntiReplay { get; private set; } = null!;

        /// <summary>
        /// Application category ID list. The structure of `app_category` block is documented below.
        /// </summary>
        [Output("appCategories")]
        public Output<ImmutableArray<Outputs.PolicyAppCategory>> AppCategories { get; private set; } = null!;

        /// <summary>
        /// Application group names. The structure of `app_group` block is documented below.
        /// </summary>
        [Output("appGroups")]
        public Output<ImmutableArray<Outputs.PolicyAppGroup>> AppGroups { get; private set; } = null!;

        /// <summary>
        /// Name of an existing Application list.
        /// </summary>
        [Output("applicationList")]
        public Output<string?> ApplicationList { get; private set; } = null!;

        /// <summary>
        /// Application ID list. The structure of `application` block is documented below.
        /// </summary>
        [Output("applications")]
        public Output<ImmutableArray<Outputs.PolicyApplication>> Applications { get; private set; } = null!;

        /// <summary>
        /// HTTPS server certificate for policy authentication.
        /// </summary>
        [Output("authCert")]
        public Output<string?> AuthCert { get; private set; } = null!;

        /// <summary>
        /// Enable/disable authentication-based routing. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("authPath")]
        public Output<string> AuthPath { get; private set; } = null!;

        /// <summary>
        /// HTTP-to-HTTPS redirect address for firewall authentication.
        /// </summary>
        [Output("authRedirectAddr")]
        public Output<string?> AuthRedirectAddr { get; private set; } = null!;

        /// <summary>
        /// Enable/disable policy traffic ASIC offloading. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("autoAsicOffload")]
        public Output<string> AutoAsicOffload { get; private set; } = null!;

        /// <summary>
        /// Name of an existing Antivirus profile.
        /// </summary>
        [Output("avProfile")]
        public Output<string?> AvProfile { get; private set; } = null!;

        /// <summary>
        /// Enable/disable block notification. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("blockNotification")]
        public Output<string> BlockNotification { get; private set; } = null!;

        /// <summary>
        /// Enable to exempt some users from the captive portal. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("captivePortalExempt")]
        public Output<string> CaptivePortalExempt { get; private set; } = null!;

        /// <summary>
        /// Enable/disable capture packets. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("capturePacket")]
        public Output<string> CapturePacket { get; private set; } = null!;

        /// <summary>
        /// Name of an existing CASB profile.
        /// </summary>
        [Output("casbProfile")]
        public Output<string?> CasbProfile { get; private set; } = null!;

        /// <summary>
        /// Name of an existing CIFS profile.
        /// </summary>
        [Output("cifsProfile")]
        public Output<string?> CifsProfile { get; private set; } = null!;

        /// <summary>
        /// Comment.
        /// </summary>
        [Output("comments")]
        public Output<string?> Comments { get; private set; } = null!;

        /// <summary>
        /// Custom fields to append to log messages for this policy. The structure of `custom_log_fields` block is documented below.
        /// </summary>
        [Output("customLogFields")]
        public Output<ImmutableArray<Outputs.PolicyCustomLogField>> CustomLogFields { get; private set; } = null!;

        /// <summary>
        /// Decrypted traffic mirror.
        /// </summary>
        [Output("decryptedTrafficMirror")]
        public Output<string?> DecryptedTrafficMirror { get; private set; } = null!;

        /// <summary>
        /// Enable TCP NPU session delay to guarantee packet order of 3-way handshake. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("delayTcpNpuSession")]
        public Output<string> DelayTcpNpuSession { get; private set; } = null!;

        /// <summary>
        /// Names of devices or device groups that can be matched by the policy. The structure of `devices` block is documented below.
        /// </summary>
        [Output("devices")]
        public Output<ImmutableArray<Outputs.PolicyDevice>> Devices { get; private set; } = null!;

        /// <summary>
        /// Name of an existing Diameter filter profile.
        /// </summary>
        [Output("diameterFilterProfile")]
        public Output<string?> DiameterFilterProfile { get; private set; } = null!;

        /// <summary>
        /// Enable to copy packet's DiffServ values from session's original direction to its reply direction. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("diffservCopy")]
        public Output<string> DiffservCopy { get; private set; } = null!;

        /// <summary>
        /// Enable to change packet's DiffServ values to the specified diffservcode-forward value. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("diffservForward")]
        public Output<string> DiffservForward { get; private set; } = null!;

        /// <summary>
        /// Enable to change packet's reverse (reply) DiffServ values to the specified diffservcode-rev value. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("diffservReverse")]
        public Output<string> DiffservReverse { get; private set; } = null!;

        /// <summary>
        /// Change packet's DiffServ to this value.
        /// </summary>
        [Output("diffservcodeForward")]
        public Output<string> DiffservcodeForward { get; private set; } = null!;

        /// <summary>
        /// Change packet's reverse (reply) DiffServ to this value.
        /// </summary>
        [Output("diffservcodeRev")]
        public Output<string> DiffservcodeRev { get; private set; } = null!;

        /// <summary>
        /// Enable/disable user authentication disclaimer. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("disclaimer")]
        public Output<string> Disclaimer { get; private set; } = null!;

        /// <summary>
        /// Name of an existing DLP profile.
        /// </summary>
        [Output("dlpProfile")]
        public Output<string?> DlpProfile { get; private set; } = null!;

        /// <summary>
        /// Name of an existing DLP sensor.
        /// </summary>
        [Output("dlpSensor")]
        public Output<string?> DlpSensor { get; private set; } = null!;

        /// <summary>
        /// Name of an existing DNS filter profile.
        /// </summary>
        [Output("dnsfilterProfile")]
        public Output<string?> DnsfilterProfile { get; private set; } = null!;

        /// <summary>
        /// Enable DSRI to ignore HTTP server responses. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("dsri")]
        public Output<string> Dsri { get; private set; } = null!;

        /// <summary>
        /// When enabled dstaddr6 specifies what the destination address must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("dstaddr6Negate")]
        public Output<string> Dstaddr6Negate { get; private set; } = null!;

        /// <summary>
        /// Destination IPv6 address name and address group names. The structure of `dstaddr6` block is documented below.
        /// </summary>
        [Output("dstaddr6s")]
        public Output<ImmutableArray<Outputs.PolicyDstaddr6>> Dstaddr6s { get; private set; } = null!;

        /// <summary>
        /// When enabled dstaddr specifies what the destination address must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("dstaddrNegate")]
        public Output<string> DstaddrNegate { get; private set; } = null!;

        /// <summary>
        /// Destination address and address group names. The structure of `dstaddr` block is documented below.
        /// </summary>
        [Output("dstaddrs")]
        public Output<ImmutableArray<Outputs.PolicyDstaddr>> Dstaddrs { get; private set; } = null!;

        /// <summary>
        /// Outgoing (egress) interface. The structure of `dstintf` block is documented below.
        /// </summary>
        [Output("dstintfs")]
        public Output<ImmutableArray<Outputs.PolicyDstintf>> Dstintfs { get; private set; } = null!;

        /// <summary>
        /// Enable/disable dynamic RADIUS defined traffic shaping. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("dynamicShaping")]
        public Output<string> DynamicShaping { get; private set; } = null!;

        /// <summary>
        /// Sort sub-tables, please do not set this parameter when configuring static sub-tables. Options: [ false, true, natural, alphabetical ]. false: Default value, do not sort tables; true/natural: sort tables in natural order. For example: [ a10, a2 ] -&gt; [ a2, a10 ]; alphabetical: sort tables in alphabetical order. For example: [ a10, a2 ] -&gt; [ a10, a2 ].
        /// </summary>
        [Output("dynamicSortSubtable")]
        public Output<string?> DynamicSortSubtable { get; private set; } = null!;

        /// <summary>
        /// Enable/disable email collection. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("emailCollect")]
        public Output<string> EmailCollect { get; private set; } = null!;

        /// <summary>
        /// Name of an existing email filter profile.
        /// </summary>
        [Output("emailfilterProfile")]
        public Output<string?> EmailfilterProfile { get; private set; } = null!;

        /// <summary>
        /// Enable/disable Forward Error Correction on traffic matching this policy on a FEC device. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("fec")]
        public Output<string> Fec { get; private set; } = null!;

        /// <summary>
        /// Name of an existing file-filter profile.
        /// </summary>
        [Output("fileFilterProfile")]
        public Output<string?> FileFilterProfile { get; private set; } = null!;

        /// <summary>
        /// How to handle sessions if the configuration of this firewall policy changes. Valid values: `check-all`, `check-new`.
        /// </summary>
        [Output("firewallSessionDirty")]
        public Output<string> FirewallSessionDirty { get; private set; } = null!;

        /// <summary>
        /// Enable to prevent source NAT from changing a session's source port. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("fixedport")]
        public Output<string> Fixedport { get; private set; } = null!;

        /// <summary>
        /// Enable/disable Fortinet Single Sign-On. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("fsso")]
        public Output<string?> Fsso { get; private set; } = null!;

        /// <summary>
        /// FSSO agent to use for NTLM authentication.
        /// </summary>
        [Output("fssoAgentForNtlm")]
        public Output<string?> FssoAgentForNtlm { get; private set; } = null!;

        /// <summary>
        /// Names of FSSO groups. The structure of `fsso_groups` block is documented below.
        /// </summary>
        [Output("fssoGroups")]
        public Output<ImmutableArray<Outputs.PolicyFssoGroup>> FssoGroups { get; private set; } = null!;

        /// <summary>
        /// Enable/disable recognition of anycast IP addresses using the geography IP database. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("geoipAnycast")]
        public Output<string> GeoipAnycast { get; private set; } = null!;

        /// <summary>
        /// Match geography address based either on its physical location or registered location. Valid values: `physical-location`, `registered-location`.
        /// </summary>
        [Output("geoipMatch")]
        public Output<string> GeoipMatch { get; private set; } = null!;

        /// <summary>
        /// Get all sub-tables including unconfigured tables. Do not set this variable to true if you configure sub-table in another resource, otherwish conflicts and overwrite will occur. Options: [ false, true ]. false: Default value, do not get unconfigured tables; true: get all tables including unconfigured tables.
        /// </summary>
        [Output("getAllTables")]
        public Output<string?> GetAllTables { get; private set; } = null!;

        /// <summary>
        /// Label for the policy that appears when the GUI is in Global View mode.
        /// </summary>
        [Output("globalLabel")]
        public Output<string?> GlobalLabel { get; private set; } = null!;

        /// <summary>
        /// Names of user groups that can authenticate with this policy. The structure of `groups` block is documented below.
        /// </summary>
        [Output("groups")]
        public Output<ImmutableArray<Outputs.PolicyGroup>> Groups { get; private set; } = null!;

        /// <summary>
        /// Redirect HTTP(S) traffic to matching transparent web proxy policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("httpPolicyRedirect")]
        public Output<string> HttpPolicyRedirect { get; private set; } = null!;

        /// <summary>
        /// Name of an existing ICAP profile.
        /// </summary>
        [Output("icapProfile")]
        public Output<string?> IcapProfile { get; private set; } = null!;

        /// <summary>
        /// Name of identity-based routing rule.
        /// </summary>
        [Output("identityBasedRoute")]
        public Output<string?> IdentityBasedRoute { get; private set; } = null!;

        /// <summary>
        /// Policy-based IPsec VPN: only traffic from the remote network can initiate a VPN. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("inbound")]
        public Output<string> Inbound { get; private set; } = null!;

        /// <summary>
        /// Policy inspection mode (Flow/proxy). Default is Flow mode. Valid values: `proxy`, `flow`.
        /// </summary>
        [Output("inspectionMode")]
        public Output<string> InspectionMode { get; private set; } = null!;

        /// <summary>
        /// Enable/disable use of Internet Services for this policy. If enabled, destination address and service are not used.  Valid values: `enable`, `disable`.
        /// </summary>
        [Output("internetService")]
        public Output<string> InternetService { get; private set; } = null!;

        /// <summary>
        /// Enable/disable use of IPv6 Internet Services for this policy. If enabled, destination address and service are not used. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("internetService6")]
        public Output<string> InternetService6 { get; private set; } = null!;

        /// <summary>
        /// Custom Internet Service6 group name. The structure of `internet_service6_custom_group` block is documented below.
        /// </summary>
        [Output("internetService6CustomGroups")]
        public Output<ImmutableArray<Outputs.PolicyInternetService6CustomGroup>> InternetService6CustomGroups { get; private set; } = null!;

        /// <summary>
        /// Custom IPv6 Internet Service name. The structure of `internet_service6_custom` block is documented below.
        /// </summary>
        [Output("internetService6Customs")]
        public Output<ImmutableArray<Outputs.PolicyInternetService6Custom>> InternetService6Customs { get; private set; } = null!;

        /// <summary>
        /// Internet Service group name. The structure of `internet_service6_group` block is documented below.
        /// </summary>
        [Output("internetService6Groups")]
        public Output<ImmutableArray<Outputs.PolicyInternetService6Group>> InternetService6Groups { get; private set; } = null!;

        /// <summary>
        /// IPv6 Internet Service name. The structure of `internet_service6_name` block is documented below.
        /// </summary>
        [Output("internetService6Names")]
        public Output<ImmutableArray<Outputs.PolicyInternetService6Name>> InternetService6Names { get; private set; } = null!;

        /// <summary>
        /// When enabled internet-service6 specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("internetService6Negate")]
        public Output<string> InternetService6Negate { get; private set; } = null!;

        /// <summary>
        /// Enable/disable use of IPv6 Internet Services in source for this policy. If enabled, source address is not used. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("internetService6Src")]
        public Output<string> InternetService6Src { get; private set; } = null!;

        /// <summary>
        /// Custom Internet Service6 source group name. The structure of `internet_service6_src_custom_group` block is documented below.
        /// </summary>
        [Output("internetService6SrcCustomGroups")]
        public Output<ImmutableArray<Outputs.PolicyInternetService6SrcCustomGroup>> InternetService6SrcCustomGroups { get; private set; } = null!;

        /// <summary>
        /// Custom IPv6 Internet Service source name. The structure of `internet_service6_src_custom` block is documented below.
        /// </summary>
        [Output("internetService6SrcCustoms")]
        public Output<ImmutableArray<Outputs.PolicyInternetService6SrcCustom>> InternetService6SrcCustoms { get; private set; } = null!;

        /// <summary>
        /// Internet Service6 source group name. The structure of `internet_service6_src_group` block is documented below.
        /// </summary>
        [Output("internetService6SrcGroups")]
        public Output<ImmutableArray<Outputs.PolicyInternetService6SrcGroup>> InternetService6SrcGroups { get; private set; } = null!;

        /// <summary>
        /// IPv6 Internet Service source name. The structure of `internet_service6_src_name` block is documented below.
        /// </summary>
        [Output("internetService6SrcNames")]
        public Output<ImmutableArray<Outputs.PolicyInternetService6SrcName>> InternetService6SrcNames { get; private set; } = null!;

        /// <summary>
        /// When enabled internet-service6-src specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("internetService6SrcNegate")]
        public Output<string> InternetService6SrcNegate { get; private set; } = null!;

        /// <summary>
        /// Custom Internet Service group name. The structure of `internet_service_custom_group` block is documented below.
        /// </summary>
        [Output("internetServiceCustomGroups")]
        public Output<ImmutableArray<Outputs.PolicyInternetServiceCustomGroup>> InternetServiceCustomGroups { get; private set; } = null!;

        /// <summary>
        /// Custom Internet Service name. The structure of `internet_service_custom` block is documented below.
        /// </summary>
        [Output("internetServiceCustoms")]
        public Output<ImmutableArray<Outputs.PolicyInternetServiceCustom>> InternetServiceCustoms { get; private set; } = null!;

        /// <summary>
        /// Internet Service group name. The structure of `internet_service_group` block is documented below.
        /// </summary>
        [Output("internetServiceGroups")]
        public Output<ImmutableArray<Outputs.PolicyInternetServiceGroup>> InternetServiceGroups { get; private set; } = null!;

        /// <summary>
        /// Internet Service ID. The structure of `internet_service_id` block is documented below.
        /// </summary>
        [Output("internetServiceIds")]
        public Output<ImmutableArray<Outputs.PolicyInternetServiceId>> InternetServiceIds { get; private set; } = null!;

        /// <summary>
        /// Internet Service name. The structure of `internet_service_name` block is documented below.
        /// </summary>
        [Output("internetServiceNames")]
        public Output<ImmutableArray<Outputs.PolicyInternetServiceName>> InternetServiceNames { get; private set; } = null!;

        /// <summary>
        /// When enabled internet-service specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("internetServiceNegate")]
        public Output<string> InternetServiceNegate { get; private set; } = null!;

        /// <summary>
        /// Enable/disable use of Internet Services in source for this policy. If enabled, source address is not used.  Valid values: `enable`, `disable`.
        /// </summary>
        [Output("internetServiceSrc")]
        public Output<string> InternetServiceSrc { get; private set; } = null!;

        /// <summary>
        /// Custom Internet Service source group name. The structure of `internet_service_src_custom_group` block is documented below.
        /// </summary>
        [Output("internetServiceSrcCustomGroups")]
        public Output<ImmutableArray<Outputs.PolicyInternetServiceSrcCustomGroup>> InternetServiceSrcCustomGroups { get; private set; } = null!;

        /// <summary>
        /// Custom Internet Service source name. The structure of `internet_service_src_custom` block is documented below.
        /// </summary>
        [Output("internetServiceSrcCustoms")]
        public Output<ImmutableArray<Outputs.PolicyInternetServiceSrcCustom>> InternetServiceSrcCustoms { get; private set; } = null!;

        /// <summary>
        /// Internet Service source group name. The structure of `internet_service_src_group` block is documented below.
        /// </summary>
        [Output("internetServiceSrcGroups")]
        public Output<ImmutableArray<Outputs.PolicyInternetServiceSrcGroup>> InternetServiceSrcGroups { get; private set; } = null!;

        /// <summary>
        /// Internet Service source ID. The structure of `internet_service_src_id` block is documented below.
        /// </summary>
        [Output("internetServiceSrcIds")]
        public Output<ImmutableArray<Outputs.PolicyInternetServiceSrcId>> InternetServiceSrcIds { get; private set; } = null!;

        /// <summary>
        /// Internet Service source name. The structure of `internet_service_src_name` block is documented below.
        /// </summary>
        [Output("internetServiceSrcNames")]
        public Output<ImmutableArray<Outputs.PolicyInternetServiceSrcName>> InternetServiceSrcNames { get; private set; } = null!;

        /// <summary>
        /// When enabled internet-service-src specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("internetServiceSrcNegate")]
        public Output<string> InternetServiceSrcNegate { get; private set; } = null!;

        /// <summary>
        /// Enable to use IP Pools for source NAT. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("ippool")]
        public Output<string> Ippool { get; private set; } = null!;

        /// <summary>
        /// Name of an existing IPS sensor.
        /// </summary>
        [Output("ipsSensor")]
        public Output<string?> IpsSensor { get; private set; } = null!;

        /// <summary>
        /// Name of an existing VoIP (ips) profile.
        /// </summary>
        [Output("ipsVoipFilter")]
        public Output<string?> IpsVoipFilter { get; private set; } = null!;

        /// <summary>
        /// Label for the policy that appears when the GUI is in Section View mode.
        /// </summary>
        [Output("label")]
        public Output<string?> Label { get; private set; } = null!;

        /// <summary>
        /// Enable to allow everything, but log all of the meaningful data for security information gathering. A learning report will be generated. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("learningMode")]
        public Output<string?> LearningMode { get; private set; } = null!;

        /// <summary>
        /// Enable or disable logging. Log all sessions or security profile sessions. Valid values: `all`, `utm`, `disable`.
        /// </summary>
        [Output("logtraffic")]
        public Output<string> Logtraffic { get; private set; } = null!;

        /// <summary>
        /// Record logs when a session starts. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("logtrafficStart")]
        public Output<string> LogtrafficStart { get; private set; } = null!;

        /// <summary>
        /// Enable to match packets that have had their destination addresses changed by a VIP. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("matchVip")]
        public Output<string> MatchVip { get; private set; } = null!;

        /// <summary>
        /// Enable/disable matching of only those packets that have had their destination addresses changed by a VIP. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("matchVipOnly")]
        public Output<string> MatchVipOnly { get; private set; } = null!;

        /// <summary>
        /// Policy name.
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// Enable/disable source NAT. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("nat")]
        public Output<string> Nat { get; private set; } = null!;

        /// <summary>
        /// Enable/disable NAT46. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("nat46")]
        public Output<string> Nat46 { get; private set; } = null!;

        /// <summary>
        /// Enable/disable NAT64. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("nat64")]
        public Output<string> Nat64 { get; private set; } = null!;

        /// <summary>
        /// Policy-based IPsec VPN: apply destination NAT to inbound traffic. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("natinbound")]
        public Output<string> Natinbound { get; private set; } = null!;

        /// <summary>
        /// Policy-based IPsec VPN: source NAT IP address for outgoing traffic.
        /// </summary>
        [Output("natip")]
        public Output<string> Natip { get; private set; } = null!;

        /// <summary>
        /// Policy-based IPsec VPN: apply source NAT to outbound traffic. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("natoutbound")]
        public Output<string> Natoutbound { get; private set; } = null!;

        /// <summary>
        /// Dynamic Network Service name. The structure of `network_service_dynamic` block is documented below.
        /// </summary>
        [Output("networkServiceDynamics")]
        public Output<ImmutableArray<Outputs.PolicyNetworkServiceDynamic>> NetworkServiceDynamics { get; private set; } = null!;

        /// <summary>
        /// Dynamic Network Service source name. The structure of `network_service_src_dynamic` block is documented below.
        /// </summary>
        [Output("networkServiceSrcDynamics")]
        public Output<ImmutableArray<Outputs.PolicyNetworkServiceSrcDynamic>> NetworkServiceSrcDynamics { get; private set; } = null!;

        /// <summary>
        /// Enable/disable UTM Network Processor acceleration. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("npAcceleration")]
        public Output<string> NpAcceleration { get; private set; } = null!;

        /// <summary>
        /// Enable/disable NTLM authentication. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("ntlm")]
        public Output<string> Ntlm { get; private set; } = null!;

        /// <summary>
        /// HTTP-User-Agent value of supported browsers. The structure of `ntlm_enabled_browsers` block is documented below.
        /// </summary>
        [Output("ntlmEnabledBrowsers")]
        public Output<ImmutableArray<Outputs.PolicyNtlmEnabledBrowser>> NtlmEnabledBrowsers { get; private set; } = null!;

        /// <summary>
        /// Enable/disable NTLM guest user access. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("ntlmGuest")]
        public Output<string> NtlmGuest { get; private set; } = null!;

        /// <summary>
        /// Policy-based IPsec VPN: only traffic from the internal network can initiate a VPN. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("outbound")]
        public Output<string> Outbound { get; private set; } = null!;

        /// <summary>
        /// Enable/disable passive WAN health measurement. When enabled, auto-asic-offload is disabled. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("passiveWanHealthMeasurement")]
        public Output<string> PassiveWanHealthMeasurement { get; private set; } = null!;

        /// <summary>
        /// Enable/disable PCP inbound DNAT. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("pcpInbound")]
        public Output<string> PcpInbound { get; private set; } = null!;

        /// <summary>
        /// Enable/disable PCP outbound SNAT. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("pcpOutbound")]
        public Output<string> PcpOutbound { get; private set; } = null!;

        /// <summary>
        /// PCP pool names. The structure of `pcp_poolname` block is documented below.
        /// </summary>
        [Output("pcpPoolnames")]
        public Output<ImmutableArray<Outputs.PolicyPcpPoolname>> PcpPoolnames { get; private set; } = null!;

        /// <summary>
        /// Per-IP traffic shaper.
        /// </summary>
        [Output("perIpShaper")]
        public Output<string?> PerIpShaper { get; private set; } = null!;

        /// <summary>
        /// Accept UDP packets from any host. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("permitAnyHost")]
        public Output<string> PermitAnyHost { get; private set; } = null!;

        /// <summary>
        /// Accept UDP packets from any Session Traversal Utilities for NAT (STUN) host. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("permitStunHost")]
        public Output<string> PermitStunHost { get; private set; } = null!;

        /// <summary>
        /// Enable/disable policy expiry. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("policyExpiry")]
        public Output<string> PolicyExpiry { get; private set; } = null!;

        /// <summary>
        /// Policy expiry date (YYYY-MM-DD HH:MM:SS).
        /// </summary>
        [Output("policyExpiryDate")]
        public Output<string> PolicyExpiryDate { get; private set; } = null!;

        /// <summary>
        /// Policy expiry date and time, in epoch format.
        /// </summary>
        [Output("policyExpiryDateUtc")]
        public Output<string?> PolicyExpiryDateUtc { get; private set; } = null!;

        /// <summary>
        /// Policy ID.
        /// </summary>
        [Output("policyid")]
        public Output<int> Policyid { get; private set; } = null!;

        /// <summary>
        /// IPv6 pool names. The structure of `poolname6` block is documented below.
        /// </summary>
        [Output("poolname6s")]
        public Output<ImmutableArray<Outputs.PolicyPoolname6>> Poolname6s { get; private set; } = null!;

        /// <summary>
        /// IP Pool names. The structure of `poolname` block is documented below.
        /// </summary>
        [Output("poolnames")]
        public Output<ImmutableArray<Outputs.PolicyPoolname>> Poolnames { get; private set; } = null!;

        /// <summary>
        /// Name of profile group.
        /// </summary>
        [Output("profileGroup")]
        public Output<string?> ProfileGroup { get; private set; } = null!;

        /// <summary>
        /// Name of an existing Protocol options profile.
        /// </summary>
        [Output("profileProtocolOptions")]
        public Output<string> ProfileProtocolOptions { get; private set; } = null!;

        /// <summary>
        /// Determine whether the firewall policy allows security profile groups or single profiles only. Valid values: `single`, `group`.
        /// </summary>
        [Output("profileType")]
        public Output<string> ProfileType { get; private set; } = null!;

        /// <summary>
        /// Enable MAC authentication bypass. The bypassed MAC address must be received from RADIUS server. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("radiusMacAuthBypass")]
        public Output<string> RadiusMacAuthBypass { get; private set; } = null!;

        /// <summary>
        /// URL users are directed to after seeing and accepting the disclaimer or authenticating.
        /// </summary>
        [Output("redirectUrl")]
        public Output<string?> RedirectUrl { get; private set; } = null!;

        /// <summary>
        /// Override the default replacement message group for this policy.
        /// </summary>
        [Output("replacemsgOverrideGroup")]
        public Output<string?> ReplacemsgOverrideGroup { get; private set; } = null!;

        /// <summary>
        /// Direction of the initial traffic for reputation to take effect. Valid values: `source`, `destination`.
        /// </summary>
        [Output("reputationDirection")]
        public Output<string> ReputationDirection { get; private set; } = null!;

        /// <summary>
        /// Direction of the initial traffic for IPv6 reputation to take effect. Valid values: `source`, `destination`.
        /// </summary>
        [Output("reputationDirection6")]
        public Output<string> ReputationDirection6 { get; private set; } = null!;

        /// <summary>
        /// Minimum Reputation to take action.
        /// </summary>
        [Output("reputationMinimum")]
        public Output<int?> ReputationMinimum { get; private set; } = null!;

        /// <summary>
        /// IPv6 Minimum Reputation to take action.
        /// </summary>
        [Output("reputationMinimum6")]
        public Output<int?> ReputationMinimum6 { get; private set; } = null!;

        /// <summary>
        /// Enable/disable RADIUS single sign-on (RSSO). Valid values: `enable`, `disable`.
        /// </summary>
        [Output("rsso")]
        public Output<string?> Rsso { get; private set; } = null!;

        /// <summary>
        /// Address names if this is an RTP NAT policy. The structure of `rtp_addr` block is documented below.
        /// </summary>
        [Output("rtpAddrs")]
        public Output<ImmutableArray<Outputs.PolicyRtpAddr>> RtpAddrs { get; private set; } = null!;

        /// <summary>
        /// Enable Real Time Protocol (RTP) NAT. Valid values: `disable`, `enable`.
        /// </summary>
        [Output("rtpNat")]
        public Output<string> RtpNat { get; private set; } = null!;

        /// <summary>
        /// Block or monitor connections to Botnet servers or disable Botnet scanning. Valid values: `disable`, `block`, `monitor`.
        /// </summary>
        [Output("scanBotnetConnections")]
        public Output<string?> ScanBotnetConnections { get; private set; } = null!;

        /// <summary>
        /// Schedule name.(Default is `always`)
        /// </summary>
        [Output("schedule")]
        public Output<string?> Schedule { get; private set; } = null!;

        /// <summary>
        /// Enable to force current sessions to end when the schedule object times out. Disable allows them to end from inactivity. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("scheduleTimeout")]
        public Output<string> ScheduleTimeout { get; private set; } = null!;

        /// <summary>
        /// Name of an existing SCTP filter profile.
        /// </summary>
        [Output("sctpFilterProfile")]
        public Output<string?> SctpFilterProfile { get; private set; } = null!;

        /// <summary>
        /// Enable to send a reply when a session is denied or blocked by a firewall policy. Valid values: `disable`, `enable`.
        /// </summary>
        [Output("sendDenyPacket")]
        public Output<string> SendDenyPacket { get; private set; } = null!;

        /// <summary>
        /// When enabled service specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("serviceNegate")]
        public Output<string> ServiceNegate { get; private set; } = null!;

        /// <summary>
        /// Service and service group names. The structure of `service` block is documented below.
        /// </summary>
        [Output("services")]
        public Output<ImmutableArray<Outputs.PolicyService>> Services { get; private set; } = null!;

        /// <summary>
        /// TTL in seconds for sessions accepted by this policy (0 means use the system default session TTL).
        /// </summary>
        [Output("sessionTtl")]
        public Output<int?> SessionTtl { get; private set; } = null!;

        /// <summary>
        /// Enable/disable security group tags (SGT) check. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("sgtCheck")]
        public Output<string> SgtCheck { get; private set; } = null!;

        /// <summary>
        /// Security group tags. The structure of `sgt` block is documented below.
        /// </summary>
        [Output("sgts")]
        public Output<ImmutableArray<Outputs.PolicySgt>> Sgts { get; private set; } = null!;

        /// <summary>
        /// Name of an existing Spam filter profile.
        /// </summary>
        [Output("spamfilterProfile")]
        public Output<string?> SpamfilterProfile { get; private set; } = null!;

        /// <summary>
        /// Vendor MAC source ID. The structure of `src_vendor_mac` block is documented below.
        /// </summary>
        [Output("srcVendorMacs")]
        public Output<ImmutableArray<Outputs.PolicySrcVendorMac>> SrcVendorMacs { get; private set; } = null!;

        /// <summary>
        /// When enabled srcaddr6 specifies what the source address must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("srcaddr6Negate")]
        public Output<string> Srcaddr6Negate { get; private set; } = null!;

        /// <summary>
        /// Source IPv6 address name and address group names. The structure of `srcaddr6` block is documented below.
        /// </summary>
        [Output("srcaddr6s")]
        public Output<ImmutableArray<Outputs.PolicySrcaddr6>> Srcaddr6s { get; private set; } = null!;

        /// <summary>
        /// When enabled srcaddr specifies what the source address must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("srcaddrNegate")]
        public Output<string> SrcaddrNegate { get; private set; } = null!;

        /// <summary>
        /// Source address and address group names. The structure of `srcaddr` block is documented below.
        /// </summary>
        [Output("srcaddrs")]
        public Output<ImmutableArray<Outputs.PolicySrcaddr>> Srcaddrs { get; private set; } = null!;

        /// <summary>
        /// Incoming (ingress) interface. The structure of `srcintf` block is documented below.
        /// </summary>
        [Output("srcintfs")]
        public Output<ImmutableArray<Outputs.PolicySrcintf>> Srcintfs { get; private set; } = null!;

        /// <summary>
        /// Name of an existing SSH filter profile.
        /// </summary>
        [Output("sshFilterProfile")]
        public Output<string?> SshFilterProfile { get; private set; } = null!;

        /// <summary>
        /// Redirect SSH traffic to matching transparent proxy policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("sshPolicyRedirect")]
        public Output<string> SshPolicyRedirect { get; private set; } = null!;

        /// <summary>
        /// Enable to copy decrypted SSL traffic to a FortiGate interface (called SSL mirroring). Valid values: `enable`, `disable`.
        /// </summary>
        [Output("sslMirror")]
        public Output<string?> SslMirror { get; private set; } = null!;

        /// <summary>
        /// SSL mirror interface name. The structure of `ssl_mirror_intf` block is documented below.
        /// </summary>
        [Output("sslMirrorIntfs")]
        public Output<ImmutableArray<Outputs.PolicySslMirrorIntf>> SslMirrorIntfs { get; private set; } = null!;

        /// <summary>
        /// Name of an existing SSL SSH profile.
        /// </summary>
        [Output("sslSshProfile")]
        public Output<string> SslSshProfile { get; private set; } = null!;

        /// <summary>
        /// Enable or disable this policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("status")]
        public Output<string> Status { get; private set; } = null!;

        /// <summary>
        /// Receiver TCP maximum segment size (MSS).
        /// </summary>
        [Output("tcpMssReceiver")]
        public Output<int?> TcpMssReceiver { get; private set; } = null!;

        /// <summary>
        /// Sender TCP maximum segment size (MSS).
        /// </summary>
        [Output("tcpMssSender")]
        public Output<int?> TcpMssSender { get; private set; } = null!;

        /// <summary>
        /// Enable/disable creation of TCP session without SYN flag. Valid values: `all`, `data-only`, `disable`.
        /// </summary>
        [Output("tcpSessionWithoutSyn")]
        public Output<string> TcpSessionWithoutSyn { get; private set; } = null!;

        /// <summary>
        /// Enable/disable sending RST packets when TCP sessions expire. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("timeoutSendRst")]
        public Output<string> TimeoutSendRst { get; private set; } = null!;

        /// <summary>
        /// ToS (Type of Service) value used for comparison.
        /// </summary>
        [Output("tos")]
        public Output<string> Tos { get; private set; } = null!;

        /// <summary>
        /// Non-zero bit positions are used for comparison while zero bit positions are ignored.
        /// </summary>
        [Output("tosMask")]
        public Output<string> TosMask { get; private set; } = null!;

        /// <summary>
        /// Enable negated TOS match. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("tosNegate")]
        public Output<string> TosNegate { get; private set; } = null!;

        /// <summary>
        /// Traffic shaper.
        /// </summary>
        [Output("trafficShaper")]
        public Output<string?> TrafficShaper { get; private set; } = null!;

        /// <summary>
        /// Reverse traffic shaper.
        /// </summary>
        [Output("trafficShaperReverse")]
        public Output<string?> TrafficShaperReverse { get; private set; } = null!;

        /// <summary>
        /// URL category ID list. The structure of `url_category` block is documented below.
        /// </summary>
        [Output("urlCategories")]
        public Output<ImmutableArray<Outputs.PolicyUrlCategory>> UrlCategories { get; private set; } = null!;

        /// <summary>
        /// Names of individual users that can authenticate with this policy. The structure of `users` block is documented below.
        /// </summary>
        [Output("users")]
        public Output<ImmutableArray<Outputs.PolicyUser>> Users { get; private set; } = null!;

        /// <summary>
        /// Enable to add one or more security profiles (AV, IPS, etc.) to the firewall policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("utmStatus")]
        public Output<string> UtmStatus { get; private set; } = null!;

        /// <summary>
        /// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
        /// </summary>
        [Output("uuid")]
        public Output<string> Uuid { get; private set; } = null!;

        /// <summary>
        /// Specifies the vdom to which the resource will be applied when the FortiGate unit is running in VDOM mode. Only one vdom can be specified. If you want to inherit the vdom configuration of the provider, please do not set this parameter.
        /// </summary>
        [Output("vdomparam")]
        public Output<string?> Vdomparam { get; private set; } = null!;

        /// <summary>
        /// Name of an existing VideoFilter profile.
        /// </summary>
        [Output("videofilterProfile")]
        public Output<string?> VideofilterProfile { get; private set; } = null!;

        /// <summary>
        /// Name of an existing virtual-patch profile.
        /// </summary>
        [Output("virtualPatchProfile")]
        public Output<string?> VirtualPatchProfile { get; private set; } = null!;

        /// <summary>
        /// VLAN forward direction user priority: 255 passthrough, 0 lowest, 7 highest.
        /// </summary>
        [Output("vlanCosFwd")]
        public Output<int> VlanCosFwd { get; private set; } = null!;

        /// <summary>
        /// VLAN reverse direction user priority: 255 passthrough, 0 lowest, 7 highest.
        /// </summary>
        [Output("vlanCosRev")]
        public Output<int> VlanCosRev { get; private set; } = null!;

        /// <summary>
        /// Set VLAN filters.
        /// </summary>
        [Output("vlanFilter")]
        public Output<string?> VlanFilter { get; private set; } = null!;

        /// <summary>
        /// Name of an existing VoIP (voipd) profile.
        /// </summary>
        [Output("voipProfile")]
        public Output<string?> VoipProfile { get; private set; } = null!;

        /// <summary>
        /// Policy-based IPsec VPN: name of the IPsec VPN Phase 1.
        /// </summary>
        [Output("vpntunnel")]
        public Output<string?> Vpntunnel { get; private set; } = null!;

        /// <summary>
        /// Name of an existing Web application firewall profile.
        /// </summary>
        [Output("wafProfile")]
        public Output<string?> WafProfile { get; private set; } = null!;

        /// <summary>
        /// Enable/disable WAN optimization. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("wanopt")]
        public Output<string> Wanopt { get; private set; } = null!;

        /// <summary>
        /// WAN optimization auto-detection mode. Valid values: `active`, `passive`, `off`.
        /// </summary>
        [Output("wanoptDetection")]
        public Output<string> WanoptDetection { get; private set; } = null!;

        /// <summary>
        /// WAN optimization passive mode options. This option decides what IP address will be used to connect server. Valid values: `default`, `transparent`, `non-transparent`.
        /// </summary>
        [Output("wanoptPassiveOpt")]
        public Output<string> WanoptPassiveOpt { get; private set; } = null!;

        /// <summary>
        /// WAN optimization peer.
        /// </summary>
        [Output("wanoptPeer")]
        public Output<string?> WanoptPeer { get; private set; } = null!;

        /// <summary>
        /// WAN optimization profile.
        /// </summary>
        [Output("wanoptProfile")]
        public Output<string?> WanoptProfile { get; private set; } = null!;

        /// <summary>
        /// Enable/disable forwarding traffic matching this policy to a configured WCCP server. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("wccp")]
        public Output<string> Wccp { get; private set; } = null!;

        /// <summary>
        /// Enable/disable web cache. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("webcache")]
        public Output<string> Webcache { get; private set; } = null!;

        /// <summary>
        /// Enable/disable web cache for HTTPS. Valid values: `disable`, `enable`.
        /// </summary>
        [Output("webcacheHttps")]
        public Output<string> WebcacheHttps { get; private set; } = null!;

        /// <summary>
        /// Name of an existing Web filter profile.
        /// </summary>
        [Output("webfilterProfile")]
        public Output<string?> WebfilterProfile { get; private set; } = null!;

        /// <summary>
        /// Web proxy forward server name.
        /// </summary>
        [Output("webproxyForwardServer")]
        public Output<string?> WebproxyForwardServer { get; private set; } = null!;

        /// <summary>
        /// Webproxy profile name.
        /// </summary>
        [Output("webproxyProfile")]
        public Output<string?> WebproxyProfile { get; private set; } = null!;

        /// <summary>
        /// Enable/disable WiFi Single Sign On (WSSO). Valid values: `enable`, `disable`.
        /// </summary>
        [Output("wsso")]
        public Output<string?> Wsso { get; private set; } = null!;

        /// <summary>
        /// Enable/disable zero trust device ownership. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("ztnaDeviceOwnership")]
        public Output<string> ZtnaDeviceOwnership { get; private set; } = null!;

        /// <summary>
        /// Source ztna-ems-tag-secondary names. The structure of `ztna_ems_tag_secondary` block is documented below.
        /// </summary>
        [Output("ztnaEmsTagSecondaries")]
        public Output<ImmutableArray<Outputs.PolicyZtnaEmsTagSecondary>> ZtnaEmsTagSecondaries { get; private set; } = null!;

        /// <summary>
        /// Source ztna-ems-tag names. The structure of `ztna_ems_tag` block is documented below.
        /// </summary>
        [Output("ztnaEmsTags")]
        public Output<ImmutableArray<Outputs.PolicyZtnaEmsTag>> ZtnaEmsTags { get; private set; } = null!;

        /// <summary>
        /// Source ztna-geo-tag names. The structure of `ztna_geo_tag` block is documented below.
        /// </summary>
        [Output("ztnaGeoTags")]
        public Output<ImmutableArray<Outputs.PolicyZtnaGeoTag>> ZtnaGeoTags { get; private set; } = null!;

        /// <summary>
        /// Redirect ZTNA traffic to matching Access-Proxy proxy-policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("ztnaPolicyRedirect")]
        public Output<string> ZtnaPolicyRedirect { get; private set; } = null!;

        /// <summary>
        /// Enable/disable zero trust access. Valid values: `enable`, `disable`.
        /// </summary>
        [Output("ztnaStatus")]
        public Output<string> ZtnaStatus { get; private set; } = null!;

        /// <summary>
        /// ZTNA tag matching logic. Valid values: `or`, `and`.
        /// </summary>
        [Output("ztnaTagsMatchLogic")]
        public Output<string> ZtnaTagsMatchLogic { get; private set; } = null!;


        /// <summary>
        /// Create a Policy resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Policy(string name, PolicyArgs args, CustomResourceOptions? options = null)
            : base("fortios:firewall/policy:Policy", name, args ?? new PolicyArgs(), MakeResourceOptions(options, ""))
        {
        }

        private Policy(string name, Input<string> id, PolicyState? state = null, CustomResourceOptions? options = null)
            : base("fortios:firewall/policy:Policy", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
                PluginDownloadURL = "github://api.github.com/pulumiverse/pulumi-fortios",
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing Policy resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static Policy Get(string name, Input<string> id, PolicyState? state = null, CustomResourceOptions? options = null)
        {
            return new Policy(name, id, state, options);
        }
    }

    public sealed class PolicyArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Policy action. On FortiOS versions 6.2.0-6.4.0: allow/deny/ipsec. On FortiOS versions &gt;= 6.4.1: accept/deny/ipsec. Valid values: `accept`, `deny`, `ipsec`.
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// Enable/disable anti-replay check. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("antiReplay")]
        public Input<string>? AntiReplay { get; set; }

        [Input("appCategories")]
        private InputList<Inputs.PolicyAppCategoryArgs>? _appCategories;

        /// <summary>
        /// Application category ID list. The structure of `app_category` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyAppCategoryArgs> AppCategories
        {
            get => _appCategories ?? (_appCategories = new InputList<Inputs.PolicyAppCategoryArgs>());
            set => _appCategories = value;
        }

        [Input("appGroups")]
        private InputList<Inputs.PolicyAppGroupArgs>? _appGroups;

        /// <summary>
        /// Application group names. The structure of `app_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyAppGroupArgs> AppGroups
        {
            get => _appGroups ?? (_appGroups = new InputList<Inputs.PolicyAppGroupArgs>());
            set => _appGroups = value;
        }

        /// <summary>
        /// Name of an existing Application list.
        /// </summary>
        [Input("applicationList")]
        public Input<string>? ApplicationList { get; set; }

        [Input("applications")]
        private InputList<Inputs.PolicyApplicationArgs>? _applications;

        /// <summary>
        /// Application ID list. The structure of `application` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyApplicationArgs> Applications
        {
            get => _applications ?? (_applications = new InputList<Inputs.PolicyApplicationArgs>());
            set => _applications = value;
        }

        /// <summary>
        /// HTTPS server certificate for policy authentication.
        /// </summary>
        [Input("authCert")]
        public Input<string>? AuthCert { get; set; }

        /// <summary>
        /// Enable/disable authentication-based routing. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("authPath")]
        public Input<string>? AuthPath { get; set; }

        /// <summary>
        /// HTTP-to-HTTPS redirect address for firewall authentication.
        /// </summary>
        [Input("authRedirectAddr")]
        public Input<string>? AuthRedirectAddr { get; set; }

        /// <summary>
        /// Enable/disable policy traffic ASIC offloading. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("autoAsicOffload")]
        public Input<string>? AutoAsicOffload { get; set; }

        /// <summary>
        /// Name of an existing Antivirus profile.
        /// </summary>
        [Input("avProfile")]
        public Input<string>? AvProfile { get; set; }

        /// <summary>
        /// Enable/disable block notification. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("blockNotification")]
        public Input<string>? BlockNotification { get; set; }

        /// <summary>
        /// Enable to exempt some users from the captive portal. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("captivePortalExempt")]
        public Input<string>? CaptivePortalExempt { get; set; }

        /// <summary>
        /// Enable/disable capture packets. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("capturePacket")]
        public Input<string>? CapturePacket { get; set; }

        /// <summary>
        /// Name of an existing CASB profile.
        /// </summary>
        [Input("casbProfile")]
        public Input<string>? CasbProfile { get; set; }

        /// <summary>
        /// Name of an existing CIFS profile.
        /// </summary>
        [Input("cifsProfile")]
        public Input<string>? CifsProfile { get; set; }

        /// <summary>
        /// Comment.
        /// </summary>
        [Input("comments")]
        public Input<string>? Comments { get; set; }

        [Input("customLogFields")]
        private InputList<Inputs.PolicyCustomLogFieldArgs>? _customLogFields;

        /// <summary>
        /// Custom fields to append to log messages for this policy. The structure of `custom_log_fields` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyCustomLogFieldArgs> CustomLogFields
        {
            get => _customLogFields ?? (_customLogFields = new InputList<Inputs.PolicyCustomLogFieldArgs>());
            set => _customLogFields = value;
        }

        /// <summary>
        /// Decrypted traffic mirror.
        /// </summary>
        [Input("decryptedTrafficMirror")]
        public Input<string>? DecryptedTrafficMirror { get; set; }

        /// <summary>
        /// Enable TCP NPU session delay to guarantee packet order of 3-way handshake. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("delayTcpNpuSession")]
        public Input<string>? DelayTcpNpuSession { get; set; }

        [Input("devices")]
        private InputList<Inputs.PolicyDeviceArgs>? _devices;

        /// <summary>
        /// Names of devices or device groups that can be matched by the policy. The structure of `devices` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyDeviceArgs> Devices
        {
            get => _devices ?? (_devices = new InputList<Inputs.PolicyDeviceArgs>());
            set => _devices = value;
        }

        /// <summary>
        /// Name of an existing Diameter filter profile.
        /// </summary>
        [Input("diameterFilterProfile")]
        public Input<string>? DiameterFilterProfile { get; set; }

        /// <summary>
        /// Enable to copy packet's DiffServ values from session's original direction to its reply direction. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("diffservCopy")]
        public Input<string>? DiffservCopy { get; set; }

        /// <summary>
        /// Enable to change packet's DiffServ values to the specified diffservcode-forward value. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("diffservForward")]
        public Input<string>? DiffservForward { get; set; }

        /// <summary>
        /// Enable to change packet's reverse (reply) DiffServ values to the specified diffservcode-rev value. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("diffservReverse")]
        public Input<string>? DiffservReverse { get; set; }

        /// <summary>
        /// Change packet's DiffServ to this value.
        /// </summary>
        [Input("diffservcodeForward")]
        public Input<string>? DiffservcodeForward { get; set; }

        /// <summary>
        /// Change packet's reverse (reply) DiffServ to this value.
        /// </summary>
        [Input("diffservcodeRev")]
        public Input<string>? DiffservcodeRev { get; set; }

        /// <summary>
        /// Enable/disable user authentication disclaimer. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("disclaimer")]
        public Input<string>? Disclaimer { get; set; }

        /// <summary>
        /// Name of an existing DLP profile.
        /// </summary>
        [Input("dlpProfile")]
        public Input<string>? DlpProfile { get; set; }

        /// <summary>
        /// Name of an existing DLP sensor.
        /// </summary>
        [Input("dlpSensor")]
        public Input<string>? DlpSensor { get; set; }

        /// <summary>
        /// Name of an existing DNS filter profile.
        /// </summary>
        [Input("dnsfilterProfile")]
        public Input<string>? DnsfilterProfile { get; set; }

        /// <summary>
        /// Enable DSRI to ignore HTTP server responses. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("dsri")]
        public Input<string>? Dsri { get; set; }

        /// <summary>
        /// When enabled dstaddr6 specifies what the destination address must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("dstaddr6Negate")]
        public Input<string>? Dstaddr6Negate { get; set; }

        [Input("dstaddr6s")]
        private InputList<Inputs.PolicyDstaddr6Args>? _dstaddr6s;

        /// <summary>
        /// Destination IPv6 address name and address group names. The structure of `dstaddr6` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyDstaddr6Args> Dstaddr6s
        {
            get => _dstaddr6s ?? (_dstaddr6s = new InputList<Inputs.PolicyDstaddr6Args>());
            set => _dstaddr6s = value;
        }

        /// <summary>
        /// When enabled dstaddr specifies what the destination address must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("dstaddrNegate")]
        public Input<string>? DstaddrNegate { get; set; }

        [Input("dstaddrs")]
        private InputList<Inputs.PolicyDstaddrArgs>? _dstaddrs;

        /// <summary>
        /// Destination address and address group names. The structure of `dstaddr` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyDstaddrArgs> Dstaddrs
        {
            get => _dstaddrs ?? (_dstaddrs = new InputList<Inputs.PolicyDstaddrArgs>());
            set => _dstaddrs = value;
        }

        [Input("dstintfs", required: true)]
        private InputList<Inputs.PolicyDstintfArgs>? _dstintfs;

        /// <summary>
        /// Outgoing (egress) interface. The structure of `dstintf` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyDstintfArgs> Dstintfs
        {
            get => _dstintfs ?? (_dstintfs = new InputList<Inputs.PolicyDstintfArgs>());
            set => _dstintfs = value;
        }

        /// <summary>
        /// Enable/disable dynamic RADIUS defined traffic shaping. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("dynamicShaping")]
        public Input<string>? DynamicShaping { get; set; }

        /// <summary>
        /// Sort sub-tables, please do not set this parameter when configuring static sub-tables. Options: [ false, true, natural, alphabetical ]. false: Default value, do not sort tables; true/natural: sort tables in natural order. For example: [ a10, a2 ] -&gt; [ a2, a10 ]; alphabetical: sort tables in alphabetical order. For example: [ a10, a2 ] -&gt; [ a10, a2 ].
        /// </summary>
        [Input("dynamicSortSubtable")]
        public Input<string>? DynamicSortSubtable { get; set; }

        /// <summary>
        /// Enable/disable email collection. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("emailCollect")]
        public Input<string>? EmailCollect { get; set; }

        /// <summary>
        /// Name of an existing email filter profile.
        /// </summary>
        [Input("emailfilterProfile")]
        public Input<string>? EmailfilterProfile { get; set; }

        /// <summary>
        /// Enable/disable Forward Error Correction on traffic matching this policy on a FEC device. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("fec")]
        public Input<string>? Fec { get; set; }

        /// <summary>
        /// Name of an existing file-filter profile.
        /// </summary>
        [Input("fileFilterProfile")]
        public Input<string>? FileFilterProfile { get; set; }

        /// <summary>
        /// How to handle sessions if the configuration of this firewall policy changes. Valid values: `check-all`, `check-new`.
        /// </summary>
        [Input("firewallSessionDirty")]
        public Input<string>? FirewallSessionDirty { get; set; }

        /// <summary>
        /// Enable to prevent source NAT from changing a session's source port. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("fixedport")]
        public Input<string>? Fixedport { get; set; }

        /// <summary>
        /// Enable/disable Fortinet Single Sign-On. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("fsso")]
        public Input<string>? Fsso { get; set; }

        /// <summary>
        /// FSSO agent to use for NTLM authentication.
        /// </summary>
        [Input("fssoAgentForNtlm")]
        public Input<string>? FssoAgentForNtlm { get; set; }

        [Input("fssoGroups")]
        private InputList<Inputs.PolicyFssoGroupArgs>? _fssoGroups;

        /// <summary>
        /// Names of FSSO groups. The structure of `fsso_groups` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyFssoGroupArgs> FssoGroups
        {
            get => _fssoGroups ?? (_fssoGroups = new InputList<Inputs.PolicyFssoGroupArgs>());
            set => _fssoGroups = value;
        }

        /// <summary>
        /// Enable/disable recognition of anycast IP addresses using the geography IP database. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("geoipAnycast")]
        public Input<string>? GeoipAnycast { get; set; }

        /// <summary>
        /// Match geography address based either on its physical location or registered location. Valid values: `physical-location`, `registered-location`.
        /// </summary>
        [Input("geoipMatch")]
        public Input<string>? GeoipMatch { get; set; }

        /// <summary>
        /// Get all sub-tables including unconfigured tables. Do not set this variable to true if you configure sub-table in another resource, otherwish conflicts and overwrite will occur. Options: [ false, true ]. false: Default value, do not get unconfigured tables; true: get all tables including unconfigured tables.
        /// </summary>
        [Input("getAllTables")]
        public Input<string>? GetAllTables { get; set; }

        /// <summary>
        /// Label for the policy that appears when the GUI is in Global View mode.
        /// </summary>
        [Input("globalLabel")]
        public Input<string>? GlobalLabel { get; set; }

        [Input("groups")]
        private InputList<Inputs.PolicyGroupArgs>? _groups;

        /// <summary>
        /// Names of user groups that can authenticate with this policy. The structure of `groups` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyGroupArgs> Groups
        {
            get => _groups ?? (_groups = new InputList<Inputs.PolicyGroupArgs>());
            set => _groups = value;
        }

        /// <summary>
        /// Redirect HTTP(S) traffic to matching transparent web proxy policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("httpPolicyRedirect")]
        public Input<string>? HttpPolicyRedirect { get; set; }

        /// <summary>
        /// Name of an existing ICAP profile.
        /// </summary>
        [Input("icapProfile")]
        public Input<string>? IcapProfile { get; set; }

        /// <summary>
        /// Name of identity-based routing rule.
        /// </summary>
        [Input("identityBasedRoute")]
        public Input<string>? IdentityBasedRoute { get; set; }

        /// <summary>
        /// Policy-based IPsec VPN: only traffic from the remote network can initiate a VPN. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("inbound")]
        public Input<string>? Inbound { get; set; }

        /// <summary>
        /// Policy inspection mode (Flow/proxy). Default is Flow mode. Valid values: `proxy`, `flow`.
        /// </summary>
        [Input("inspectionMode")]
        public Input<string>? InspectionMode { get; set; }

        /// <summary>
        /// Enable/disable use of Internet Services for this policy. If enabled, destination address and service are not used.  Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetService")]
        public Input<string>? InternetService { get; set; }

        /// <summary>
        /// Enable/disable use of IPv6 Internet Services for this policy. If enabled, destination address and service are not used. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetService6")]
        public Input<string>? InternetService6 { get; set; }

        [Input("internetService6CustomGroups")]
        private InputList<Inputs.PolicyInternetService6CustomGroupArgs>? _internetService6CustomGroups;

        /// <summary>
        /// Custom Internet Service6 group name. The structure of `internet_service6_custom_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6CustomGroupArgs> InternetService6CustomGroups
        {
            get => _internetService6CustomGroups ?? (_internetService6CustomGroups = new InputList<Inputs.PolicyInternetService6CustomGroupArgs>());
            set => _internetService6CustomGroups = value;
        }

        [Input("internetService6Customs")]
        private InputList<Inputs.PolicyInternetService6CustomArgs>? _internetService6Customs;

        /// <summary>
        /// Custom IPv6 Internet Service name. The structure of `internet_service6_custom` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6CustomArgs> InternetService6Customs
        {
            get => _internetService6Customs ?? (_internetService6Customs = new InputList<Inputs.PolicyInternetService6CustomArgs>());
            set => _internetService6Customs = value;
        }

        [Input("internetService6Groups")]
        private InputList<Inputs.PolicyInternetService6GroupArgs>? _internetService6Groups;

        /// <summary>
        /// Internet Service group name. The structure of `internet_service6_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6GroupArgs> InternetService6Groups
        {
            get => _internetService6Groups ?? (_internetService6Groups = new InputList<Inputs.PolicyInternetService6GroupArgs>());
            set => _internetService6Groups = value;
        }

        [Input("internetService6Names")]
        private InputList<Inputs.PolicyInternetService6NameArgs>? _internetService6Names;

        /// <summary>
        /// IPv6 Internet Service name. The structure of `internet_service6_name` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6NameArgs> InternetService6Names
        {
            get => _internetService6Names ?? (_internetService6Names = new InputList<Inputs.PolicyInternetService6NameArgs>());
            set => _internetService6Names = value;
        }

        /// <summary>
        /// When enabled internet-service6 specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetService6Negate")]
        public Input<string>? InternetService6Negate { get; set; }

        /// <summary>
        /// Enable/disable use of IPv6 Internet Services in source for this policy. If enabled, source address is not used. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetService6Src")]
        public Input<string>? InternetService6Src { get; set; }

        [Input("internetService6SrcCustomGroups")]
        private InputList<Inputs.PolicyInternetService6SrcCustomGroupArgs>? _internetService6SrcCustomGroups;

        /// <summary>
        /// Custom Internet Service6 source group name. The structure of `internet_service6_src_custom_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6SrcCustomGroupArgs> InternetService6SrcCustomGroups
        {
            get => _internetService6SrcCustomGroups ?? (_internetService6SrcCustomGroups = new InputList<Inputs.PolicyInternetService6SrcCustomGroupArgs>());
            set => _internetService6SrcCustomGroups = value;
        }

        [Input("internetService6SrcCustoms")]
        private InputList<Inputs.PolicyInternetService6SrcCustomArgs>? _internetService6SrcCustoms;

        /// <summary>
        /// Custom IPv6 Internet Service source name. The structure of `internet_service6_src_custom` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6SrcCustomArgs> InternetService6SrcCustoms
        {
            get => _internetService6SrcCustoms ?? (_internetService6SrcCustoms = new InputList<Inputs.PolicyInternetService6SrcCustomArgs>());
            set => _internetService6SrcCustoms = value;
        }

        [Input("internetService6SrcGroups")]
        private InputList<Inputs.PolicyInternetService6SrcGroupArgs>? _internetService6SrcGroups;

        /// <summary>
        /// Internet Service6 source group name. The structure of `internet_service6_src_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6SrcGroupArgs> InternetService6SrcGroups
        {
            get => _internetService6SrcGroups ?? (_internetService6SrcGroups = new InputList<Inputs.PolicyInternetService6SrcGroupArgs>());
            set => _internetService6SrcGroups = value;
        }

        [Input("internetService6SrcNames")]
        private InputList<Inputs.PolicyInternetService6SrcNameArgs>? _internetService6SrcNames;

        /// <summary>
        /// IPv6 Internet Service source name. The structure of `internet_service6_src_name` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6SrcNameArgs> InternetService6SrcNames
        {
            get => _internetService6SrcNames ?? (_internetService6SrcNames = new InputList<Inputs.PolicyInternetService6SrcNameArgs>());
            set => _internetService6SrcNames = value;
        }

        /// <summary>
        /// When enabled internet-service6-src specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetService6SrcNegate")]
        public Input<string>? InternetService6SrcNegate { get; set; }

        [Input("internetServiceCustomGroups")]
        private InputList<Inputs.PolicyInternetServiceCustomGroupArgs>? _internetServiceCustomGroups;

        /// <summary>
        /// Custom Internet Service group name. The structure of `internet_service_custom_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceCustomGroupArgs> InternetServiceCustomGroups
        {
            get => _internetServiceCustomGroups ?? (_internetServiceCustomGroups = new InputList<Inputs.PolicyInternetServiceCustomGroupArgs>());
            set => _internetServiceCustomGroups = value;
        }

        [Input("internetServiceCustoms")]
        private InputList<Inputs.PolicyInternetServiceCustomArgs>? _internetServiceCustoms;

        /// <summary>
        /// Custom Internet Service name. The structure of `internet_service_custom` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceCustomArgs> InternetServiceCustoms
        {
            get => _internetServiceCustoms ?? (_internetServiceCustoms = new InputList<Inputs.PolicyInternetServiceCustomArgs>());
            set => _internetServiceCustoms = value;
        }

        [Input("internetServiceGroups")]
        private InputList<Inputs.PolicyInternetServiceGroupArgs>? _internetServiceGroups;

        /// <summary>
        /// Internet Service group name. The structure of `internet_service_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceGroupArgs> InternetServiceGroups
        {
            get => _internetServiceGroups ?? (_internetServiceGroups = new InputList<Inputs.PolicyInternetServiceGroupArgs>());
            set => _internetServiceGroups = value;
        }

        [Input("internetServiceIds")]
        private InputList<Inputs.PolicyInternetServiceIdArgs>? _internetServiceIds;

        /// <summary>
        /// Internet Service ID. The structure of `internet_service_id` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceIdArgs> InternetServiceIds
        {
            get => _internetServiceIds ?? (_internetServiceIds = new InputList<Inputs.PolicyInternetServiceIdArgs>());
            set => _internetServiceIds = value;
        }

        [Input("internetServiceNames")]
        private InputList<Inputs.PolicyInternetServiceNameArgs>? _internetServiceNames;

        /// <summary>
        /// Internet Service name. The structure of `internet_service_name` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceNameArgs> InternetServiceNames
        {
            get => _internetServiceNames ?? (_internetServiceNames = new InputList<Inputs.PolicyInternetServiceNameArgs>());
            set => _internetServiceNames = value;
        }

        /// <summary>
        /// When enabled internet-service specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetServiceNegate")]
        public Input<string>? InternetServiceNegate { get; set; }

        /// <summary>
        /// Enable/disable use of Internet Services in source for this policy. If enabled, source address is not used.  Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetServiceSrc")]
        public Input<string>? InternetServiceSrc { get; set; }

        [Input("internetServiceSrcCustomGroups")]
        private InputList<Inputs.PolicyInternetServiceSrcCustomGroupArgs>? _internetServiceSrcCustomGroups;

        /// <summary>
        /// Custom Internet Service source group name. The structure of `internet_service_src_custom_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceSrcCustomGroupArgs> InternetServiceSrcCustomGroups
        {
            get => _internetServiceSrcCustomGroups ?? (_internetServiceSrcCustomGroups = new InputList<Inputs.PolicyInternetServiceSrcCustomGroupArgs>());
            set => _internetServiceSrcCustomGroups = value;
        }

        [Input("internetServiceSrcCustoms")]
        private InputList<Inputs.PolicyInternetServiceSrcCustomArgs>? _internetServiceSrcCustoms;

        /// <summary>
        /// Custom Internet Service source name. The structure of `internet_service_src_custom` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceSrcCustomArgs> InternetServiceSrcCustoms
        {
            get => _internetServiceSrcCustoms ?? (_internetServiceSrcCustoms = new InputList<Inputs.PolicyInternetServiceSrcCustomArgs>());
            set => _internetServiceSrcCustoms = value;
        }

        [Input("internetServiceSrcGroups")]
        private InputList<Inputs.PolicyInternetServiceSrcGroupArgs>? _internetServiceSrcGroups;

        /// <summary>
        /// Internet Service source group name. The structure of `internet_service_src_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceSrcGroupArgs> InternetServiceSrcGroups
        {
            get => _internetServiceSrcGroups ?? (_internetServiceSrcGroups = new InputList<Inputs.PolicyInternetServiceSrcGroupArgs>());
            set => _internetServiceSrcGroups = value;
        }

        [Input("internetServiceSrcIds")]
        private InputList<Inputs.PolicyInternetServiceSrcIdArgs>? _internetServiceSrcIds;

        /// <summary>
        /// Internet Service source ID. The structure of `internet_service_src_id` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceSrcIdArgs> InternetServiceSrcIds
        {
            get => _internetServiceSrcIds ?? (_internetServiceSrcIds = new InputList<Inputs.PolicyInternetServiceSrcIdArgs>());
            set => _internetServiceSrcIds = value;
        }

        [Input("internetServiceSrcNames")]
        private InputList<Inputs.PolicyInternetServiceSrcNameArgs>? _internetServiceSrcNames;

        /// <summary>
        /// Internet Service source name. The structure of `internet_service_src_name` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceSrcNameArgs> InternetServiceSrcNames
        {
            get => _internetServiceSrcNames ?? (_internetServiceSrcNames = new InputList<Inputs.PolicyInternetServiceSrcNameArgs>());
            set => _internetServiceSrcNames = value;
        }

        /// <summary>
        /// When enabled internet-service-src specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetServiceSrcNegate")]
        public Input<string>? InternetServiceSrcNegate { get; set; }

        /// <summary>
        /// Enable to use IP Pools for source NAT. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("ippool")]
        public Input<string>? Ippool { get; set; }

        /// <summary>
        /// Name of an existing IPS sensor.
        /// </summary>
        [Input("ipsSensor")]
        public Input<string>? IpsSensor { get; set; }

        /// <summary>
        /// Name of an existing VoIP (ips) profile.
        /// </summary>
        [Input("ipsVoipFilter")]
        public Input<string>? IpsVoipFilter { get; set; }

        /// <summary>
        /// Label for the policy that appears when the GUI is in Section View mode.
        /// </summary>
        [Input("label")]
        public Input<string>? Label { get; set; }

        /// <summary>
        /// Enable to allow everything, but log all of the meaningful data for security information gathering. A learning report will be generated. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("learningMode")]
        public Input<string>? LearningMode { get; set; }

        /// <summary>
        /// Enable or disable logging. Log all sessions or security profile sessions. Valid values: `all`, `utm`, `disable`.
        /// </summary>
        [Input("logtraffic")]
        public Input<string>? Logtraffic { get; set; }

        /// <summary>
        /// Record logs when a session starts. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("logtrafficStart")]
        public Input<string>? LogtrafficStart { get; set; }

        /// <summary>
        /// Enable to match packets that have had their destination addresses changed by a VIP. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("matchVip")]
        public Input<string>? MatchVip { get; set; }

        /// <summary>
        /// Enable/disable matching of only those packets that have had their destination addresses changed by a VIP. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("matchVipOnly")]
        public Input<string>? MatchVipOnly { get; set; }

        /// <summary>
        /// Policy name.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Enable/disable source NAT. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("nat")]
        public Input<string>? Nat { get; set; }

        /// <summary>
        /// Enable/disable NAT46. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("nat46")]
        public Input<string>? Nat46 { get; set; }

        /// <summary>
        /// Enable/disable NAT64. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("nat64")]
        public Input<string>? Nat64 { get; set; }

        /// <summary>
        /// Policy-based IPsec VPN: apply destination NAT to inbound traffic. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("natinbound")]
        public Input<string>? Natinbound { get; set; }

        /// <summary>
        /// Policy-based IPsec VPN: source NAT IP address for outgoing traffic.
        /// </summary>
        [Input("natip")]
        public Input<string>? Natip { get; set; }

        /// <summary>
        /// Policy-based IPsec VPN: apply source NAT to outbound traffic. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("natoutbound")]
        public Input<string>? Natoutbound { get; set; }

        [Input("networkServiceDynamics")]
        private InputList<Inputs.PolicyNetworkServiceDynamicArgs>? _networkServiceDynamics;

        /// <summary>
        /// Dynamic Network Service name. The structure of `network_service_dynamic` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyNetworkServiceDynamicArgs> NetworkServiceDynamics
        {
            get => _networkServiceDynamics ?? (_networkServiceDynamics = new InputList<Inputs.PolicyNetworkServiceDynamicArgs>());
            set => _networkServiceDynamics = value;
        }

        [Input("networkServiceSrcDynamics")]
        private InputList<Inputs.PolicyNetworkServiceSrcDynamicArgs>? _networkServiceSrcDynamics;

        /// <summary>
        /// Dynamic Network Service source name. The structure of `network_service_src_dynamic` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyNetworkServiceSrcDynamicArgs> NetworkServiceSrcDynamics
        {
            get => _networkServiceSrcDynamics ?? (_networkServiceSrcDynamics = new InputList<Inputs.PolicyNetworkServiceSrcDynamicArgs>());
            set => _networkServiceSrcDynamics = value;
        }

        /// <summary>
        /// Enable/disable UTM Network Processor acceleration. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("npAcceleration")]
        public Input<string>? NpAcceleration { get; set; }

        /// <summary>
        /// Enable/disable NTLM authentication. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("ntlm")]
        public Input<string>? Ntlm { get; set; }

        [Input("ntlmEnabledBrowsers")]
        private InputList<Inputs.PolicyNtlmEnabledBrowserArgs>? _ntlmEnabledBrowsers;

        /// <summary>
        /// HTTP-User-Agent value of supported browsers. The structure of `ntlm_enabled_browsers` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyNtlmEnabledBrowserArgs> NtlmEnabledBrowsers
        {
            get => _ntlmEnabledBrowsers ?? (_ntlmEnabledBrowsers = new InputList<Inputs.PolicyNtlmEnabledBrowserArgs>());
            set => _ntlmEnabledBrowsers = value;
        }

        /// <summary>
        /// Enable/disable NTLM guest user access. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("ntlmGuest")]
        public Input<string>? NtlmGuest { get; set; }

        /// <summary>
        /// Policy-based IPsec VPN: only traffic from the internal network can initiate a VPN. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("outbound")]
        public Input<string>? Outbound { get; set; }

        /// <summary>
        /// Enable/disable passive WAN health measurement. When enabled, auto-asic-offload is disabled. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("passiveWanHealthMeasurement")]
        public Input<string>? PassiveWanHealthMeasurement { get; set; }

        /// <summary>
        /// Enable/disable PCP inbound DNAT. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("pcpInbound")]
        public Input<string>? PcpInbound { get; set; }

        /// <summary>
        /// Enable/disable PCP outbound SNAT. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("pcpOutbound")]
        public Input<string>? PcpOutbound { get; set; }

        [Input("pcpPoolnames")]
        private InputList<Inputs.PolicyPcpPoolnameArgs>? _pcpPoolnames;

        /// <summary>
        /// PCP pool names. The structure of `pcp_poolname` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyPcpPoolnameArgs> PcpPoolnames
        {
            get => _pcpPoolnames ?? (_pcpPoolnames = new InputList<Inputs.PolicyPcpPoolnameArgs>());
            set => _pcpPoolnames = value;
        }

        /// <summary>
        /// Per-IP traffic shaper.
        /// </summary>
        [Input("perIpShaper")]
        public Input<string>? PerIpShaper { get; set; }

        /// <summary>
        /// Accept UDP packets from any host. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("permitAnyHost")]
        public Input<string>? PermitAnyHost { get; set; }

        /// <summary>
        /// Accept UDP packets from any Session Traversal Utilities for NAT (STUN) host. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("permitStunHost")]
        public Input<string>? PermitStunHost { get; set; }

        /// <summary>
        /// Enable/disable policy expiry. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("policyExpiry")]
        public Input<string>? PolicyExpiry { get; set; }

        /// <summary>
        /// Policy expiry date (YYYY-MM-DD HH:MM:SS).
        /// </summary>
        [Input("policyExpiryDate")]
        public Input<string>? PolicyExpiryDate { get; set; }

        /// <summary>
        /// Policy expiry date and time, in epoch format.
        /// </summary>
        [Input("policyExpiryDateUtc")]
        public Input<string>? PolicyExpiryDateUtc { get; set; }

        /// <summary>
        /// Policy ID.
        /// </summary>
        [Input("policyid")]
        public Input<int>? Policyid { get; set; }

        [Input("poolname6s")]
        private InputList<Inputs.PolicyPoolname6Args>? _poolname6s;

        /// <summary>
        /// IPv6 pool names. The structure of `poolname6` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyPoolname6Args> Poolname6s
        {
            get => _poolname6s ?? (_poolname6s = new InputList<Inputs.PolicyPoolname6Args>());
            set => _poolname6s = value;
        }

        [Input("poolnames")]
        private InputList<Inputs.PolicyPoolnameArgs>? _poolnames;

        /// <summary>
        /// IP Pool names. The structure of `poolname` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyPoolnameArgs> Poolnames
        {
            get => _poolnames ?? (_poolnames = new InputList<Inputs.PolicyPoolnameArgs>());
            set => _poolnames = value;
        }

        /// <summary>
        /// Name of profile group.
        /// </summary>
        [Input("profileGroup")]
        public Input<string>? ProfileGroup { get; set; }

        /// <summary>
        /// Name of an existing Protocol options profile.
        /// </summary>
        [Input("profileProtocolOptions")]
        public Input<string>? ProfileProtocolOptions { get; set; }

        /// <summary>
        /// Determine whether the firewall policy allows security profile groups or single profiles only. Valid values: `single`, `group`.
        /// </summary>
        [Input("profileType")]
        public Input<string>? ProfileType { get; set; }

        /// <summary>
        /// Enable MAC authentication bypass. The bypassed MAC address must be received from RADIUS server. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("radiusMacAuthBypass")]
        public Input<string>? RadiusMacAuthBypass { get; set; }

        /// <summary>
        /// URL users are directed to after seeing and accepting the disclaimer or authenticating.
        /// </summary>
        [Input("redirectUrl")]
        public Input<string>? RedirectUrl { get; set; }

        /// <summary>
        /// Override the default replacement message group for this policy.
        /// </summary>
        [Input("replacemsgOverrideGroup")]
        public Input<string>? ReplacemsgOverrideGroup { get; set; }

        /// <summary>
        /// Direction of the initial traffic for reputation to take effect. Valid values: `source`, `destination`.
        /// </summary>
        [Input("reputationDirection")]
        public Input<string>? ReputationDirection { get; set; }

        /// <summary>
        /// Direction of the initial traffic for IPv6 reputation to take effect. Valid values: `source`, `destination`.
        /// </summary>
        [Input("reputationDirection6")]
        public Input<string>? ReputationDirection6 { get; set; }

        /// <summary>
        /// Minimum Reputation to take action.
        /// </summary>
        [Input("reputationMinimum")]
        public Input<int>? ReputationMinimum { get; set; }

        /// <summary>
        /// IPv6 Minimum Reputation to take action.
        /// </summary>
        [Input("reputationMinimum6")]
        public Input<int>? ReputationMinimum6 { get; set; }

        /// <summary>
        /// Enable/disable RADIUS single sign-on (RSSO). Valid values: `enable`, `disable`.
        /// </summary>
        [Input("rsso")]
        public Input<string>? Rsso { get; set; }

        [Input("rtpAddrs")]
        private InputList<Inputs.PolicyRtpAddrArgs>? _rtpAddrs;

        /// <summary>
        /// Address names if this is an RTP NAT policy. The structure of `rtp_addr` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyRtpAddrArgs> RtpAddrs
        {
            get => _rtpAddrs ?? (_rtpAddrs = new InputList<Inputs.PolicyRtpAddrArgs>());
            set => _rtpAddrs = value;
        }

        /// <summary>
        /// Enable Real Time Protocol (RTP) NAT. Valid values: `disable`, `enable`.
        /// </summary>
        [Input("rtpNat")]
        public Input<string>? RtpNat { get; set; }

        /// <summary>
        /// Block or monitor connections to Botnet servers or disable Botnet scanning. Valid values: `disable`, `block`, `monitor`.
        /// </summary>
        [Input("scanBotnetConnections")]
        public Input<string>? ScanBotnetConnections { get; set; }

        /// <summary>
        /// Schedule name.(Default is `always`)
        /// </summary>
        [Input("schedule")]
        public Input<string>? Schedule { get; set; }

        /// <summary>
        /// Enable to force current sessions to end when the schedule object times out. Disable allows them to end from inactivity. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("scheduleTimeout")]
        public Input<string>? ScheduleTimeout { get; set; }

        /// <summary>
        /// Name of an existing SCTP filter profile.
        /// </summary>
        [Input("sctpFilterProfile")]
        public Input<string>? SctpFilterProfile { get; set; }

        /// <summary>
        /// Enable to send a reply when a session is denied or blocked by a firewall policy. Valid values: `disable`, `enable`.
        /// </summary>
        [Input("sendDenyPacket")]
        public Input<string>? SendDenyPacket { get; set; }

        /// <summary>
        /// When enabled service specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("serviceNegate")]
        public Input<string>? ServiceNegate { get; set; }

        [Input("services")]
        private InputList<Inputs.PolicyServiceArgs>? _services;

        /// <summary>
        /// Service and service group names. The structure of `service` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyServiceArgs> Services
        {
            get => _services ?? (_services = new InputList<Inputs.PolicyServiceArgs>());
            set => _services = value;
        }

        /// <summary>
        /// TTL in seconds for sessions accepted by this policy (0 means use the system default session TTL).
        /// </summary>
        [Input("sessionTtl")]
        public Input<int>? SessionTtl { get; set; }

        /// <summary>
        /// Enable/disable security group tags (SGT) check. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("sgtCheck")]
        public Input<string>? SgtCheck { get; set; }

        [Input("sgts")]
        private InputList<Inputs.PolicySgtArgs>? _sgts;

        /// <summary>
        /// Security group tags. The structure of `sgt` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicySgtArgs> Sgts
        {
            get => _sgts ?? (_sgts = new InputList<Inputs.PolicySgtArgs>());
            set => _sgts = value;
        }

        /// <summary>
        /// Name of an existing Spam filter profile.
        /// </summary>
        [Input("spamfilterProfile")]
        public Input<string>? SpamfilterProfile { get; set; }

        [Input("srcVendorMacs")]
        private InputList<Inputs.PolicySrcVendorMacArgs>? _srcVendorMacs;

        /// <summary>
        /// Vendor MAC source ID. The structure of `src_vendor_mac` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicySrcVendorMacArgs> SrcVendorMacs
        {
            get => _srcVendorMacs ?? (_srcVendorMacs = new InputList<Inputs.PolicySrcVendorMacArgs>());
            set => _srcVendorMacs = value;
        }

        /// <summary>
        /// When enabled srcaddr6 specifies what the source address must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("srcaddr6Negate")]
        public Input<string>? Srcaddr6Negate { get; set; }

        [Input("srcaddr6s")]
        private InputList<Inputs.PolicySrcaddr6Args>? _srcaddr6s;

        /// <summary>
        /// Source IPv6 address name and address group names. The structure of `srcaddr6` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicySrcaddr6Args> Srcaddr6s
        {
            get => _srcaddr6s ?? (_srcaddr6s = new InputList<Inputs.PolicySrcaddr6Args>());
            set => _srcaddr6s = value;
        }

        /// <summary>
        /// When enabled srcaddr specifies what the source address must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("srcaddrNegate")]
        public Input<string>? SrcaddrNegate { get; set; }

        [Input("srcaddrs")]
        private InputList<Inputs.PolicySrcaddrArgs>? _srcaddrs;

        /// <summary>
        /// Source address and address group names. The structure of `srcaddr` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicySrcaddrArgs> Srcaddrs
        {
            get => _srcaddrs ?? (_srcaddrs = new InputList<Inputs.PolicySrcaddrArgs>());
            set => _srcaddrs = value;
        }

        [Input("srcintfs", required: true)]
        private InputList<Inputs.PolicySrcintfArgs>? _srcintfs;

        /// <summary>
        /// Incoming (ingress) interface. The structure of `srcintf` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicySrcintfArgs> Srcintfs
        {
            get => _srcintfs ?? (_srcintfs = new InputList<Inputs.PolicySrcintfArgs>());
            set => _srcintfs = value;
        }

        /// <summary>
        /// Name of an existing SSH filter profile.
        /// </summary>
        [Input("sshFilterProfile")]
        public Input<string>? SshFilterProfile { get; set; }

        /// <summary>
        /// Redirect SSH traffic to matching transparent proxy policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("sshPolicyRedirect")]
        public Input<string>? SshPolicyRedirect { get; set; }

        /// <summary>
        /// Enable to copy decrypted SSL traffic to a FortiGate interface (called SSL mirroring). Valid values: `enable`, `disable`.
        /// </summary>
        [Input("sslMirror")]
        public Input<string>? SslMirror { get; set; }

        [Input("sslMirrorIntfs")]
        private InputList<Inputs.PolicySslMirrorIntfArgs>? _sslMirrorIntfs;

        /// <summary>
        /// SSL mirror interface name. The structure of `ssl_mirror_intf` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicySslMirrorIntfArgs> SslMirrorIntfs
        {
            get => _sslMirrorIntfs ?? (_sslMirrorIntfs = new InputList<Inputs.PolicySslMirrorIntfArgs>());
            set => _sslMirrorIntfs = value;
        }

        /// <summary>
        /// Name of an existing SSL SSH profile.
        /// </summary>
        [Input("sslSshProfile")]
        public Input<string>? SslSshProfile { get; set; }

        /// <summary>
        /// Enable or disable this policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("status")]
        public Input<string>? Status { get; set; }

        /// <summary>
        /// Receiver TCP maximum segment size (MSS).
        /// </summary>
        [Input("tcpMssReceiver")]
        public Input<int>? TcpMssReceiver { get; set; }

        /// <summary>
        /// Sender TCP maximum segment size (MSS).
        /// </summary>
        [Input("tcpMssSender")]
        public Input<int>? TcpMssSender { get; set; }

        /// <summary>
        /// Enable/disable creation of TCP session without SYN flag. Valid values: `all`, `data-only`, `disable`.
        /// </summary>
        [Input("tcpSessionWithoutSyn")]
        public Input<string>? TcpSessionWithoutSyn { get; set; }

        /// <summary>
        /// Enable/disable sending RST packets when TCP sessions expire. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("timeoutSendRst")]
        public Input<string>? TimeoutSendRst { get; set; }

        /// <summary>
        /// ToS (Type of Service) value used for comparison.
        /// </summary>
        [Input("tos")]
        public Input<string>? Tos { get; set; }

        /// <summary>
        /// Non-zero bit positions are used for comparison while zero bit positions are ignored.
        /// </summary>
        [Input("tosMask")]
        public Input<string>? TosMask { get; set; }

        /// <summary>
        /// Enable negated TOS match. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("tosNegate")]
        public Input<string>? TosNegate { get; set; }

        /// <summary>
        /// Traffic shaper.
        /// </summary>
        [Input("trafficShaper")]
        public Input<string>? TrafficShaper { get; set; }

        /// <summary>
        /// Reverse traffic shaper.
        /// </summary>
        [Input("trafficShaperReverse")]
        public Input<string>? TrafficShaperReverse { get; set; }

        [Input("urlCategories")]
        private InputList<Inputs.PolicyUrlCategoryArgs>? _urlCategories;

        /// <summary>
        /// URL category ID list. The structure of `url_category` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyUrlCategoryArgs> UrlCategories
        {
            get => _urlCategories ?? (_urlCategories = new InputList<Inputs.PolicyUrlCategoryArgs>());
            set => _urlCategories = value;
        }

        [Input("users")]
        private InputList<Inputs.PolicyUserArgs>? _users;

        /// <summary>
        /// Names of individual users that can authenticate with this policy. The structure of `users` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyUserArgs> Users
        {
            get => _users ?? (_users = new InputList<Inputs.PolicyUserArgs>());
            set => _users = value;
        }

        /// <summary>
        /// Enable to add one or more security profiles (AV, IPS, etc.) to the firewall policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("utmStatus")]
        public Input<string>? UtmStatus { get; set; }

        /// <summary>
        /// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
        /// </summary>
        [Input("uuid")]
        public Input<string>? Uuid { get; set; }

        /// <summary>
        /// Specifies the vdom to which the resource will be applied when the FortiGate unit is running in VDOM mode. Only one vdom can be specified. If you want to inherit the vdom configuration of the provider, please do not set this parameter.
        /// </summary>
        [Input("vdomparam")]
        public Input<string>? Vdomparam { get; set; }

        /// <summary>
        /// Name of an existing VideoFilter profile.
        /// </summary>
        [Input("videofilterProfile")]
        public Input<string>? VideofilterProfile { get; set; }

        /// <summary>
        /// Name of an existing virtual-patch profile.
        /// </summary>
        [Input("virtualPatchProfile")]
        public Input<string>? VirtualPatchProfile { get; set; }

        /// <summary>
        /// VLAN forward direction user priority: 255 passthrough, 0 lowest, 7 highest.
        /// </summary>
        [Input("vlanCosFwd")]
        public Input<int>? VlanCosFwd { get; set; }

        /// <summary>
        /// VLAN reverse direction user priority: 255 passthrough, 0 lowest, 7 highest.
        /// </summary>
        [Input("vlanCosRev")]
        public Input<int>? VlanCosRev { get; set; }

        /// <summary>
        /// Set VLAN filters.
        /// </summary>
        [Input("vlanFilter")]
        public Input<string>? VlanFilter { get; set; }

        /// <summary>
        /// Name of an existing VoIP (voipd) profile.
        /// </summary>
        [Input("voipProfile")]
        public Input<string>? VoipProfile { get; set; }

        /// <summary>
        /// Policy-based IPsec VPN: name of the IPsec VPN Phase 1.
        /// </summary>
        [Input("vpntunnel")]
        public Input<string>? Vpntunnel { get; set; }

        /// <summary>
        /// Name of an existing Web application firewall profile.
        /// </summary>
        [Input("wafProfile")]
        public Input<string>? WafProfile { get; set; }

        /// <summary>
        /// Enable/disable WAN optimization. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("wanopt")]
        public Input<string>? Wanopt { get; set; }

        /// <summary>
        /// WAN optimization auto-detection mode. Valid values: `active`, `passive`, `off`.
        /// </summary>
        [Input("wanoptDetection")]
        public Input<string>? WanoptDetection { get; set; }

        /// <summary>
        /// WAN optimization passive mode options. This option decides what IP address will be used to connect server. Valid values: `default`, `transparent`, `non-transparent`.
        /// </summary>
        [Input("wanoptPassiveOpt")]
        public Input<string>? WanoptPassiveOpt { get; set; }

        /// <summary>
        /// WAN optimization peer.
        /// </summary>
        [Input("wanoptPeer")]
        public Input<string>? WanoptPeer { get; set; }

        /// <summary>
        /// WAN optimization profile.
        /// </summary>
        [Input("wanoptProfile")]
        public Input<string>? WanoptProfile { get; set; }

        /// <summary>
        /// Enable/disable forwarding traffic matching this policy to a configured WCCP server. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("wccp")]
        public Input<string>? Wccp { get; set; }

        /// <summary>
        /// Enable/disable web cache. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("webcache")]
        public Input<string>? Webcache { get; set; }

        /// <summary>
        /// Enable/disable web cache for HTTPS. Valid values: `disable`, `enable`.
        /// </summary>
        [Input("webcacheHttps")]
        public Input<string>? WebcacheHttps { get; set; }

        /// <summary>
        /// Name of an existing Web filter profile.
        /// </summary>
        [Input("webfilterProfile")]
        public Input<string>? WebfilterProfile { get; set; }

        /// <summary>
        /// Web proxy forward server name.
        /// </summary>
        [Input("webproxyForwardServer")]
        public Input<string>? WebproxyForwardServer { get; set; }

        /// <summary>
        /// Webproxy profile name.
        /// </summary>
        [Input("webproxyProfile")]
        public Input<string>? WebproxyProfile { get; set; }

        /// <summary>
        /// Enable/disable WiFi Single Sign On (WSSO). Valid values: `enable`, `disable`.
        /// </summary>
        [Input("wsso")]
        public Input<string>? Wsso { get; set; }

        /// <summary>
        /// Enable/disable zero trust device ownership. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("ztnaDeviceOwnership")]
        public Input<string>? ZtnaDeviceOwnership { get; set; }

        [Input("ztnaEmsTagSecondaries")]
        private InputList<Inputs.PolicyZtnaEmsTagSecondaryArgs>? _ztnaEmsTagSecondaries;

        /// <summary>
        /// Source ztna-ems-tag-secondary names. The structure of `ztna_ems_tag_secondary` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyZtnaEmsTagSecondaryArgs> ZtnaEmsTagSecondaries
        {
            get => _ztnaEmsTagSecondaries ?? (_ztnaEmsTagSecondaries = new InputList<Inputs.PolicyZtnaEmsTagSecondaryArgs>());
            set => _ztnaEmsTagSecondaries = value;
        }

        [Input("ztnaEmsTags")]
        private InputList<Inputs.PolicyZtnaEmsTagArgs>? _ztnaEmsTags;

        /// <summary>
        /// Source ztna-ems-tag names. The structure of `ztna_ems_tag` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyZtnaEmsTagArgs> ZtnaEmsTags
        {
            get => _ztnaEmsTags ?? (_ztnaEmsTags = new InputList<Inputs.PolicyZtnaEmsTagArgs>());
            set => _ztnaEmsTags = value;
        }

        [Input("ztnaGeoTags")]
        private InputList<Inputs.PolicyZtnaGeoTagArgs>? _ztnaGeoTags;

        /// <summary>
        /// Source ztna-geo-tag names. The structure of `ztna_geo_tag` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyZtnaGeoTagArgs> ZtnaGeoTags
        {
            get => _ztnaGeoTags ?? (_ztnaGeoTags = new InputList<Inputs.PolicyZtnaGeoTagArgs>());
            set => _ztnaGeoTags = value;
        }

        /// <summary>
        /// Redirect ZTNA traffic to matching Access-Proxy proxy-policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("ztnaPolicyRedirect")]
        public Input<string>? ZtnaPolicyRedirect { get; set; }

        /// <summary>
        /// Enable/disable zero trust access. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("ztnaStatus")]
        public Input<string>? ZtnaStatus { get; set; }

        /// <summary>
        /// ZTNA tag matching logic. Valid values: `or`, `and`.
        /// </summary>
        [Input("ztnaTagsMatchLogic")]
        public Input<string>? ZtnaTagsMatchLogic { get; set; }

        public PolicyArgs()
        {
        }
        public static new PolicyArgs Empty => new PolicyArgs();
    }

    public sealed class PolicyState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Policy action. On FortiOS versions 6.2.0-6.4.0: allow/deny/ipsec. On FortiOS versions &gt;= 6.4.1: accept/deny/ipsec. Valid values: `accept`, `deny`, `ipsec`.
        /// </summary>
        [Input("action")]
        public Input<string>? Action { get; set; }

        /// <summary>
        /// Enable/disable anti-replay check. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("antiReplay")]
        public Input<string>? AntiReplay { get; set; }

        [Input("appCategories")]
        private InputList<Inputs.PolicyAppCategoryGetArgs>? _appCategories;

        /// <summary>
        /// Application category ID list. The structure of `app_category` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyAppCategoryGetArgs> AppCategories
        {
            get => _appCategories ?? (_appCategories = new InputList<Inputs.PolicyAppCategoryGetArgs>());
            set => _appCategories = value;
        }

        [Input("appGroups")]
        private InputList<Inputs.PolicyAppGroupGetArgs>? _appGroups;

        /// <summary>
        /// Application group names. The structure of `app_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyAppGroupGetArgs> AppGroups
        {
            get => _appGroups ?? (_appGroups = new InputList<Inputs.PolicyAppGroupGetArgs>());
            set => _appGroups = value;
        }

        /// <summary>
        /// Name of an existing Application list.
        /// </summary>
        [Input("applicationList")]
        public Input<string>? ApplicationList { get; set; }

        [Input("applications")]
        private InputList<Inputs.PolicyApplicationGetArgs>? _applications;

        /// <summary>
        /// Application ID list. The structure of `application` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyApplicationGetArgs> Applications
        {
            get => _applications ?? (_applications = new InputList<Inputs.PolicyApplicationGetArgs>());
            set => _applications = value;
        }

        /// <summary>
        /// HTTPS server certificate for policy authentication.
        /// </summary>
        [Input("authCert")]
        public Input<string>? AuthCert { get; set; }

        /// <summary>
        /// Enable/disable authentication-based routing. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("authPath")]
        public Input<string>? AuthPath { get; set; }

        /// <summary>
        /// HTTP-to-HTTPS redirect address for firewall authentication.
        /// </summary>
        [Input("authRedirectAddr")]
        public Input<string>? AuthRedirectAddr { get; set; }

        /// <summary>
        /// Enable/disable policy traffic ASIC offloading. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("autoAsicOffload")]
        public Input<string>? AutoAsicOffload { get; set; }

        /// <summary>
        /// Name of an existing Antivirus profile.
        /// </summary>
        [Input("avProfile")]
        public Input<string>? AvProfile { get; set; }

        /// <summary>
        /// Enable/disable block notification. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("blockNotification")]
        public Input<string>? BlockNotification { get; set; }

        /// <summary>
        /// Enable to exempt some users from the captive portal. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("captivePortalExempt")]
        public Input<string>? CaptivePortalExempt { get; set; }

        /// <summary>
        /// Enable/disable capture packets. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("capturePacket")]
        public Input<string>? CapturePacket { get; set; }

        /// <summary>
        /// Name of an existing CASB profile.
        /// </summary>
        [Input("casbProfile")]
        public Input<string>? CasbProfile { get; set; }

        /// <summary>
        /// Name of an existing CIFS profile.
        /// </summary>
        [Input("cifsProfile")]
        public Input<string>? CifsProfile { get; set; }

        /// <summary>
        /// Comment.
        /// </summary>
        [Input("comments")]
        public Input<string>? Comments { get; set; }

        [Input("customLogFields")]
        private InputList<Inputs.PolicyCustomLogFieldGetArgs>? _customLogFields;

        /// <summary>
        /// Custom fields to append to log messages for this policy. The structure of `custom_log_fields` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyCustomLogFieldGetArgs> CustomLogFields
        {
            get => _customLogFields ?? (_customLogFields = new InputList<Inputs.PolicyCustomLogFieldGetArgs>());
            set => _customLogFields = value;
        }

        /// <summary>
        /// Decrypted traffic mirror.
        /// </summary>
        [Input("decryptedTrafficMirror")]
        public Input<string>? DecryptedTrafficMirror { get; set; }

        /// <summary>
        /// Enable TCP NPU session delay to guarantee packet order of 3-way handshake. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("delayTcpNpuSession")]
        public Input<string>? DelayTcpNpuSession { get; set; }

        [Input("devices")]
        private InputList<Inputs.PolicyDeviceGetArgs>? _devices;

        /// <summary>
        /// Names of devices or device groups that can be matched by the policy. The structure of `devices` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyDeviceGetArgs> Devices
        {
            get => _devices ?? (_devices = new InputList<Inputs.PolicyDeviceGetArgs>());
            set => _devices = value;
        }

        /// <summary>
        /// Name of an existing Diameter filter profile.
        /// </summary>
        [Input("diameterFilterProfile")]
        public Input<string>? DiameterFilterProfile { get; set; }

        /// <summary>
        /// Enable to copy packet's DiffServ values from session's original direction to its reply direction. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("diffservCopy")]
        public Input<string>? DiffservCopy { get; set; }

        /// <summary>
        /// Enable to change packet's DiffServ values to the specified diffservcode-forward value. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("diffservForward")]
        public Input<string>? DiffservForward { get; set; }

        /// <summary>
        /// Enable to change packet's reverse (reply) DiffServ values to the specified diffservcode-rev value. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("diffservReverse")]
        public Input<string>? DiffservReverse { get; set; }

        /// <summary>
        /// Change packet's DiffServ to this value.
        /// </summary>
        [Input("diffservcodeForward")]
        public Input<string>? DiffservcodeForward { get; set; }

        /// <summary>
        /// Change packet's reverse (reply) DiffServ to this value.
        /// </summary>
        [Input("diffservcodeRev")]
        public Input<string>? DiffservcodeRev { get; set; }

        /// <summary>
        /// Enable/disable user authentication disclaimer. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("disclaimer")]
        public Input<string>? Disclaimer { get; set; }

        /// <summary>
        /// Name of an existing DLP profile.
        /// </summary>
        [Input("dlpProfile")]
        public Input<string>? DlpProfile { get; set; }

        /// <summary>
        /// Name of an existing DLP sensor.
        /// </summary>
        [Input("dlpSensor")]
        public Input<string>? DlpSensor { get; set; }

        /// <summary>
        /// Name of an existing DNS filter profile.
        /// </summary>
        [Input("dnsfilterProfile")]
        public Input<string>? DnsfilterProfile { get; set; }

        /// <summary>
        /// Enable DSRI to ignore HTTP server responses. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("dsri")]
        public Input<string>? Dsri { get; set; }

        /// <summary>
        /// When enabled dstaddr6 specifies what the destination address must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("dstaddr6Negate")]
        public Input<string>? Dstaddr6Negate { get; set; }

        [Input("dstaddr6s")]
        private InputList<Inputs.PolicyDstaddr6GetArgs>? _dstaddr6s;

        /// <summary>
        /// Destination IPv6 address name and address group names. The structure of `dstaddr6` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyDstaddr6GetArgs> Dstaddr6s
        {
            get => _dstaddr6s ?? (_dstaddr6s = new InputList<Inputs.PolicyDstaddr6GetArgs>());
            set => _dstaddr6s = value;
        }

        /// <summary>
        /// When enabled dstaddr specifies what the destination address must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("dstaddrNegate")]
        public Input<string>? DstaddrNegate { get; set; }

        [Input("dstaddrs")]
        private InputList<Inputs.PolicyDstaddrGetArgs>? _dstaddrs;

        /// <summary>
        /// Destination address and address group names. The structure of `dstaddr` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyDstaddrGetArgs> Dstaddrs
        {
            get => _dstaddrs ?? (_dstaddrs = new InputList<Inputs.PolicyDstaddrGetArgs>());
            set => _dstaddrs = value;
        }

        [Input("dstintfs")]
        private InputList<Inputs.PolicyDstintfGetArgs>? _dstintfs;

        /// <summary>
        /// Outgoing (egress) interface. The structure of `dstintf` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyDstintfGetArgs> Dstintfs
        {
            get => _dstintfs ?? (_dstintfs = new InputList<Inputs.PolicyDstintfGetArgs>());
            set => _dstintfs = value;
        }

        /// <summary>
        /// Enable/disable dynamic RADIUS defined traffic shaping. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("dynamicShaping")]
        public Input<string>? DynamicShaping { get; set; }

        /// <summary>
        /// Sort sub-tables, please do not set this parameter when configuring static sub-tables. Options: [ false, true, natural, alphabetical ]. false: Default value, do not sort tables; true/natural: sort tables in natural order. For example: [ a10, a2 ] -&gt; [ a2, a10 ]; alphabetical: sort tables in alphabetical order. For example: [ a10, a2 ] -&gt; [ a10, a2 ].
        /// </summary>
        [Input("dynamicSortSubtable")]
        public Input<string>? DynamicSortSubtable { get; set; }

        /// <summary>
        /// Enable/disable email collection. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("emailCollect")]
        public Input<string>? EmailCollect { get; set; }

        /// <summary>
        /// Name of an existing email filter profile.
        /// </summary>
        [Input("emailfilterProfile")]
        public Input<string>? EmailfilterProfile { get; set; }

        /// <summary>
        /// Enable/disable Forward Error Correction on traffic matching this policy on a FEC device. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("fec")]
        public Input<string>? Fec { get; set; }

        /// <summary>
        /// Name of an existing file-filter profile.
        /// </summary>
        [Input("fileFilterProfile")]
        public Input<string>? FileFilterProfile { get; set; }

        /// <summary>
        /// How to handle sessions if the configuration of this firewall policy changes. Valid values: `check-all`, `check-new`.
        /// </summary>
        [Input("firewallSessionDirty")]
        public Input<string>? FirewallSessionDirty { get; set; }

        /// <summary>
        /// Enable to prevent source NAT from changing a session's source port. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("fixedport")]
        public Input<string>? Fixedport { get; set; }

        /// <summary>
        /// Enable/disable Fortinet Single Sign-On. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("fsso")]
        public Input<string>? Fsso { get; set; }

        /// <summary>
        /// FSSO agent to use for NTLM authentication.
        /// </summary>
        [Input("fssoAgentForNtlm")]
        public Input<string>? FssoAgentForNtlm { get; set; }

        [Input("fssoGroups")]
        private InputList<Inputs.PolicyFssoGroupGetArgs>? _fssoGroups;

        /// <summary>
        /// Names of FSSO groups. The structure of `fsso_groups` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyFssoGroupGetArgs> FssoGroups
        {
            get => _fssoGroups ?? (_fssoGroups = new InputList<Inputs.PolicyFssoGroupGetArgs>());
            set => _fssoGroups = value;
        }

        /// <summary>
        /// Enable/disable recognition of anycast IP addresses using the geography IP database. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("geoipAnycast")]
        public Input<string>? GeoipAnycast { get; set; }

        /// <summary>
        /// Match geography address based either on its physical location or registered location. Valid values: `physical-location`, `registered-location`.
        /// </summary>
        [Input("geoipMatch")]
        public Input<string>? GeoipMatch { get; set; }

        /// <summary>
        /// Get all sub-tables including unconfigured tables. Do not set this variable to true if you configure sub-table in another resource, otherwish conflicts and overwrite will occur. Options: [ false, true ]. false: Default value, do not get unconfigured tables; true: get all tables including unconfigured tables.
        /// </summary>
        [Input("getAllTables")]
        public Input<string>? GetAllTables { get; set; }

        /// <summary>
        /// Label for the policy that appears when the GUI is in Global View mode.
        /// </summary>
        [Input("globalLabel")]
        public Input<string>? GlobalLabel { get; set; }

        [Input("groups")]
        private InputList<Inputs.PolicyGroupGetArgs>? _groups;

        /// <summary>
        /// Names of user groups that can authenticate with this policy. The structure of `groups` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyGroupGetArgs> Groups
        {
            get => _groups ?? (_groups = new InputList<Inputs.PolicyGroupGetArgs>());
            set => _groups = value;
        }

        /// <summary>
        /// Redirect HTTP(S) traffic to matching transparent web proxy policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("httpPolicyRedirect")]
        public Input<string>? HttpPolicyRedirect { get; set; }

        /// <summary>
        /// Name of an existing ICAP profile.
        /// </summary>
        [Input("icapProfile")]
        public Input<string>? IcapProfile { get; set; }

        /// <summary>
        /// Name of identity-based routing rule.
        /// </summary>
        [Input("identityBasedRoute")]
        public Input<string>? IdentityBasedRoute { get; set; }

        /// <summary>
        /// Policy-based IPsec VPN: only traffic from the remote network can initiate a VPN. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("inbound")]
        public Input<string>? Inbound { get; set; }

        /// <summary>
        /// Policy inspection mode (Flow/proxy). Default is Flow mode. Valid values: `proxy`, `flow`.
        /// </summary>
        [Input("inspectionMode")]
        public Input<string>? InspectionMode { get; set; }

        /// <summary>
        /// Enable/disable use of Internet Services for this policy. If enabled, destination address and service are not used.  Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetService")]
        public Input<string>? InternetService { get; set; }

        /// <summary>
        /// Enable/disable use of IPv6 Internet Services for this policy. If enabled, destination address and service are not used. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetService6")]
        public Input<string>? InternetService6 { get; set; }

        [Input("internetService6CustomGroups")]
        private InputList<Inputs.PolicyInternetService6CustomGroupGetArgs>? _internetService6CustomGroups;

        /// <summary>
        /// Custom Internet Service6 group name. The structure of `internet_service6_custom_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6CustomGroupGetArgs> InternetService6CustomGroups
        {
            get => _internetService6CustomGroups ?? (_internetService6CustomGroups = new InputList<Inputs.PolicyInternetService6CustomGroupGetArgs>());
            set => _internetService6CustomGroups = value;
        }

        [Input("internetService6Customs")]
        private InputList<Inputs.PolicyInternetService6CustomGetArgs>? _internetService6Customs;

        /// <summary>
        /// Custom IPv6 Internet Service name. The structure of `internet_service6_custom` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6CustomGetArgs> InternetService6Customs
        {
            get => _internetService6Customs ?? (_internetService6Customs = new InputList<Inputs.PolicyInternetService6CustomGetArgs>());
            set => _internetService6Customs = value;
        }

        [Input("internetService6Groups")]
        private InputList<Inputs.PolicyInternetService6GroupGetArgs>? _internetService6Groups;

        /// <summary>
        /// Internet Service group name. The structure of `internet_service6_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6GroupGetArgs> InternetService6Groups
        {
            get => _internetService6Groups ?? (_internetService6Groups = new InputList<Inputs.PolicyInternetService6GroupGetArgs>());
            set => _internetService6Groups = value;
        }

        [Input("internetService6Names")]
        private InputList<Inputs.PolicyInternetService6NameGetArgs>? _internetService6Names;

        /// <summary>
        /// IPv6 Internet Service name. The structure of `internet_service6_name` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6NameGetArgs> InternetService6Names
        {
            get => _internetService6Names ?? (_internetService6Names = new InputList<Inputs.PolicyInternetService6NameGetArgs>());
            set => _internetService6Names = value;
        }

        /// <summary>
        /// When enabled internet-service6 specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetService6Negate")]
        public Input<string>? InternetService6Negate { get; set; }

        /// <summary>
        /// Enable/disable use of IPv6 Internet Services in source for this policy. If enabled, source address is not used. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetService6Src")]
        public Input<string>? InternetService6Src { get; set; }

        [Input("internetService6SrcCustomGroups")]
        private InputList<Inputs.PolicyInternetService6SrcCustomGroupGetArgs>? _internetService6SrcCustomGroups;

        /// <summary>
        /// Custom Internet Service6 source group name. The structure of `internet_service6_src_custom_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6SrcCustomGroupGetArgs> InternetService6SrcCustomGroups
        {
            get => _internetService6SrcCustomGroups ?? (_internetService6SrcCustomGroups = new InputList<Inputs.PolicyInternetService6SrcCustomGroupGetArgs>());
            set => _internetService6SrcCustomGroups = value;
        }

        [Input("internetService6SrcCustoms")]
        private InputList<Inputs.PolicyInternetService6SrcCustomGetArgs>? _internetService6SrcCustoms;

        /// <summary>
        /// Custom IPv6 Internet Service source name. The structure of `internet_service6_src_custom` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6SrcCustomGetArgs> InternetService6SrcCustoms
        {
            get => _internetService6SrcCustoms ?? (_internetService6SrcCustoms = new InputList<Inputs.PolicyInternetService6SrcCustomGetArgs>());
            set => _internetService6SrcCustoms = value;
        }

        [Input("internetService6SrcGroups")]
        private InputList<Inputs.PolicyInternetService6SrcGroupGetArgs>? _internetService6SrcGroups;

        /// <summary>
        /// Internet Service6 source group name. The structure of `internet_service6_src_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6SrcGroupGetArgs> InternetService6SrcGroups
        {
            get => _internetService6SrcGroups ?? (_internetService6SrcGroups = new InputList<Inputs.PolicyInternetService6SrcGroupGetArgs>());
            set => _internetService6SrcGroups = value;
        }

        [Input("internetService6SrcNames")]
        private InputList<Inputs.PolicyInternetService6SrcNameGetArgs>? _internetService6SrcNames;

        /// <summary>
        /// IPv6 Internet Service source name. The structure of `internet_service6_src_name` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetService6SrcNameGetArgs> InternetService6SrcNames
        {
            get => _internetService6SrcNames ?? (_internetService6SrcNames = new InputList<Inputs.PolicyInternetService6SrcNameGetArgs>());
            set => _internetService6SrcNames = value;
        }

        /// <summary>
        /// When enabled internet-service6-src specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetService6SrcNegate")]
        public Input<string>? InternetService6SrcNegate { get; set; }

        [Input("internetServiceCustomGroups")]
        private InputList<Inputs.PolicyInternetServiceCustomGroupGetArgs>? _internetServiceCustomGroups;

        /// <summary>
        /// Custom Internet Service group name. The structure of `internet_service_custom_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceCustomGroupGetArgs> InternetServiceCustomGroups
        {
            get => _internetServiceCustomGroups ?? (_internetServiceCustomGroups = new InputList<Inputs.PolicyInternetServiceCustomGroupGetArgs>());
            set => _internetServiceCustomGroups = value;
        }

        [Input("internetServiceCustoms")]
        private InputList<Inputs.PolicyInternetServiceCustomGetArgs>? _internetServiceCustoms;

        /// <summary>
        /// Custom Internet Service name. The structure of `internet_service_custom` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceCustomGetArgs> InternetServiceCustoms
        {
            get => _internetServiceCustoms ?? (_internetServiceCustoms = new InputList<Inputs.PolicyInternetServiceCustomGetArgs>());
            set => _internetServiceCustoms = value;
        }

        [Input("internetServiceGroups")]
        private InputList<Inputs.PolicyInternetServiceGroupGetArgs>? _internetServiceGroups;

        /// <summary>
        /// Internet Service group name. The structure of `internet_service_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceGroupGetArgs> InternetServiceGroups
        {
            get => _internetServiceGroups ?? (_internetServiceGroups = new InputList<Inputs.PolicyInternetServiceGroupGetArgs>());
            set => _internetServiceGroups = value;
        }

        [Input("internetServiceIds")]
        private InputList<Inputs.PolicyInternetServiceIdGetArgs>? _internetServiceIds;

        /// <summary>
        /// Internet Service ID. The structure of `internet_service_id` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceIdGetArgs> InternetServiceIds
        {
            get => _internetServiceIds ?? (_internetServiceIds = new InputList<Inputs.PolicyInternetServiceIdGetArgs>());
            set => _internetServiceIds = value;
        }

        [Input("internetServiceNames")]
        private InputList<Inputs.PolicyInternetServiceNameGetArgs>? _internetServiceNames;

        /// <summary>
        /// Internet Service name. The structure of `internet_service_name` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceNameGetArgs> InternetServiceNames
        {
            get => _internetServiceNames ?? (_internetServiceNames = new InputList<Inputs.PolicyInternetServiceNameGetArgs>());
            set => _internetServiceNames = value;
        }

        /// <summary>
        /// When enabled internet-service specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetServiceNegate")]
        public Input<string>? InternetServiceNegate { get; set; }

        /// <summary>
        /// Enable/disable use of Internet Services in source for this policy. If enabled, source address is not used.  Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetServiceSrc")]
        public Input<string>? InternetServiceSrc { get; set; }

        [Input("internetServiceSrcCustomGroups")]
        private InputList<Inputs.PolicyInternetServiceSrcCustomGroupGetArgs>? _internetServiceSrcCustomGroups;

        /// <summary>
        /// Custom Internet Service source group name. The structure of `internet_service_src_custom_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceSrcCustomGroupGetArgs> InternetServiceSrcCustomGroups
        {
            get => _internetServiceSrcCustomGroups ?? (_internetServiceSrcCustomGroups = new InputList<Inputs.PolicyInternetServiceSrcCustomGroupGetArgs>());
            set => _internetServiceSrcCustomGroups = value;
        }

        [Input("internetServiceSrcCustoms")]
        private InputList<Inputs.PolicyInternetServiceSrcCustomGetArgs>? _internetServiceSrcCustoms;

        /// <summary>
        /// Custom Internet Service source name. The structure of `internet_service_src_custom` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceSrcCustomGetArgs> InternetServiceSrcCustoms
        {
            get => _internetServiceSrcCustoms ?? (_internetServiceSrcCustoms = new InputList<Inputs.PolicyInternetServiceSrcCustomGetArgs>());
            set => _internetServiceSrcCustoms = value;
        }

        [Input("internetServiceSrcGroups")]
        private InputList<Inputs.PolicyInternetServiceSrcGroupGetArgs>? _internetServiceSrcGroups;

        /// <summary>
        /// Internet Service source group name. The structure of `internet_service_src_group` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceSrcGroupGetArgs> InternetServiceSrcGroups
        {
            get => _internetServiceSrcGroups ?? (_internetServiceSrcGroups = new InputList<Inputs.PolicyInternetServiceSrcGroupGetArgs>());
            set => _internetServiceSrcGroups = value;
        }

        [Input("internetServiceSrcIds")]
        private InputList<Inputs.PolicyInternetServiceSrcIdGetArgs>? _internetServiceSrcIds;

        /// <summary>
        /// Internet Service source ID. The structure of `internet_service_src_id` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceSrcIdGetArgs> InternetServiceSrcIds
        {
            get => _internetServiceSrcIds ?? (_internetServiceSrcIds = new InputList<Inputs.PolicyInternetServiceSrcIdGetArgs>());
            set => _internetServiceSrcIds = value;
        }

        [Input("internetServiceSrcNames")]
        private InputList<Inputs.PolicyInternetServiceSrcNameGetArgs>? _internetServiceSrcNames;

        /// <summary>
        /// Internet Service source name. The structure of `internet_service_src_name` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyInternetServiceSrcNameGetArgs> InternetServiceSrcNames
        {
            get => _internetServiceSrcNames ?? (_internetServiceSrcNames = new InputList<Inputs.PolicyInternetServiceSrcNameGetArgs>());
            set => _internetServiceSrcNames = value;
        }

        /// <summary>
        /// When enabled internet-service-src specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("internetServiceSrcNegate")]
        public Input<string>? InternetServiceSrcNegate { get; set; }

        /// <summary>
        /// Enable to use IP Pools for source NAT. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("ippool")]
        public Input<string>? Ippool { get; set; }

        /// <summary>
        /// Name of an existing IPS sensor.
        /// </summary>
        [Input("ipsSensor")]
        public Input<string>? IpsSensor { get; set; }

        /// <summary>
        /// Name of an existing VoIP (ips) profile.
        /// </summary>
        [Input("ipsVoipFilter")]
        public Input<string>? IpsVoipFilter { get; set; }

        /// <summary>
        /// Label for the policy that appears when the GUI is in Section View mode.
        /// </summary>
        [Input("label")]
        public Input<string>? Label { get; set; }

        /// <summary>
        /// Enable to allow everything, but log all of the meaningful data for security information gathering. A learning report will be generated. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("learningMode")]
        public Input<string>? LearningMode { get; set; }

        /// <summary>
        /// Enable or disable logging. Log all sessions or security profile sessions. Valid values: `all`, `utm`, `disable`.
        /// </summary>
        [Input("logtraffic")]
        public Input<string>? Logtraffic { get; set; }

        /// <summary>
        /// Record logs when a session starts. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("logtrafficStart")]
        public Input<string>? LogtrafficStart { get; set; }

        /// <summary>
        /// Enable to match packets that have had their destination addresses changed by a VIP. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("matchVip")]
        public Input<string>? MatchVip { get; set; }

        /// <summary>
        /// Enable/disable matching of only those packets that have had their destination addresses changed by a VIP. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("matchVipOnly")]
        public Input<string>? MatchVipOnly { get; set; }

        /// <summary>
        /// Policy name.
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// Enable/disable source NAT. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("nat")]
        public Input<string>? Nat { get; set; }

        /// <summary>
        /// Enable/disable NAT46. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("nat46")]
        public Input<string>? Nat46 { get; set; }

        /// <summary>
        /// Enable/disable NAT64. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("nat64")]
        public Input<string>? Nat64 { get; set; }

        /// <summary>
        /// Policy-based IPsec VPN: apply destination NAT to inbound traffic. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("natinbound")]
        public Input<string>? Natinbound { get; set; }

        /// <summary>
        /// Policy-based IPsec VPN: source NAT IP address for outgoing traffic.
        /// </summary>
        [Input("natip")]
        public Input<string>? Natip { get; set; }

        /// <summary>
        /// Policy-based IPsec VPN: apply source NAT to outbound traffic. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("natoutbound")]
        public Input<string>? Natoutbound { get; set; }

        [Input("networkServiceDynamics")]
        private InputList<Inputs.PolicyNetworkServiceDynamicGetArgs>? _networkServiceDynamics;

        /// <summary>
        /// Dynamic Network Service name. The structure of `network_service_dynamic` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyNetworkServiceDynamicGetArgs> NetworkServiceDynamics
        {
            get => _networkServiceDynamics ?? (_networkServiceDynamics = new InputList<Inputs.PolicyNetworkServiceDynamicGetArgs>());
            set => _networkServiceDynamics = value;
        }

        [Input("networkServiceSrcDynamics")]
        private InputList<Inputs.PolicyNetworkServiceSrcDynamicGetArgs>? _networkServiceSrcDynamics;

        /// <summary>
        /// Dynamic Network Service source name. The structure of `network_service_src_dynamic` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyNetworkServiceSrcDynamicGetArgs> NetworkServiceSrcDynamics
        {
            get => _networkServiceSrcDynamics ?? (_networkServiceSrcDynamics = new InputList<Inputs.PolicyNetworkServiceSrcDynamicGetArgs>());
            set => _networkServiceSrcDynamics = value;
        }

        /// <summary>
        /// Enable/disable UTM Network Processor acceleration. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("npAcceleration")]
        public Input<string>? NpAcceleration { get; set; }

        /// <summary>
        /// Enable/disable NTLM authentication. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("ntlm")]
        public Input<string>? Ntlm { get; set; }

        [Input("ntlmEnabledBrowsers")]
        private InputList<Inputs.PolicyNtlmEnabledBrowserGetArgs>? _ntlmEnabledBrowsers;

        /// <summary>
        /// HTTP-User-Agent value of supported browsers. The structure of `ntlm_enabled_browsers` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyNtlmEnabledBrowserGetArgs> NtlmEnabledBrowsers
        {
            get => _ntlmEnabledBrowsers ?? (_ntlmEnabledBrowsers = new InputList<Inputs.PolicyNtlmEnabledBrowserGetArgs>());
            set => _ntlmEnabledBrowsers = value;
        }

        /// <summary>
        /// Enable/disable NTLM guest user access. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("ntlmGuest")]
        public Input<string>? NtlmGuest { get; set; }

        /// <summary>
        /// Policy-based IPsec VPN: only traffic from the internal network can initiate a VPN. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("outbound")]
        public Input<string>? Outbound { get; set; }

        /// <summary>
        /// Enable/disable passive WAN health measurement. When enabled, auto-asic-offload is disabled. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("passiveWanHealthMeasurement")]
        public Input<string>? PassiveWanHealthMeasurement { get; set; }

        /// <summary>
        /// Enable/disable PCP inbound DNAT. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("pcpInbound")]
        public Input<string>? PcpInbound { get; set; }

        /// <summary>
        /// Enable/disable PCP outbound SNAT. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("pcpOutbound")]
        public Input<string>? PcpOutbound { get; set; }

        [Input("pcpPoolnames")]
        private InputList<Inputs.PolicyPcpPoolnameGetArgs>? _pcpPoolnames;

        /// <summary>
        /// PCP pool names. The structure of `pcp_poolname` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyPcpPoolnameGetArgs> PcpPoolnames
        {
            get => _pcpPoolnames ?? (_pcpPoolnames = new InputList<Inputs.PolicyPcpPoolnameGetArgs>());
            set => _pcpPoolnames = value;
        }

        /// <summary>
        /// Per-IP traffic shaper.
        /// </summary>
        [Input("perIpShaper")]
        public Input<string>? PerIpShaper { get; set; }

        /// <summary>
        /// Accept UDP packets from any host. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("permitAnyHost")]
        public Input<string>? PermitAnyHost { get; set; }

        /// <summary>
        /// Accept UDP packets from any Session Traversal Utilities for NAT (STUN) host. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("permitStunHost")]
        public Input<string>? PermitStunHost { get; set; }

        /// <summary>
        /// Enable/disable policy expiry. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("policyExpiry")]
        public Input<string>? PolicyExpiry { get; set; }

        /// <summary>
        /// Policy expiry date (YYYY-MM-DD HH:MM:SS).
        /// </summary>
        [Input("policyExpiryDate")]
        public Input<string>? PolicyExpiryDate { get; set; }

        /// <summary>
        /// Policy expiry date and time, in epoch format.
        /// </summary>
        [Input("policyExpiryDateUtc")]
        public Input<string>? PolicyExpiryDateUtc { get; set; }

        /// <summary>
        /// Policy ID.
        /// </summary>
        [Input("policyid")]
        public Input<int>? Policyid { get; set; }

        [Input("poolname6s")]
        private InputList<Inputs.PolicyPoolname6GetArgs>? _poolname6s;

        /// <summary>
        /// IPv6 pool names. The structure of `poolname6` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyPoolname6GetArgs> Poolname6s
        {
            get => _poolname6s ?? (_poolname6s = new InputList<Inputs.PolicyPoolname6GetArgs>());
            set => _poolname6s = value;
        }

        [Input("poolnames")]
        private InputList<Inputs.PolicyPoolnameGetArgs>? _poolnames;

        /// <summary>
        /// IP Pool names. The structure of `poolname` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyPoolnameGetArgs> Poolnames
        {
            get => _poolnames ?? (_poolnames = new InputList<Inputs.PolicyPoolnameGetArgs>());
            set => _poolnames = value;
        }

        /// <summary>
        /// Name of profile group.
        /// </summary>
        [Input("profileGroup")]
        public Input<string>? ProfileGroup { get; set; }

        /// <summary>
        /// Name of an existing Protocol options profile.
        /// </summary>
        [Input("profileProtocolOptions")]
        public Input<string>? ProfileProtocolOptions { get; set; }

        /// <summary>
        /// Determine whether the firewall policy allows security profile groups or single profiles only. Valid values: `single`, `group`.
        /// </summary>
        [Input("profileType")]
        public Input<string>? ProfileType { get; set; }

        /// <summary>
        /// Enable MAC authentication bypass. The bypassed MAC address must be received from RADIUS server. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("radiusMacAuthBypass")]
        public Input<string>? RadiusMacAuthBypass { get; set; }

        /// <summary>
        /// URL users are directed to after seeing and accepting the disclaimer or authenticating.
        /// </summary>
        [Input("redirectUrl")]
        public Input<string>? RedirectUrl { get; set; }

        /// <summary>
        /// Override the default replacement message group for this policy.
        /// </summary>
        [Input("replacemsgOverrideGroup")]
        public Input<string>? ReplacemsgOverrideGroup { get; set; }

        /// <summary>
        /// Direction of the initial traffic for reputation to take effect. Valid values: `source`, `destination`.
        /// </summary>
        [Input("reputationDirection")]
        public Input<string>? ReputationDirection { get; set; }

        /// <summary>
        /// Direction of the initial traffic for IPv6 reputation to take effect. Valid values: `source`, `destination`.
        /// </summary>
        [Input("reputationDirection6")]
        public Input<string>? ReputationDirection6 { get; set; }

        /// <summary>
        /// Minimum Reputation to take action.
        /// </summary>
        [Input("reputationMinimum")]
        public Input<int>? ReputationMinimum { get; set; }

        /// <summary>
        /// IPv6 Minimum Reputation to take action.
        /// </summary>
        [Input("reputationMinimum6")]
        public Input<int>? ReputationMinimum6 { get; set; }

        /// <summary>
        /// Enable/disable RADIUS single sign-on (RSSO). Valid values: `enable`, `disable`.
        /// </summary>
        [Input("rsso")]
        public Input<string>? Rsso { get; set; }

        [Input("rtpAddrs")]
        private InputList<Inputs.PolicyRtpAddrGetArgs>? _rtpAddrs;

        /// <summary>
        /// Address names if this is an RTP NAT policy. The structure of `rtp_addr` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyRtpAddrGetArgs> RtpAddrs
        {
            get => _rtpAddrs ?? (_rtpAddrs = new InputList<Inputs.PolicyRtpAddrGetArgs>());
            set => _rtpAddrs = value;
        }

        /// <summary>
        /// Enable Real Time Protocol (RTP) NAT. Valid values: `disable`, `enable`.
        /// </summary>
        [Input("rtpNat")]
        public Input<string>? RtpNat { get; set; }

        /// <summary>
        /// Block or monitor connections to Botnet servers or disable Botnet scanning. Valid values: `disable`, `block`, `monitor`.
        /// </summary>
        [Input("scanBotnetConnections")]
        public Input<string>? ScanBotnetConnections { get; set; }

        /// <summary>
        /// Schedule name.(Default is `always`)
        /// </summary>
        [Input("schedule")]
        public Input<string>? Schedule { get; set; }

        /// <summary>
        /// Enable to force current sessions to end when the schedule object times out. Disable allows them to end from inactivity. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("scheduleTimeout")]
        public Input<string>? ScheduleTimeout { get; set; }

        /// <summary>
        /// Name of an existing SCTP filter profile.
        /// </summary>
        [Input("sctpFilterProfile")]
        public Input<string>? SctpFilterProfile { get; set; }

        /// <summary>
        /// Enable to send a reply when a session is denied or blocked by a firewall policy. Valid values: `disable`, `enable`.
        /// </summary>
        [Input("sendDenyPacket")]
        public Input<string>? SendDenyPacket { get; set; }

        /// <summary>
        /// When enabled service specifies what the service must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("serviceNegate")]
        public Input<string>? ServiceNegate { get; set; }

        [Input("services")]
        private InputList<Inputs.PolicyServiceGetArgs>? _services;

        /// <summary>
        /// Service and service group names. The structure of `service` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyServiceGetArgs> Services
        {
            get => _services ?? (_services = new InputList<Inputs.PolicyServiceGetArgs>());
            set => _services = value;
        }

        /// <summary>
        /// TTL in seconds for sessions accepted by this policy (0 means use the system default session TTL).
        /// </summary>
        [Input("sessionTtl")]
        public Input<int>? SessionTtl { get; set; }

        /// <summary>
        /// Enable/disable security group tags (SGT) check. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("sgtCheck")]
        public Input<string>? SgtCheck { get; set; }

        [Input("sgts")]
        private InputList<Inputs.PolicySgtGetArgs>? _sgts;

        /// <summary>
        /// Security group tags. The structure of `sgt` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicySgtGetArgs> Sgts
        {
            get => _sgts ?? (_sgts = new InputList<Inputs.PolicySgtGetArgs>());
            set => _sgts = value;
        }

        /// <summary>
        /// Name of an existing Spam filter profile.
        /// </summary>
        [Input("spamfilterProfile")]
        public Input<string>? SpamfilterProfile { get; set; }

        [Input("srcVendorMacs")]
        private InputList<Inputs.PolicySrcVendorMacGetArgs>? _srcVendorMacs;

        /// <summary>
        /// Vendor MAC source ID. The structure of `src_vendor_mac` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicySrcVendorMacGetArgs> SrcVendorMacs
        {
            get => _srcVendorMacs ?? (_srcVendorMacs = new InputList<Inputs.PolicySrcVendorMacGetArgs>());
            set => _srcVendorMacs = value;
        }

        /// <summary>
        /// When enabled srcaddr6 specifies what the source address must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("srcaddr6Negate")]
        public Input<string>? Srcaddr6Negate { get; set; }

        [Input("srcaddr6s")]
        private InputList<Inputs.PolicySrcaddr6GetArgs>? _srcaddr6s;

        /// <summary>
        /// Source IPv6 address name and address group names. The structure of `srcaddr6` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicySrcaddr6GetArgs> Srcaddr6s
        {
            get => _srcaddr6s ?? (_srcaddr6s = new InputList<Inputs.PolicySrcaddr6GetArgs>());
            set => _srcaddr6s = value;
        }

        /// <summary>
        /// When enabled srcaddr specifies what the source address must NOT be. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("srcaddrNegate")]
        public Input<string>? SrcaddrNegate { get; set; }

        [Input("srcaddrs")]
        private InputList<Inputs.PolicySrcaddrGetArgs>? _srcaddrs;

        /// <summary>
        /// Source address and address group names. The structure of `srcaddr` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicySrcaddrGetArgs> Srcaddrs
        {
            get => _srcaddrs ?? (_srcaddrs = new InputList<Inputs.PolicySrcaddrGetArgs>());
            set => _srcaddrs = value;
        }

        [Input("srcintfs")]
        private InputList<Inputs.PolicySrcintfGetArgs>? _srcintfs;

        /// <summary>
        /// Incoming (ingress) interface. The structure of `srcintf` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicySrcintfGetArgs> Srcintfs
        {
            get => _srcintfs ?? (_srcintfs = new InputList<Inputs.PolicySrcintfGetArgs>());
            set => _srcintfs = value;
        }

        /// <summary>
        /// Name of an existing SSH filter profile.
        /// </summary>
        [Input("sshFilterProfile")]
        public Input<string>? SshFilterProfile { get; set; }

        /// <summary>
        /// Redirect SSH traffic to matching transparent proxy policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("sshPolicyRedirect")]
        public Input<string>? SshPolicyRedirect { get; set; }

        /// <summary>
        /// Enable to copy decrypted SSL traffic to a FortiGate interface (called SSL mirroring). Valid values: `enable`, `disable`.
        /// </summary>
        [Input("sslMirror")]
        public Input<string>? SslMirror { get; set; }

        [Input("sslMirrorIntfs")]
        private InputList<Inputs.PolicySslMirrorIntfGetArgs>? _sslMirrorIntfs;

        /// <summary>
        /// SSL mirror interface name. The structure of `ssl_mirror_intf` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicySslMirrorIntfGetArgs> SslMirrorIntfs
        {
            get => _sslMirrorIntfs ?? (_sslMirrorIntfs = new InputList<Inputs.PolicySslMirrorIntfGetArgs>());
            set => _sslMirrorIntfs = value;
        }

        /// <summary>
        /// Name of an existing SSL SSH profile.
        /// </summary>
        [Input("sslSshProfile")]
        public Input<string>? SslSshProfile { get; set; }

        /// <summary>
        /// Enable or disable this policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("status")]
        public Input<string>? Status { get; set; }

        /// <summary>
        /// Receiver TCP maximum segment size (MSS).
        /// </summary>
        [Input("tcpMssReceiver")]
        public Input<int>? TcpMssReceiver { get; set; }

        /// <summary>
        /// Sender TCP maximum segment size (MSS).
        /// </summary>
        [Input("tcpMssSender")]
        public Input<int>? TcpMssSender { get; set; }

        /// <summary>
        /// Enable/disable creation of TCP session without SYN flag. Valid values: `all`, `data-only`, `disable`.
        /// </summary>
        [Input("tcpSessionWithoutSyn")]
        public Input<string>? TcpSessionWithoutSyn { get; set; }

        /// <summary>
        /// Enable/disable sending RST packets when TCP sessions expire. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("timeoutSendRst")]
        public Input<string>? TimeoutSendRst { get; set; }

        /// <summary>
        /// ToS (Type of Service) value used for comparison.
        /// </summary>
        [Input("tos")]
        public Input<string>? Tos { get; set; }

        /// <summary>
        /// Non-zero bit positions are used for comparison while zero bit positions are ignored.
        /// </summary>
        [Input("tosMask")]
        public Input<string>? TosMask { get; set; }

        /// <summary>
        /// Enable negated TOS match. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("tosNegate")]
        public Input<string>? TosNegate { get; set; }

        /// <summary>
        /// Traffic shaper.
        /// </summary>
        [Input("trafficShaper")]
        public Input<string>? TrafficShaper { get; set; }

        /// <summary>
        /// Reverse traffic shaper.
        /// </summary>
        [Input("trafficShaperReverse")]
        public Input<string>? TrafficShaperReverse { get; set; }

        [Input("urlCategories")]
        private InputList<Inputs.PolicyUrlCategoryGetArgs>? _urlCategories;

        /// <summary>
        /// URL category ID list. The structure of `url_category` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyUrlCategoryGetArgs> UrlCategories
        {
            get => _urlCategories ?? (_urlCategories = new InputList<Inputs.PolicyUrlCategoryGetArgs>());
            set => _urlCategories = value;
        }

        [Input("users")]
        private InputList<Inputs.PolicyUserGetArgs>? _users;

        /// <summary>
        /// Names of individual users that can authenticate with this policy. The structure of `users` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyUserGetArgs> Users
        {
            get => _users ?? (_users = new InputList<Inputs.PolicyUserGetArgs>());
            set => _users = value;
        }

        /// <summary>
        /// Enable to add one or more security profiles (AV, IPS, etc.) to the firewall policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("utmStatus")]
        public Input<string>? UtmStatus { get; set; }

        /// <summary>
        /// Universally Unique Identifier (UUID; automatically assigned but can be manually reset).
        /// </summary>
        [Input("uuid")]
        public Input<string>? Uuid { get; set; }

        /// <summary>
        /// Specifies the vdom to which the resource will be applied when the FortiGate unit is running in VDOM mode. Only one vdom can be specified. If you want to inherit the vdom configuration of the provider, please do not set this parameter.
        /// </summary>
        [Input("vdomparam")]
        public Input<string>? Vdomparam { get; set; }

        /// <summary>
        /// Name of an existing VideoFilter profile.
        /// </summary>
        [Input("videofilterProfile")]
        public Input<string>? VideofilterProfile { get; set; }

        /// <summary>
        /// Name of an existing virtual-patch profile.
        /// </summary>
        [Input("virtualPatchProfile")]
        public Input<string>? VirtualPatchProfile { get; set; }

        /// <summary>
        /// VLAN forward direction user priority: 255 passthrough, 0 lowest, 7 highest.
        /// </summary>
        [Input("vlanCosFwd")]
        public Input<int>? VlanCosFwd { get; set; }

        /// <summary>
        /// VLAN reverse direction user priority: 255 passthrough, 0 lowest, 7 highest.
        /// </summary>
        [Input("vlanCosRev")]
        public Input<int>? VlanCosRev { get; set; }

        /// <summary>
        /// Set VLAN filters.
        /// </summary>
        [Input("vlanFilter")]
        public Input<string>? VlanFilter { get; set; }

        /// <summary>
        /// Name of an existing VoIP (voipd) profile.
        /// </summary>
        [Input("voipProfile")]
        public Input<string>? VoipProfile { get; set; }

        /// <summary>
        /// Policy-based IPsec VPN: name of the IPsec VPN Phase 1.
        /// </summary>
        [Input("vpntunnel")]
        public Input<string>? Vpntunnel { get; set; }

        /// <summary>
        /// Name of an existing Web application firewall profile.
        /// </summary>
        [Input("wafProfile")]
        public Input<string>? WafProfile { get; set; }

        /// <summary>
        /// Enable/disable WAN optimization. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("wanopt")]
        public Input<string>? Wanopt { get; set; }

        /// <summary>
        /// WAN optimization auto-detection mode. Valid values: `active`, `passive`, `off`.
        /// </summary>
        [Input("wanoptDetection")]
        public Input<string>? WanoptDetection { get; set; }

        /// <summary>
        /// WAN optimization passive mode options. This option decides what IP address will be used to connect server. Valid values: `default`, `transparent`, `non-transparent`.
        /// </summary>
        [Input("wanoptPassiveOpt")]
        public Input<string>? WanoptPassiveOpt { get; set; }

        /// <summary>
        /// WAN optimization peer.
        /// </summary>
        [Input("wanoptPeer")]
        public Input<string>? WanoptPeer { get; set; }

        /// <summary>
        /// WAN optimization profile.
        /// </summary>
        [Input("wanoptProfile")]
        public Input<string>? WanoptProfile { get; set; }

        /// <summary>
        /// Enable/disable forwarding traffic matching this policy to a configured WCCP server. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("wccp")]
        public Input<string>? Wccp { get; set; }

        /// <summary>
        /// Enable/disable web cache. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("webcache")]
        public Input<string>? Webcache { get; set; }

        /// <summary>
        /// Enable/disable web cache for HTTPS. Valid values: `disable`, `enable`.
        /// </summary>
        [Input("webcacheHttps")]
        public Input<string>? WebcacheHttps { get; set; }

        /// <summary>
        /// Name of an existing Web filter profile.
        /// </summary>
        [Input("webfilterProfile")]
        public Input<string>? WebfilterProfile { get; set; }

        /// <summary>
        /// Web proxy forward server name.
        /// </summary>
        [Input("webproxyForwardServer")]
        public Input<string>? WebproxyForwardServer { get; set; }

        /// <summary>
        /// Webproxy profile name.
        /// </summary>
        [Input("webproxyProfile")]
        public Input<string>? WebproxyProfile { get; set; }

        /// <summary>
        /// Enable/disable WiFi Single Sign On (WSSO). Valid values: `enable`, `disable`.
        /// </summary>
        [Input("wsso")]
        public Input<string>? Wsso { get; set; }

        /// <summary>
        /// Enable/disable zero trust device ownership. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("ztnaDeviceOwnership")]
        public Input<string>? ZtnaDeviceOwnership { get; set; }

        [Input("ztnaEmsTagSecondaries")]
        private InputList<Inputs.PolicyZtnaEmsTagSecondaryGetArgs>? _ztnaEmsTagSecondaries;

        /// <summary>
        /// Source ztna-ems-tag-secondary names. The structure of `ztna_ems_tag_secondary` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyZtnaEmsTagSecondaryGetArgs> ZtnaEmsTagSecondaries
        {
            get => _ztnaEmsTagSecondaries ?? (_ztnaEmsTagSecondaries = new InputList<Inputs.PolicyZtnaEmsTagSecondaryGetArgs>());
            set => _ztnaEmsTagSecondaries = value;
        }

        [Input("ztnaEmsTags")]
        private InputList<Inputs.PolicyZtnaEmsTagGetArgs>? _ztnaEmsTags;

        /// <summary>
        /// Source ztna-ems-tag names. The structure of `ztna_ems_tag` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyZtnaEmsTagGetArgs> ZtnaEmsTags
        {
            get => _ztnaEmsTags ?? (_ztnaEmsTags = new InputList<Inputs.PolicyZtnaEmsTagGetArgs>());
            set => _ztnaEmsTags = value;
        }

        [Input("ztnaGeoTags")]
        private InputList<Inputs.PolicyZtnaGeoTagGetArgs>? _ztnaGeoTags;

        /// <summary>
        /// Source ztna-geo-tag names. The structure of `ztna_geo_tag` block is documented below.
        /// </summary>
        public InputList<Inputs.PolicyZtnaGeoTagGetArgs> ZtnaGeoTags
        {
            get => _ztnaGeoTags ?? (_ztnaGeoTags = new InputList<Inputs.PolicyZtnaGeoTagGetArgs>());
            set => _ztnaGeoTags = value;
        }

        /// <summary>
        /// Redirect ZTNA traffic to matching Access-Proxy proxy-policy. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("ztnaPolicyRedirect")]
        public Input<string>? ZtnaPolicyRedirect { get; set; }

        /// <summary>
        /// Enable/disable zero trust access. Valid values: `enable`, `disable`.
        /// </summary>
        [Input("ztnaStatus")]
        public Input<string>? ZtnaStatus { get; set; }

        /// <summary>
        /// ZTNA tag matching logic. Valid values: `or`, `and`.
        /// </summary>
        [Input("ztnaTagsMatchLogic")]
        public Input<string>? ZtnaTagsMatchLogic { get; set; }

        public PolicyState()
        {
        }
        public static new PolicyState Empty => new PolicyState();
    }
}
